<!-- Start of file boot-new/boot-new.xml -->
<!-- $Id: boot-new.xml 56817 2008-11-30 08:13:01Z fjp $ -->

<chapter id="boot-new">
 <title
>새로운 데비안 시스템으로 부팅하기</title>

 <sect1 id="base-boot"
><title
>진실의 시간</title>
<para
>시스템이 혼자 힘으로 하는 최초의 부팅을 전기 엔지니어들은 <quote
>스모크 테스트(smoke test)</quote
>라고 부릅니다. </para
><para arch="x86"
>기본값으로 설치를 마쳤다면, 시스템을 부팅할 때 맨 처음에 <classname
>grub</classname
> 메뉴나 <classname
>lilo</classname
> 부트로더가 나타날 것입니다. 메뉴의 첫번째로 들어가면 새로 설치한 데비안 시스템입니다. 설치할 때 컴퓨터의 다른 운영 체제를 (윈도우즈 등) 찾았다면 그 운영 체제도 메뉴의 아래 부분에 있습니다. </para
><para
>시스템이 제대로 시작하지 않아도 당황하지 마십시오. 설치할 때 문제가 없었다면, 대부분은 데비안 부팅만 안 되는 비교적 작은 문제일 뿐입니다. 이러한 문제는 보통 다시 설치하지 않더라도 해결할 수 있습니다. 해결하는 한 가지 방법은 설치 프로그램에 내장된 응급 복구 모드를 이용하는 것입니다. (<xref linkend="rescue"/> 참고.) </para
><para
>데비안 및 리눅스를 처음 접한다면, 좀 더 경험이 많은 사람에게 도움을 청해야 할 경우도 있습니다. <phrase arch="x86"
>직접적인 온라인 도움을 요청하려면 OFTC 네트워크의 #debian이나 #debian-boot를 이용해 보십시오. 아니면 <ulink url="&url-list-subscribe;"
>debian-user 메일링 리스트</ulink
>에 연락할 수도 있습니다.</phrase
> <phrase arch="not-x86"
>&arch-title;처럼 많이 사용하지 않는 아키텍처의 경우에는, <ulink url="&url-list-subscribe;"
>debian-&arch-listname; 메일링 리스트</ulink
>를 이용하는 게 가장 좋습니다.</phrase
> <xref linkend="submit-bug"/>의 설명에 따라 설치 보고서를 제출할 수도 있습니다. 여러분이 겪은 문제를 분명하게 설명하고 화면에 표시된 메세지를 모두 포함해 주십시오. 그래야 다른 사람이 더 쉽게 이 문제를 파악할 수 있습니다. </para
><para arch="x86"
>컴퓨터에 다른 운영 체제가 있지만 설치할 때 찾지 못했거나 제대로 찾지 못했다면, 설치 보고서를 제출하십시오. </para>

  <sect2 arch="m68k"
><title
>BVME 6000 부팅</title>
<para
>만일 BVM 또는 모토로라 VMEbus 컴퓨터에 디스크 없이 (diskless) 설치를 수행한 직후라면, TFTP 서버에서 <command
>tftplilo</command
> 프로그램을 로드한 뒤에 <prompt
>LILO Boot:</prompt
> 프롬프트에서 다음 중 하나를 입력합니다: <itemizedlist>
<listitem
><para
>BVME 4000/6000에서 부팅하려면, <userinput
>b6000</userinput
>이라고 입력하고 &enterkey;를 누릅니다. </para
></listitem
><listitem
><para
>MVME162에서 부팅하려면, <userinput
>b162</userinput
>라고 입력하고 &enterkey;를 누릅니다. </para
></listitem
><listitem
><para
>MVME166/167에서 부팅하려면, <userinput
>b167</userinput
>이라고 입력하고 &enterkey;를 누릅니다. </para
></listitem>
</itemizedlist>

</para>

   </sect2>

  <sect2 arch="m68k"
><title
>매킨토시 부팅</title>

<para
>설치 파일이 들어 있는 디렉토리로 가서, <keycap
>command</keycap
>을 누른채로 <command
>Penguin</command
> booter를 시작합니다. <userinput
>Settings</userinput
> 대화 상자로 가서 (<keycombo
> <keycap
>command</keycap
> <keycap
>T</keycap
> </keycombo
>), <userinput
>root=/dev/ram ramdisk_size=15000</userinput
>처럼 되어 있는 커널 옵션을 찾으십시오. </para
><para
>해당 항목을 <userinput
>root=/dev/<replaceable
>yyyy</replaceable
></userinput
>로 바꿔야 합니다. <replaceable
>yyyy</replaceable
>는 시스템을 설치한 파티션의 리눅스 이름입니다. (예를 들어 <filename
>/dev/sda1</filename
>.) 앞에서 이 이름을 적어 뒀어야 합니다. 화면이 작은 사용자의 경우 <userinput
>fbcon=font:VGA8x8</userinput
> (혹은 2.6보다 오래된 커널의 경우 <userinput
>video=font:VGA8x8</userinput
>) 설정을 하면 더 보기 좋습니다. 이 설정은 언제든 바꿀 수 있습니다. </para
><para
>시작할 때 즉시 GNU/리눅스로 시작하지 않으려면, <userinput
>Auto Boot</userinput
> 옵션을 사용하지 마십시오. <userinput
>Save Settings As Default</userinput
> 옵션을 사용해 설정을 <filename
>Prefs</filename
> 파일에 저장하십시오. </para
><para
>이제 <userinput
>Boot Now</userinput
> (<keycombo
> <keycap
>command</keycap
> <keycap
>B</keycap
> </keycombo
>) 명령어로 램디스크에 설치한 시스템이 아니라 새롭게 설치한 GNU/리눅스를 시작합니다. </para
><para
>데비안이 부팅하고, 처음 설치 시스템 부팅할 때와 똑같은 메시지가 나오고, 뒤이어서 처음 보는 메시지도 나올 것입니다. </para>
   </sect2>


  <sect2 arch="powerpc"
><title
>올드월드 파워맥</title>
<para
>설치를 마친 다음 부팅이 실패하면, <prompt
>boot:</prompt
> 프롬프트에서 멈춰서 <userinput
>Linux</userinput
>를 입력해보십시오. (<filename
>quik.conf</filename
> 안에 기본 부팅 설정이 Linux라는 레이블로 되어 있습니다.) <prompt
>boot:</prompt
> 프롬프트에서 <keycap
>Tab</keycap
> 키를 누르면 <filename
>quik.conf</filename
>에 정의한 레이블 목록을 표시합니다. 설치 프로그램으로 돌아가 <guimenuitem
>Install Quik on a Hard Disk</guimenuitem
> 단계에서 설정한 <filename
>/target/etc/quik.conf</filename
> 파일을 바꿔서 부팅할 수도 있습니다. <command
>quik</command
>를 사용하는 여러가지 힌트는 <ulink url="&url-powerpc-quik-faq;"
></ulink
>에서 읽을 수 있습니다. </para
><para
>nvram을 리셋하지 않고 맥오에스로 다시 부팅하려면, OpenFirmware 프롬프트에서 <userinput
>bye</userinput
>를 입력합니다. (맥오에스를 컴퓨터에서 지우지 않았다고 가정합니다.) 콜드 부팅하는 동안 <keycombo
> <keycap
>command</keycap
> <keycap
>option</keycap
> <keycap
>o</keycap
> <keycap
>f</keycap
> </keycombo
> 키를 누르고 있으면 OpenFirmware 프롬프트가 나타납니다. OpenFirmware nvram을 리셋해서 맥오에스 기본값으로 돌아가려면 (다시 맥오에스 부팅으로 돌아가려면), 콜드 부팅하는 동안 <keycombo
> <keycap
>command</keycap
> <keycap
>option</keycap
> <keycap
>p</keycap
> <keycap
>r</keycap
> </keycombo
> 키를 누르고 있으십시오. </para
><para
>설치한 시스템으로 부팅할 때 <command
>BootX</command
>를 사용한다면, <filename
>Linux Kernels</filename
> 폴더에서 원하는 커널을 선택하고, 램디스크 옵션의 선택을 해제한 뒤에 설치에 사용한 루트 장치 이름을 입력하십시오. 예를 들어 <userinput
>/dev/hda8</userinput
>과 같이 씁니다. </para>
   </sect2>


  <sect2 arch="powerpc"
><title
>뉴월드 파워맥</title>
<para
>G4와 아이북에서 <keycap
>option</keycap
> 키를 누르고 있으면, 부팅 가능한 운영 체제마다 단추가 하나씩 있는 그래픽 화면이 나타납니다. &debian;는 작은 펭귄 아이콘이 들어 있는 단추입니다. </para
><para
>맥오에스를 계속 유지하는 경우 맥오에스에서 OpenFirmware의 <envar
>boot-device</envar
> 변수를 바꾸면, OpenFirmware를 기본값 설정으로 리셋해야 합니다. 리셋하려면 콜드 부팅하는 동안 <keycombo
> <keycap
>command</keycap
> <keycap
>option</keycap
> <keycap
>p</keycap
> <keycap
>r</keycap
> </keycombo
> 키를 누르고 있으십시오. </para
><para
><prompt
>boot:</prompt
> 프롬프트에서 <keycap
>tab</keycap
> 키를 누르면 <filename
>yaboot.conf</filename
>에 정의한 레이블을 표시합니다. </para
><para
>G3 또는 G4 하드웨어에서 OpenFirmware를 리셋하면 기본으로 &debian;를 부팅합니다. (올바르게 파티션을 나누고 Apple_Bootstrap 파티션이 앞쪽에 놓여 있는 경우.) 데비안이 SCSI 디스크에 들어 있고 맥오에스가 IDE 디스크에 들어 있으면, 리셋해도 데비안으로 부팅하지 않을 것입니다. OpenFirmware에 들어가 <envar
>boot-device</envar
> 변수를 설정해야 합니다. <command
>ybin</command
> 프로그램을 이용하면 이 변수 설정을 자동으로 합니다. </para
><para
>&debian;가 처음으로 부팅하면, <filename
>/etc/yaboot.conf</filename
>에 (듀얼 부팅 옵션 등) 원하는 어떤 옵션이라도 추가 할 수 있고, <command
>ybin</command
>를 실행하면 바꾼 설정에 맞춰 부팅 파티션을 업데이트할 수 있습니다. 더 자세한 정보는 <ulink url="&url-powerpc-yaboot-faq;"
>yaboot HOWTO</ulink
>를 읽어 보십시오. </para>
   </sect2>
 </sect1>


<!-- Start of file boot-new/mount-encrypted.xml -->
<!-- $Id: mount-encrypted.xml 56326 2008-10-06 23:03:54Z fjp $ -->

 <sect1 id="mount-encrypted-volumes">
 <title
>암호화 볼륨 마운트하기</title>

<para
>설치할 때 암호화 볼륨을 만들고 마운트 위치를 지정했다면, 부팅할 때 각각의 볼륨에 대해 암호를 입력하게 됩니다. 실제 절차는 dm-crypt와 loop-AES가 약간 다릅니다. </para>

  <sect2 id="mount-dm-crypt">
  <title
>dm-crypt</title>

<para
>dm-crypt로 암호화한 파티션의 경우 부팅할 때 다음과 같이 물어봅니다: <informalexample
><screen>
Starting early crypto disks... <replaceable
>part</replaceable
>_crypt(starting)
Enter LUKS passphrase:
</screen
></informalexample
> 첫번째 줄에서, <replaceable
>part</replaceable
>는 실제 파티션의 이름입니다. (예를 들어 sda2나 md0.) 여기에서 과연 <emphasis
>어떤 볼륨의</emphasis
> 암호를 실제로 입력해야 하는 지 궁금할 것입니다. <filename
>/home</filename
>일까요? 아니면 <filename
>/var</filename
>일까요? 물론, 암호화 볼륨이 1개뿐이라면, 이 볼륨을 설정할 때 사용한 암호를 입력하면 됩니다. 설치할 때 암호화 볼륨을 여러 개 설정했다면, <xref linkend="partman-crypto"/>의 마지막 단계에서 적어 놓은 메모를 잘 가지고 있어야 합니다. <filename
><replaceable
>part</replaceable
>_crypt</filename
>에 해당되는 사항과 거기에 해당하는 마운트 위치를 적어 놓지 않았다면 새로 설치한 시스템의 <filename
>/etc/crypttab</filename
>과 <filename
>/etc/fstab</filename
>에서 찾아 볼 수도 있습니다. </para
><para
>이 프롬프트는 암호화한 루트 파일시스템을 마운트할 때는 약간 다릅니다. 시스템을 부팅할 때 사용하는 initrd를 만들 때 어떤 initramfs 만들기 프로그램을 사용했느냐에 따라 다릅니다. 아래의 예제는 <classname
>initramfs-tools</classname
>로 initrd를 만들 경우에 대한 예제입니다: <informalexample
><screen
>Begin: Mounting <emphasis
>root file system</emphasis
>... ...
Begin: Running /scripts/local-top ...
Enter LUKS passphrase:
</screen
></informalexample>

</para
><para
>암호를 입력할 때는 아무런 글자도 (별표 조차도) 나타나지 않습니다. 암호를 잘못 입력하면 두 번 더 시도할 수 있습니다. 세 번째 시도에서 틀리면 부팅 과정에서 해당 볼륨을 건너뛰고 다음 파일 시스템으로 넘어갑니다. 자세한 정보는 <xref linkend="crypto-troubleshooting"/> 부분을 보십시오. </para
><para
>암호를 모두 입력하면 부팅은 평소처럼 계속 진행합니다. </para>
  </sect2>

  <sect2 id="mount-loop-aes">
  <title
>loop-AES</title>

<para
>loop-AES를 사용해 암호화한 파티션의 경우 부팅할 때 다음 프롬프트가 나옵니다: <informalexample
><screen
>Checking loop-encrypted file systems.
Setting up /dev/loop<replaceable
>X</replaceable
> (/<replaceable
>mountpoint</replaceable
>)
Password:
</screen
></informalexample>

</para
><para
>암호를 입력할 때는 아무런 글자도 (별표 조차도) 나타나지 않습니다. 암호를 잘못 입력하면 두 번 더 시도할 수 있습니다. 세 번째 시도에서 틀리면 부팅 과정에서 해당 볼륨을 건너뛰고 다음 파일 시스템으로 넘어갑니다. 자세한 정보는 <xref linkend="crypto-troubleshooting"/> 부분을 보십시오. </para
><para
>암호를 모두 입력하면 부팅은 평소처럼 계속 진행합니다. </para>
  </sect2>

  <sect2 id="crypto-troubleshooting">
  <title
>문제 해결</title>

<para
>암호가 틀려서 암호화 볼륨을 마운트하지 못할 경우, 부팅한 다음에 수동으로 마운트해야 합니다. 여러가지 경우가 있습니다. </para>

<itemizedlist>
<listitem
><para
>첫번째 경우는 루트 파티션입니다. 올바르게 마운트하지 않으면, 부팅 과정이 멈추게 되고 컴퓨터를 다시 시작해서 암호를 다시 입력해야 합니다. </para
></listitem>
<listitem
><para
>가장 쉬운 경우는 암호화 볼륨에 <filename
>/home</filename
>이나 <filename
>/srv</filename
>처럼 데이터가 들어 있는 경우입니다. 부팅한 다음에 이 볼륨을 수동으로 마운트하기만 하면 됩니다. loop-AES의 경우 한 번에 끝나는 작업입니다: <informalexample
><screen
> <prompt
>#</prompt
> <userinput
>mount <replaceable
>/마운트_위치</replaceable
></userinput>
<prompt
>Password:</prompt>
</screen
></informalexample
> 여기서 <replaceable
>/마운트_위치</replaceable
>는 해당 디렉토리를 (예를 들어 <filename
>/home</filename
>) 씁니다. 일반적인 마운트와 다른 부분은 이 볼륨의 암호를 입력하는 것 뿐입니다. </para
><para
>dm-crypt의 경우에는 약간 까다롭습니다. 먼저 해당 볼륨을 다음 명령어로 <application
>device mapper</application
>에 등록해야 합니다: <informalexample
><screen>
<prompt
>#</prompt
> <userinput
>/etc/init.d/cryptdisks start</userinput>
</screen
></informalexample
> 이렇게 하면 <filename
>/etc/crypttab</filename
>에 들어 있는 모든 볼륨을 검색하고 암호를 올바르게 입력할 때마다 <filename
>/dev</filename
> 디렉토리 아래에 적당한 장치를 만듭니다. (이미 등록한 볼륨은 건너 뛰므로, 걱정하지 말고 이 명령어를 여러번 실행해도 됩니다.) 올바르게 등록을 마치면 해당 볼륨을 평소와 다름없이 마운트할 수 있습니다: <informalexample
><screen
><prompt
>#</prompt
> <userinput
>mount <replaceable
>/마운트_위치</replaceable
></userinput
>
</screen
></informalexample>

</para
></listitem>
<listitem
><para
>꼭 필요하지는 않은 시스템 파일이 들어 있는 볼륨중에 하나라도 (<filename
>/usr</filename
> 혹은 <filename
>/var</filename
>) 마운트할 수 없는 경우, 그래도 시스템이 부팅하고 수동으로 볼륨을 마운트할 수 있습니다. 하지만 현재 런레벨의 각종 서비스를 (다시) 시작해야 할 수도 있습니다. 서비스가 제대로 시작하지 않았을 가능성이 높기 때문입니다. 가장 쉬운 방법은 쉘에서 다음과 같은 명령어로 첫번째 런레벨로 갔다가 다시 돌아오는 방법입니다:<informalexample
><screen>
<prompt
>#</prompt
> <userinput
>init 1</userinput>
</screen
></informalexample
> 이렇게 입력하고 루트 암호를 물어보면 <keycombo
> <keycap
>Control</keycap
> <keycap
>D</keycap
> </keycombo
>를 누릅니다. </para
></listitem>
</itemizedlist>

  </sect2>
 </sect1>
<!--   End of file boot-new/mount-encrypted.xml -->

 <sect1 id="login">
 <title
>로그인</title>

<para
>패키지 설치가 끝나면 로그인 프롬프트를 표시합니다. 설치할 때 입력한 개인 로그인 및 암호를 이용해 로그인합니다. 그러면 이제 시스템을 사용할 준비를 다 마쳤습니다. </para
><para
>처음 설치한 사용자라면 문서를 살펴보고 싶을 것입니다. 이 문서는 시스템을 시작할 때부터 시스템 안에 설치되어 있습니다. 현재 여러 개의 문서 시스템이 있고, 여러가지 종류의 문서를 통합하는 작업을 진행하고 있습니다. 다음과 같은 방법으로 문서 보기를 시작할 수 있습니다. </para
><para
>설치한 프로그램에 들어 있는 문서는 <filename
>/usr/share/doc/</filename
> 아래에, 그 프로그램의 이름으로 (정확히 말해 그 프로그램이 들어 있는 데비안 패키지의 이름으로) 된 서브 디렉토리에 들어 있습니다. 하지만 이보다 자세한 문서는 별도의 문서 패키지에 들어 있고, 이 패키지는 보통 기본으로 설치하지 않습니다. 예를 들어 <command
>apt</command
> 패키지 관리 도구에 관한 문서는 <classname
>apt-doc</classname
> 혹은 <classname
>apt-howto</classname
> 패키지에 들어 있습니다. </para
><para
>또 <filename
>/usr/share/doc/</filename
> 아래에 특수 폴더가 몇 개 더 있습니다. 리눅스 HOWTO는 <filename
>/usr/share/doc/HOWTO/en-txt/</filename
> 안에 <emphasis
>.gz</emphasis
> (압축한) 형식으로 들어 있습니다. <classname
>dhelp</classname
>를 설치하면 <filename
>/usr/share/doc/HTML/index.html</filename
> 파일에 브라우저로 볼 수 있는 문서 목록이 있습니다. </para
><para
>다음 명령으로 텍스트 기반 브라우저를 사용하면 간단히 이 문서를 볼 수 있습니다 : <informalexample
><screen>
$ cd /usr/share/doc/
$ w3m .
</screen
></informalexample
> <command
>w3m</command
> 명령 다음에 나오는 점은 현재 디렉토리의 내용을 표시한다는 뜻입니다. </para
><para
>그래픽 데스크탑 환경을 설치했다면, 그 환경의 웹 브라우저를 이용할 수 있습니다. 프로그램 메뉴에서 웹 브라우저를 실행해서 주소창에 <userinput
>/usr/share/doc/</userinput
>을 입력하고 Enter를 누르십시오. </para
><para
><userinput
>info <replaceable
>명령어</replaceable
></userinput
> 또는 <userinput
>man <replaceable
>명령어</replaceable
></userinput
> 명령을 입력하면, 명령어 프롬프트에서 사용할 수 있는 대부분의 명령에 대한 문서를 볼 수 있습니다. <userinput
>help</userinput
>를 입력하면 쉘 명령어에 대한 도움말을 표시합니다. 명령어 뒤에 <userinput
>--help</userinput
> 옵션을 붙이면 짤막한 명령어 사용법을 표시합니다. 명령어의 결과가 화면 위로 지나가 버린다면 <userinput
>|&nbsp;more</userinput
>를 명령 뒤에 붙이면 화면 위로 스크롤되 지나가기 전에 출력을 일시 정지할 수 있습니다. 어떤 글자로 시작하는 명령어의 목록을 보려면 그 글자를 입력하고 탭을 두번 누릅니다. </para>

 </sect1>
</chapter>
<!--   End of file boot-new/boot-new.xml -->
