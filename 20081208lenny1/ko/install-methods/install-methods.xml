<!-- Start of file install-methods/install-methods.xml -->
<!-- $Id: install-methods.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<chapter id="install-methods">
 <title
>시스템 설치 미디어 구하기</title>


<!-- Start of file install-methods/official-cdrom.xml -->
<!-- $Id: official-cdrom.xml 28672 2005-06-26 10:06:30Z fjp $ -->

 <sect1 id="official-cdrom">
 <title
>공식 &debian; CD-ROM 세트</title>
<para
>여러 가지 방법 중에서 &debian; 설치에 가장 쉬운 방법은 공식 데비안 CD-ROM 세트로 설치하는 것입니다. CD 세트는 판매하는 회사에서 (<ulink url="&url-debian-cd-vendors;"
>CD 판매 회사 페이지</ulink
> 참고) 구입할 수 있습니다. 네트워크 연결이 빠르고, CD 라이터가 있으면, 데비안 미러 사이트에서 CD-ROM 이미지를 다운로드해서 직접 CD 세트를 만들 수도 있습니다. (CD 만드는 방법은 <ulink url="&url-debian-cd;"
>데비안 CD 페이지</ulink
> 참고) 데비안 CD 세트가 있고 CD에서 부팅할 수 있으면, 바로 <xref linkend="boot-installer"/> 부분으로 넘어갈 수 있습니다. 이 부팅 CD에는 가능한 범위 내에서 대부분의 사람에게 필요한 파일이 들어 있습니다. 바이너리 패키지 모음은 전부 여러 장의 CD가 필요하지만, 아마도 3번째 이후의 CD에서 패키지가 필요한 일은 없을 겁니다. DVD 버전을 쓸 수도 있습니다. DVD 버전은 보관할 공간도 줄어들고, CD를 이것 저것 교환해야 하는 일도 없습니다. </para
><para
>CD 세트를 갖고 있지만 CD 부팅을 지원하지 않는 경우, <phrase condition="supports-floppy-boot"
>플로피 디스크,</phrase
> <phrase arch="s390"
>테이프, 테이프 에뮬레이션,</phrase
> <phrase condition="bootable-disk"
>하드 디스크,</phrase
> <phrase condition="bootable-usb"
>USB 메모리,</phrase
> <phrase condition="supports-tftp"
>네트워크 부팅,</phrase
> 아니면 수동으로 CD에서 커널을 읽어들여서 시스템 설치 프로그램을 맨 처음 부팅할 수 있습니다. 부팅할 때 필요한 파일은 CD 안에도 들어 있습니다. 데비안 네트워크 아카이브와 CD의 폴더 구조는 완전히 동일합니다. 그래서 부팅하는 데 필요한 파일의 경로를 아래에서 언급하면, CD의 같은 서브 디렉토리 안에서 그 파일을 찾아 보십시오. </para
><para
>설치 프로그램을 부팅하기만 하면, 필요한 다른 파일은 모두 CD에서 이용할 수 있습니다. </para
><para
>CD 세트가 없으면, 설치 프로그램의 시스템 파일을 다운로드해서 <phrase arch="s390"
>설치 테이프</phrase
> <phrase condition="supports-floppy-boot"
>플로피 디스크나</phrase
> <phrase condition="bootable-disk"
>하드 디스크나</phrase
> <phrase condition="bootable-usb"
>USB 메모리나</phrase
> <phrase condition="supports-tftp"
>네트워크로 연결된 컴퓨터에</phrase
> 저장해 놓으십시오. 그러면 이 파일을 이용해 설치 프로그램을 부팅할 수 있습니다. </para>

 </sect1>
<!--   End of file install-methods/official-cdrom.xml -->

<!-- Start of file install-methods/downloading-files.xml -->
<!-- $Id: downloading-files.xml 56139 2008-09-26 10:44:32Z lunar $ -->

 <sect1 id="downloading-files">
 <title
>데비안 미러에서 파일 다운로드</title>

<para
>가장 가까이 있는 (그래서 가장 빠를 것 같은) 미러 사이트를 찾으려면, <ulink url="&url-debian-mirrors;"
>데비안 미러 목록</ulink
>을 참고하십시오. </para
><para
>데비안 미러에서 FTP를 통해 파일을 다운로드할 때, 파일을 <emphasis
>바이너리(binary)</emphasis
> 모드로 받도록 하십시오. 텍스트(text)나 자동(automatic) 모드로 받으면 안 됩니다. </para>

  <sect2 id="where-files">
  <title
>설치 이미지를 찾을 위치</title>

<para
>설치 이미지는 데비안 미러의 <ulink url="&url-debian-installer;images"
>debian/dists/&releasename;/main/installer-&architecture;/current/images/</ulink
> 디렉토리 안에 있습니다. <ulink url="&url-debian-installer;images/MANIFEST"
>MANIFEST</ulink
> 파일을 보면 각 이미지 이름과 그 용도가 쓰여 있습니다. </para>


<!-- Start of file install-methods/download/alpha.xml -->
<!-- $Id: alpha.xml 28997 2005-07-07 21:09:22Z fjp $ -->


   <sect3 arch="alpha"
><title
>Alpha 설치 파일</title>
<para
>ARC 콘솔 펌웨어에서 <command
>MILO</command
>를 이용해 부팅하려면, 디스크 이미지에 있는 <command
>MILO</command
>와 <command
>LINLOAD.EXE</command
> 파일이 들어 있는 디스크도 준비해야 합니다. Alpha 펌웨어와 부트로더에 관한 더 많은 정보는 <xref linkend="alpha-firmware"/> 부분을 참고하십시오. 플로피 이미지는 <filename
>MILO</filename
> 디렉토리에 <filename
>milo_<replaceable
>서브아키텍처</replaceable
>.bin</filename
>이라는 파일로 들어 있습니다. </para
><para
>불행히도 이 <command
>MILO</command
> 이미지는 테스트를 할 수 없었고 동작하지 않는 서브 아키텍처가 있을 수도 있습니다. 이미지가 동작하지 않으면 해당 <command
>MILO</command
> 바이너리를 플로피에 복사해 보십시오. (<ulink url="&disturlftp;main/disks-alpha/current/MILO/"
></ulink
>) 단 이 <command
>MILO</command
>는 EXT2의 <quote
>sparse superblocks</quote
>를 지원하지 않기 때문에, 새로 만든 EXT2 파일 시스템에서는 커널을 읽어들일 수 없습니다. 이 문제를 피해가려면, 커널을 <command
>MILO</command
> 바로 다음에 있는 FAT 파티션에 넣으면 됩니다. </para
><para
><command
>MILO</command
> 바이너리는 플랫폼마다 다릅니다. 여러분의 Alpha 플랫폼에 맞는 <command
>MILO</command
> 이미지를 찾으려면 <xref linkend="alpha-cpus"/> 부분을 참고하십시오. </para>
   </sect3>
<!--   End of file install-methods/download/alpha.xml -->

<!-- Start of file install-methods/download/arm.xml -->
<!-- $Id: arm.xml 55541 2008-09-03 15:16:19Z tbm $ -->


   <sect3 arch="arm" id="netwinder-install-files">
   <title
>NetWinder 설치 파일</title>
<para
>NetWinder를 부팅하는 가장 쉬운 방법은, 들어 있는 &netwinder-boot-img; TFTP 이미지를 이용해 네트워크에서 부팅하는 것입니다. </para>
   </sect3>

   <sect3 arch="arm" id="cats-install-files">
   <title
>CATS 설치 파일</title>
<para
>CATS는 네트워크나 CD-ROM을 이용해서 부팅할 수 있습니다. 커널과 initrd 이미지는 &cats-boot-img;에서 구할 수 있습니다. </para>
   </sect3>

   <sect3 arch="arm" id="nslu2-install-files">
   <title
>NSLU2 설치 파일</title>
<para
>Linksys2 NSLU2에 있는 펌웨어 이미지는 자동으로 <classname
>debian-installer</classname
>를 부팅합니다. Linksys의 웹 인터페이스나 upslug2 프로그램을 이용해 이 펌웨어 이미지를 업로드할 수 있습니다. 이 펌웨어 이미지는 &nslu2-firmware-img;에서 구할 수 있습니다. </para>
   </sect3>


   <sect3 arch="arm" id="n2100-install-files">
   <title
>Thecus N2100 설치 파일</title>
<para
>Thecus N2100에 있는 펌웨어 이미지는 자동으로 <classname
>debian-installer</classname
>를 부팅합니다. 이 펌웨어 이미지는 Thecus 펌웨어 업그레이드 기능을 이용해 설치할 수 있습니다. 이 펌웨어 이미지는 &n2100-firmware-img;에서 구할 수 있습니다. </para>
   </sect3>

   <sect3 arch="arm" id="glantank-install-files">
   <title
>GLAN Tank 설치 파일</title>
<para
>GLAN Tank는 데비안을 설치하려는 디스크의 ext2 파티션에 커널과 램디스크가 있어야 합니다. 이 이미지는 &glantank-firmware-img;에서 구할 수 있습니다. </para>
   </sect3>

   <sect3 arch="arm" id="kuroboxpro-install-files">
   <title
>Kurobox Pro 설치 파일</title>
<para
>Kurobox Pro는 데비안을 설치하려는 디스크의 ext2 파티션에 커널과 램디스크가 있어야 합니다. 이 이미지는 &kuroboxpro-firmware-img;에서 구할 수 있습니다. </para>
   </sect3>

   <sect3 arch="arm" id="mv2120-install-files">
   <title
>HP mv2120 설치 파일</title>
<para
><classname
>debian-installer</classname
>를 부팅할 수 있는 HP mv2120의 펌웨어 이미지가 있습니다. 이 펌웨어 이미지는 리눅스 및 기타 시스템에서 uphpmvault로 설치할 수 있고, 또 윈도우즈의 HP Media Vault Firmware Recovery Utility에서 설치할 수 있습니다. 이 펌웨어 이미지는 &mv2120-firmware-img;에서 구할 수 있습니다. </para>
   </sect3>

   <sect3 arch="arm" id="qnap-install-files">
   <title
>QNAP Turbo Station 설치 파일</title>
<para
>QNAP Turbo Station은 (TS-109, TS-209 and TS-409) 커널과 램디스크를 &qnap-firmware-img;에서 구해야 합니다. 이 이미지를 플래시에 쓰는 스크립트가 있습니다. </para>
   </sect3>

<!--   End of file install-methods/download/arm.xml -->

<!-- Start of file install-methods/download/powerpc.xml -->
<!-- $Id: powerpc.xml 28672 2005-06-26 10:06:30Z fjp $ -->

<!-- commented out as it seems out of date and the links are broken

   <sect3 arch="powerpc" id="newworld-install-files">
   <title
>NewWorld MacOS Installation Files </title>
<para>

For floppy-less installation on NewWorld Macs, it may be most
convenient to obtain all the necessary files packaged into one Stuffit
archive from
<ulink url="&url-powerpc-of;"
></ulink
> (separate instructions are
included in the archive). Otherwise, obtain the normal installation
files listed above. Retrieve the files to an HFS (not HFS+) partition
on your system.  You will also need the <filename
>yaboot</filename
> and
<filename
>yaboot.conf</filename
> files from the
<ulink url="&downloadable-file;new-powermac/"
>new-powermac</ulink
> or
<ulink url="&downloadable-file;powermac/"
>powermac</ulink
> archive folder.
However, the newest G4 PowerMacs, and those that work without MacOS 9,
need the newest version of <command
>yaboot</command
>; the one in the
archive will not work. Obtain the newest version from
<ulink url="http://penguinppc.org/projects/yaboot/"
></ulink
>.

</para>
   </sect3>

-->
<!--   End of file install-methods/download/powerpc.xml -->

<!-- Start of file install-methods/download/m68k.xml -->
<!-- $Id: m68k.xml 28672 2005-06-26 10:06:30Z fjp $ -->


   <sect3 arch="m68k" id="kernel-22">
   <title
>커널 고르기</title>

<para
>일부 m68k 서브 아키텍처에서는 설치할 커널을 선택할 수 있습니다. 일반적인 경우라면 가장 최근의 버전을 처음에 시도해 보시길 권합니다. 해당 서브 아키텍처나 컴퓨터에서 2.2.x 커널이 필요한 경우에는, 2.2.x 커널을 지원하는 이미지를 사용하도록 하십시오. (<ulink url="&disturl;/main/installer-&architecture;/current/images/MANIFEST"
>MANIFEST</ulink
>를 참고하십시오.) </para>
<para
>모든 2.2.x 커널 m68k 이미지는 &ramdisksize; 커널 파라미터가 필요합니다. </para>
   </sect3>
<!--   End of file install-methods/download/m68k.xml -->

  </sect2>

 </sect1>
<!--   End of file install-methods/downloading-files.xml -->

<!-- Start of file install-methods/ipl-tape.xml -->
<!-- $Id: ipl-tape.xml 36841 2006-04-30 23:34:32Z fjp $ -->

 <sect1 arch="s390" id="ipl-tape">
 <title
>IPL 테이프 만들기</title>

<para
>CD-ROM에서 부팅할 수 없고 VM을 사용하는 게 아니라면 먼저 IPL 테이프를 만들어야 합니다. <ulink url="http://www.redbooks.ibm.com/pubs/pdfs/redbooks/sg246264.pdf"
> Linux for IBM eServer zSeries and S/390: Distributions</ulink
> Redbook의 3.4.3에 설명되어 있습니다. 테이프에 쓸 때 필요한 파일은 (순서대로): <filename
>kernel.debian</filename
>, <filename
>parmfile.debian</filename
>과 <filename
>initrd.debian</filename
>입니다. 이 파일은 <filename
>tape</filename
> 서브 디렉토리에서 다운로드할 수 있습니다. <xref linkend="where-files"/> 부분을 참고하십시오. </para>
 </sect1>

<!--   End of file install-methods/ipl-tape.xml -->

<!-- Start of file install-methods/create-floppy.xml -->
<!-- $Id: create-floppy.xml 45453 2007-02-27 12:58:15Z fjp $ -->

 <sect1 condition="supports-floppy-boot" id="create-floppy">
 <title
>디스크 이미지에서 플로피 만들기</title>
<para
>CD나 다른 방법으로 부팅할 수 없는 하드웨어의 경우, 보통 마지막 방법으로 부팅 플로피 디스크를 사용해 설치 프로그램을 부팅합니다. </para
><para arch="powerpc"
>알려진 바에 따르면, 맥 USB 플로피 드라이브에서는 플로피 디스크에서 설치 프로그램 부팅하기가 실패합니다. </para
><para arch="m68k"
>Amiga 혹은 68k 맥에서는 플로피 디스크에서 설치 프로그램 부팅하기를 지원하지 않습니다. </para
><para
>디스크 이미지는 플로피 디스크의 모든 내용이 <emphasis
>로우</emphasis
> 형태로 들어 있는 파일입니다. <filename
>boot.img</filename
>같은 디스크 이미지는 플로피 드라이브에 그냥 복사할 수 없습니다. 이미지 파일을 플로피 디스크에 <emphasis
>로우</emphasis
> 모드로 쓰려면 특별한 프로그램을 사용합니다. 이미지 파일은 디스크 전체의 내용을 그대로 나타내는 파일이기 때문입니다. 파일의 데이터를 플로피에 <emphasis
>섹터 복사</emphasis
>해야 합니다. </para
><para
>디스크 이미지에서 플로피를 만드는 방법은 다른 여러 기술이 있습니다. 여기서는 여러 가지 플랫폼에서 디스크 이미지로 플로피를 만드는 방법을 설명합니다. </para
><para
>플로피를 만들기 전에, 먼저 데비안 미러에서 <xref linkend="downloading-files"/>에 설명한 방법대로 파일을 다운로드합니다. <phrase arch="i386"
>설치 CD-ROM이나 DVD가 이미 있으면, 플로피 이미지 파일은 CD/DVD에 들어 있습니다.</phrase
> </para
><para
>플로피를 만들 때 어떤 방법을 사용하든 간에, 플로피를 쓴 다음에 쓰기 방지 탭을 걸어 놓아서 플로피 내용이 손상되지 않도록 하십시오. </para>

  <sect2
><title
>리눅스나 유닉스 시스템에서 디스크 이미지 쓰기</title>
<para
>플로피 디스크 이미지 파일을 플로피 디스크에 쓰려면, 보통은 시스템의 루트 권한이 있어야 합니다. 비어 있는 플로피를 플로피 드라이브에 넣으십시오. 그리고 다음 명령을 사용하십시오: <informalexample
><screen>
$ dd if=<replaceable
>파일_이름</replaceable
> of=/dev/fd0 bs=1024 conv=sync ; sync
</screen
></informalexample
> 여기서 <replaceable
>파일_이름</replaceable
>은 플로피 디스크 이미지 파일의 이름입니다. 플로피 디스크 장치 이름으로는 <filename
>/dev/fd0</filename
>을 가장 많이 씁니다. 워크스테이션에서는 다를 수도 있습니다. <phrase arch="sparc"
>(Solaris에서는 <filename
>/dev/fd/0</filename
>입니다.)</phrase
> 플로피 디스크에 데이터를 다 쓰기도 전에 명령어가 끝나서 프롬프트가 나올 수도 있기 때문에, 플로피 디스크가 사용중이라는 불이 깜박이는 지 잘 살펴 보시고 깜박이지 않을 때 플로피를 드라이브에서 빼야 합니다. 어떤 시스템에서는 플로피를 빼려면 플로피를 꺼내는 별도의 명령을 실행해야 합니다. <phrase arch="sparc"
>(Solaris에서는 <command
>eject</command
> 명령을 사용하십시오. 맨페이지를 참고하십시오.)</phrase
> </para
><para
>어떤 시스템에서는 드라이브에 플로피 디스크를 넣으면 자동으로 마운트합니다. <emphasis
>로우 모드</emphasis
>로 플로피를 쓰려면 그 전에 이 기능을 꺼야 합니다. 불행히도, 이 기능을 끄는 방법은 운영 체제마다 다 다릅니다. <phrase arch="sparc"
>Solaris에서 플로피 디스크에 로우 모드로 접근하려면 볼륨 관리 기능을 피해가면 됩니다. 먼저 플로피가 자동 마운트되도록 하십시오. (<command
>volcheck</command
>나 파일 관리자의 해당 명령 사용) 그리고 <command
>dd</command
> 명령을 위에서 쓴 방법대로 쓰시고, 거기에서 <filename
>/dev/fd0</filename
>을 <filename
>/vol/rdsk/<replaceable
>플로피이름</replaceable
></filename
>이라고 바꾸십시오. (<replaceable
>플로피이름</replaceable
>은 포맷할 때 만든 플로피 이름입니다. 이름 없는 플로피는 기본값이 <filename
>unnamed_floppy</filename
>) 그 외의 시스템에서는 시스템 관리자에게 문의하십시오. </phrase
> </para
><para arch="powerpc"
>powerpc 리눅스에서 플로피를 쓰는 경우, 플로피를 꺼내는 명령을 사용해야 합니다. <command
>eject</command
> 프로그램을 사용합니다. 이 프로그램을 따로 설치해야 할 수도 있습니다. </para>

  </sect2>


<!-- Start of file install-methods/floppy/i386.xml -->
<!-- $Id: i386.xml 39870 2006-08-16 00:35:08Z fjp $ -->


<!--  This is not set off for i386 only, because many people will have -->
<!--  access to a PC in order to make a floppy for other arches. -->

  <sect2
><title
>DOS, 윈도우즈, OS/2에서 디스크 이미지 쓰기</title>

<para
>i386 혹은 amd64 컴퓨터의 경우는, 다음 명령 중의 하나를 이용해 이미지를 플로피로 복사하십시오. </para
><para
>MS-DOS에서는 <command
>rawrite1</command
> 및 <command
>rawrite2</command
> 프로그램을 사용할 수 있습니다. 윈도우즈에서는 DOS 창에서 사용하십시오. 윈도우즈 탐색기에서 이 프로그램을 두번 눌러도 동작하지 <emphasis
>않습니다</emphasis
>. </para
><para
><command
>rwwrtwin</command
> 프로그램은 윈도우즈 95, NT, 98, 2000, ME, XP에서 (그리고 아마도 그 이후 버전에서도) 동작합니다. 사용하려면 같은 디렉토리에서 diskio.dll 파일을 풀어야 합니다. </para
><para
>이 도구는 공식 데비안 CD-ROM의 <filename
>/tools</filename
> 디렉토리 아래에 있습니다. </para>
  </sect2>
<!--   End of file install-methods/floppy/i386.xml -->

<!-- Start of file install-methods/floppy/m68k.xml -->
<!-- $Id: m68k.xml 45433 2007-02-26 18:10:28Z wouter $ -->


  <sect2 arch="m68k"
><title
>Atari 시스템에서 디스크 이미지 쓰기</title>
<para
>&rawwrite.ttp; 프로그램이 플로피 디스크 이미지와 같은 디렉토리에 들어 있습니다. 프로그램 아이콘에 두번 눌러 실행하고, TOS 프로그램의 명령행 대화 상자에서 플로피에 사용하려는 플로피 이미지 파일의 이름을 입력하십시오. </para>

  </sect2>

  <sect2 arch="m68k"
><title
>매킨토시 시스템에서 디스크 이미지 쓰기</title>
<para
>현재 릴리스에서는 플로피에서 부팅해서 설치할 수 있도록 지원하지 않기 때문에, 매킨토시 시스템에서는 디스크 이미지를 쓸 필요가 없습니다. 하지만 이 파일은 나중 단계에서 운영체제와 모듈을 설치할 때 필요합니다. </para>

  </sect2>
<!--   End of file install-methods/floppy/m68k.xml -->

<!-- Start of file install-methods/floppy/powerpc.xml -->
<!-- $Id: powerpc.xml 28997 2005-07-07 21:09:22Z fjp $ -->


  <sect2 arch="powerpc"
><title
>맥오에스에서 디스크 이미지 쓰기</title>
<para
>디스크 이미지 파일에서 플로피를 만드는 용도로 <application
>Make Debian Floppy</application
>라는 AppleScript가 있습니다. <ulink url="ftp://ftp2.sourceforge.net/pub/sourceforge/d/de/debian-imac/MakeDebianFloppy.sit"
></ulink
>에서 다운로드할 수 있습니다. 이 스크립트를 사용하려면, 데스크탑에 놓은 다음 플로피 이미지를 끌어다 놓으십시오. 확장 관리자에서 Applescript를 설치하고 사용해야 합니다. Disk Copy에서 현재 플로피를 지우고 해당 파일 이미지를 쓸 지 여부를 확인합니다. </para
><para
>맥오에스의 <command
>Disk Copy</command
> 유틸리티를 직접 사용할 수도 있고, 프리웨어인 <command
>suntar</command
> 유틸리티를 사용할 수도 있습니다. 플로피 이미지로 예를 들면 <filename
>root.bin</filename
>이 있습니다. 이 유틸리티로 플로피 이미지를 만드려면 다음 방법 중의 하나를 사용하십시오. </para>

   <sect3>
   <title
><command
>Disk Copy</command
>로 디스크 이미지 쓰기</title>
<para
>공식 &debian; CD에 있는 파일에서 플로피 이미지를 만들면, Type과 Creator가 이미 지정되어 있습니다. 다음의 <command
>Creator-Changer</command
> 단계는 데비안 미러에서 이미지 파일을 다운로드할 경우에만 상관 있습니다. </para>
<orderedlist>
<listitem
><para
><ulink url="&url-powerpc-creator-changer;"
>Creator-Changer</ulink
>를 받아서 그걸 이용해 <filename
>root.bin</filename
> 파일을 여십시오. </para
></listitem>
<listitem
><para
>Creator를 <userinput
>ddsk</userinput
>로 (Disk Copy) 바꾸고, Type을 <userinput
>DDim</userinput
>으로 (binary floppy image) 바꿉니다. 대소문자를 구별합니다. </para
></listitem>
<listitem
><para
><emphasis
>중요:</emphasis
> Finder에서, <userinput
>Get Info</userinput
>를 사용해 플로피 이미지에 대한 Finder 정보를 표시하십시오. 그리고 <userinput
>File Locked</userinput
>에 <quote
>X</quote
> 표시하십시오. 그래야 맥오에스에서 이미지를 마운트하더라도 부트 블록을 망가뜨리지 않습니다. </para
></listitem>
    <listitem
><para
><command
>Disk Copy</command
>를 구하십시오. 맥오에스 시스템이나 CD가 있으면 거기에 이미 <command
>Disk Copy</command
>가 들어 있을 겁니다. 없으면 <ulink url="&url-powerpc-diskcopy;"
></ulink
>에서 받으십시오. </para
></listitem>
<listitem
><para
><command
>Disk Copy</command
>를 실행하고, 메뉴에서 <menuchoice
> <guimenu
>Utilities</guimenu
> <guimenuitem
>Make a Floppy</guimenuitem
> </menuchoice
>를 선택하십시오. 그리고 나타나는 대화 상자에서 <emphasis
>잠긴 (locked)</emphasis
> 이미지 파일을 선택하십시오. 플로피를 넣으라고 물어보고, 정말로 플로피를 지울 지 물어봅니다. 다 마치면 플로피가 튀어 나옵니다. </para
></listitem>
</orderedlist>

   </sect3>

   <sect3>
   <title
><command
>suntar</command
>로 디스크 이미지 쓰기</title>
<para>

<orderedlist>
<listitem
><para
><ulink url="&url-powerpc-suntar;"
></ulink
>에서 <command
>suntar</command
>를 다운로드하십시오. <command
>suntar</command
> 프로그램을 실행하고 <userinput
>Special</userinput
> 메뉴에서 <quote
>Overwrite Select...</quote
>를 선택하십시오. </para
></listitem>
<listitem
><para
>플로피를 넣고, &enterkey;를 누르십시오. (섹터 0에서 시작) </para
></listitem>
<listitem
><para
>파일 열기 창에서 <filename
>root.bin</filename
> 파일을 선택하십시오. </para
></listitem>
<listitem
><para
>플로피를 성공적으로 만들었으면, <menuchoice
><guimenu
>File</guimenu
> <guimenuitem
>Eject</guimenuitem
></menuchoice
>를 선택하십시오. 플로피를 쓸 때 오류가 발생하면 그 플로피를 꺼내고 다른 플로피로 시도해 보십시오. </para
></listitem>
</orderedlist>
새로 만든 플로피를 사용하기 전에, <emphasis
>쓰기 방지 탭을 거십시오</emphasis
>! 그렇게 하지 않고 실수로 맥오에스에서 마운트하게 되면, 맥오에스가 데이터를 망가뜨립니다. </para>
   </sect3>
  </sect2>
<!--   End of file install-methods/floppy/powerpc.xml -->

 </sect1>

<!--   End of file install-methods/create-floppy.xml -->

<!-- Start of file install-methods/boot-usb-files.xml -->
<!-- $Id: boot-usb-files.xml 57590 2009-02-16 22:01:04Z fjp $ -->

 <sect1 condition="bootable-usb" id="boot-usb-files">
 <title
>USB 메모리 부팅에 필요한 파일 준비하기</title>

<para
>USB 메모리에서 부팅할 경우 사용할 수 있는 설치 방식은 두 가지가 있습니다. 첫 번째 방법은 네트워크에서 전부 설치하는 방법입니다. 두 번째 방법은 USB 메모리에 CD 이미지도 복사해서 그 CD 이미지에서 (필요하다면 미러 사이트와 같이) 패키지를 설치하는 방법입니다. 두 번째 방법을 더 많이 사용합니다. </para
><para
>첫 번째 설치 방법의 경우 설치 프로그램 이미지를 <filename
>netboot</filename
> 디렉토리에서 (<xref linkend="where-files"/>에서 설명한 위치에 있습니다) 복사한 다음 아래에서 설명한 <quote
>유연한 방법</quote
>을 사용해 USB 메모리에 파일을 복사하십시오. </para
><para
>두 번째 설치 방법에서 사용하는 설치 이미지는 <filename
>hd-media</filename
> 디렉토리에 들어 있고 <quote
>쉬운 방법</quote
>이나 <quote
>유연한 방법</quote
> 중 하나를 사용해 이미지를 USB 메모리에 복사합니다. 이 설치 방법에서는 CD 이미지도 다운로드해야 합니다. 설치 이미지와 CD 이미지는 같은 &d-i; 버전의 이미지여야 합니다. 버전이 맞지 않으면 설치할 때 오류가 발생할 것입니다<footnote
> <para
> 이 경우 오류 메세지는 커널 모듈이 없다는 오류 메세지가 표시될 것입니다. CD 이미지에 들어 있는 udeb 파일의 커널 모듈 버전이 커널의 버전과 다른 경우입니다. </para
> </footnote
>. </para
><para
>USB 메모리를 준비하려면 GNU/리눅스가 동작하고 USB를 지원하는 시스템이 필요합니다. 최신의 GNU/리눅스 시스템에서는 USB 메모리를 연결하면 자동으로 인식합니다. 자동으로 인식이 안 된다면 usb-storage 커널 모듈을 읽어들였는지 확인하십시오. USB 메모리를 연결하면 그 장치는 <filename
>/dev/sdX</filename
>에 연결됩니다. 여기서 <quote
>X</quote
>는 a-z 범위의 알파벳입니다. USB 메모리를 연결하고 <command
>dmesg</command
> 명령을 실행하면 그 USB 메모리가 어떤 장치에 연결되었는 지 알아볼 수 있습니다. USB 메모리에 쓰려면, 쓰기 방지 스위치를 풀어 놓아야 할 수도 있습니다. </para>
<warning
><para
>여기서 설명한 대로 하면 해당 장치에 들어 있는 내용이 모두 지워집니다! USB 메모리의 장치 이름을 올바르게 사용하도록 주의하십시오. 예를 들어 장치 이름을 잘못 사용해 하드 디스크에 들어 있는 내용이 모두 지워질 수도 잇습니다. </para
></warning>
<para
>단 USB 메모리는 크기가 최소 256MB는 되어야 합니다. (<xref linkend="usb-copy-flexible"/>에 쓰여 있는 대로 하면 더 작아도 가능합니다.) </para>

  <sect2 id="usb-copy-easy">
  <title
>파일 복사하기 &mdash; 쉬운 방법</title>
<para
><filename
>hd-media/boot.img.gz</filename
> 파일에는 <phrase arch="x86"
><classname
>syslinux</classname
>와 그 설정 파일은 물론,</phrase
> <phrase arch="powerpc"
><classname
>yaboot</classname
>와 그 설정 파일은 물론,</phrase
> 모든 설치 프로그램 파일이 (커널 포함) 다 들어 있습니다. </para
><para
>이 방식은 편리하기는 하지만 한 가지 큰 단점이 있습니다. USB 메모리 용량이 아무리 크더라도 장치의 논리 크기가 256MB까지 밖에 안 됩니다. USB 메모리의 파티션을 나눠서 새 파일 시스템을 만들어야 다른 용도로 사용할 수 있습니다. 또 한 가지 단점은 전체 CD 이미지를 복사해 넣을 수 없다는 점입니다. 작은 용량의 비지니스 카드나 네트워크 설치 CD 이미지만 가능합니다. </para
><para arch="x86"
>이 이미지를 사용하려면 USB 메모리에 압축을 풀어 놓기만 하면 됩니다: <informalexample
><screen
># zcat boot.img.gz &gt; /dev/<replaceable
>sdX</replaceable
>
</screen
></informalexample>

</para
><para arch="powerpc"
><command
>mac-fdisk</command
>의 <userinput
>C</userinput
> 명령으로 "Apple_Bootstrap" 타입의 파티션을 USB 메모리에 만들고 이미지를 다음 명령으로 풀어 놓으십시오: <informalexample
><screen
># zcat boot.img.gz &gt; /dev/<replaceable
>sdX2</replaceable
>
</screen
></informalexample>

</para
><para
>그 다음 USB 메모리를 마운트하십시오. <phrase arch="x86"
>(<userinput
>mount /dev/<replaceable
>sdX</replaceable
> /mnt</userinput
>)</phrase
> <phrase arch="powerpc"
>(<userinput
>mount /dev/<replaceable
>sdX2</replaceable
> /mnt</userinput
>)</phrase
> 이 USB 메모리에는 <phrase arch="x86"
>FAT 파일 시스템</phrase
><phrase arch="powerpc"
>HFS 파일 시스템 </phrase
>이 들어 있고, 그 안에 데비안 네트워크 설치 ISO 이미지 혹은 비지니스 카드 ISO 이미지를 그 안에 복사합니다. 마운트를 해제하면 (<userinput
>umount /mnt</userinput
>) 다 끝납니다. </para>
  </sect2>

  <sect2 id="usb-copy-flexible">
  <title
>파일 복사하기 &mdash; 유연한 방법</title>
<para
>좀 더 유연한 방법이 좋다면, 아니면 무슨 일이 일어나고 있는지 보고 싶기라도 하다면, 다음 방법으로 파일을 USB 메모리에 넣으십시오. 이 방식의 한 가지 장점은, (USB 메모리 용량이 충분히 크다면) 전체 CD의 ISO 이미지를 복사할 수도 있다는 점입니다. </para>


<!-- Start of file install-methods/usb-setup/x86.xml -->
<!-- $Id: x86.xml 56442 2008-10-15 18:10:38Z fjp $ -->

   <sect3 arch="x86">
   <title
>USB 메모리 파티션 나누기</title>
<para
>다음은 USB 메모리에서 전체 장치를 사용하지 않고, 첫번째 파티션을 사용하는 방법입니다. </para
><note
><para
>대부분의 USB 장치는 한 개의 FAT16 파티션으로 미리 포맷되어 있기 때문에, 다시 파티션 하거나 다시 포맷할 필요가 없습니다. 해야 한다면 <command
>cfdisk</command
>나 다른 파티션 도구를 이용해 FAT16 파티션을 만들고 다음 명령으로 파일 시스템을 만드십시오: <informalexample
><screen>
# mkdosfs /dev/<replaceable
>sdX1</replaceable>
</screen
></informalexample
> USB 메모리의 장치명을 올바르게 사용해야 합니다. <command
>mkdosfs</command
> 명령은 <classname
>dosfstools</classname
> 데비안 패키지에 들어 있습니다. </para
></note
><para
>USB 메모리에서 부팅한 다음 커널을 시작하려면 부트로더를 USB 메모리에 넣어야 합니다. 그 어떤 부트로더라도 (예를 들어 <classname
>lilo</classname
>) 동작하지만, <classname
>syslinux</classname
>를 사용하는 게 편리합니다. <classname
>syslinux</classname
>는 FAT16 파티션을 사용하고 텍스트 파일을 편집하는 것만으로 설정을 바꿀 수 있기 때문입니다. FAT 파일 시스템을 지원하는 어떤 운영 체제라도 부트로더를 설정할 때 이용할 수 있습니다. </para
><para
><classname
>syslinux</classname
>를 USB 메모리의 FAT16 파티션에 넣으려면, <classname
>syslinux</classname
>와 <classname
>mtools</classname
> 패키지를 설치하고, 다음 명령을 실행합니다: <informalexample
><screen>
# syslinux /dev/<replaceable
>sdX1</replaceable>
</screen
></informalexample
> 다시 말하지만, 신경 써서 장치 이름을 올바르게 쓰십시오. <command
>syslinux</command
>를 실행할 때 그 파티션을 마운트하면 안 됩니다. 이 명령은 파티션에 부트 섹터를 쓰고, 부트로더 코드가 들어 있는 <filename
>ldlinux.sys</filename
> 파일을 만듭니다. </para>
   </sect3>

   <sect3 arch="x86">
   <title
>설치 프로그램 이미지 추가하기</title>
<para
>파티션을 마운트하고 (<userinput
>mount /dev/<replaceable
>sdX1</replaceable
> /mnt</userinput
>) 데비안 아카이브에서 다음 파일을 USB 메모리로 복사하십시오: <itemizedlist
> <listitem
><para
> <filename
>vmlinuz</filename
> (커널 바이너리) </para
></listitem
> <listitem
><para
> <filename
>initrd.gz</filename
> (최초 램디스크 이미지) </para
></listitem
> <listitem
><para
> <filename
>syslinux.cfg</filename
> (SYSLINUX 설정 파일 </para
></listitem
> <listitem
><para
> 추가 커널 모듈 </para
></listitem
> </itemizedlist
> 파일 이름을 바꾸려면, <classname
>syslinux</classname
>에서는 DOS 파일 이름만 (8.3 방식) 사용할 수 있다는 점을 주의하십시오. </para
><para
>그 다음에 <filename
>syslinux.cfg</filename
> 설정 파일을 만들어야 합니다. 설정 파일에는 최소한 다음 두 줄이 들어가야 합니다: <informalexample
><screen>
default vmlinuz
append initrd=initrd.gz
</screen
></informalexample
> 그래픽 설치 프로그램의 경우 두 번째 줄에 <userinput
>video=vesa:ywrap,mtrr vga=788</userinput
> 옵션을 덧붙입니다. </para
><para
><filename
>hd-media</filename
> 이미지를 사용하는 경우, 데비안 ISO 이미지를 USB 메모리에 복사해야 합니다. (비지니스 카드, 네트워크 설치, 전체 CD 이미지 중에서 용량에 맞는 이미지를 하나 고르십시오.) 복사했으면 USB 메모리 마운트를 해제합니다. (<userinput
>umount /mnt</userinput
>) </para>
   </sect3>
<!--   End of file install-methods/usb-setup/x86.xml -->

<!-- Start of file install-methods/usb-setup/powerpc.xml -->
<!-- $Id: powerpc.xml 56442 2008-10-15 18:10:38Z fjp $ -->

   <sect3 arch="powerpc">
   <title
>USB 메모리 파티션 나누기</title>
<para
>USB 메모리 대부분은 처음에는 Open Firmware가 부팅할 수 없는 방식으로 되어 있습니다. 그래서 USB 메모리를 다시 파티션해야 합니다. 맥 시스템에서는 <userinput
>mac-fdisk /dev/<replaceable
>sdX</replaceable
></userinput
>라고 실행하고, <userinput
>i</userinput
> 명령으로 새 파티션 맵을 초기화한 다음, <userinput
>C</userinput
> 명령으로 새로운 Apple_Bootstrap 파티션을 만듭니다. (맨 앞의 "partition"은 항상 파티션 맵 자신입니다) 그리고 다음 명령을 실행하십시오: <informalexample
><screen>
$ hformat /dev/<replaceable
>sdX2</replaceable>
</screen
></informalexample
> 주의해서 USB 메모리에 올바른 장치 이름을 사용하십시오. <command
>hformat</command
> 명령은 <classname
>hfsutils</classname
> 데비안 패키지에 들어 있습니다. </para
><para
>USB 메모리에서 부팅한 다음 커널을 시작하려면, 부트로더를 USB 메모리에 넣어야 합니다. <command
>yaboot</command
> 부트로더를 HFS 파일 시스템에 설치해서 텍스트 파일 편집만으로 설정할 수 있습니다. HFS 파일 시스템을 지원하는 어떤 운영 체제라도 부트로더 설정을 바꾸는 데 이용할 수 있습니다. </para
><para
><command
>yaboot</command
>에 같이 들어 있는 <command
>ybin</command
>은 아직 USB 저장 장치를 인식하지 못합니다. 그래서 <classname
>hfsutils</classname
>을 이용해 <command
>yaboot</command
>를 수동으로 설치해야 합니다. 다음 명령을 실행하십시오: <informalexample
><screen>
$ hmount /dev/<replaceable
>sdX2</replaceable>
$ hcopy -r /usr/lib/yaboot/yaboot :
$ hattrib -c UNIX -t tbxi :yaboot
$ hattrib -b :
$ humount
</screen
></informalexample
> 다시 말하지만, 주의해서 올바른 장치 이름을 사용하십시오. 그렇지 않으면 위 명령을 실행해도 파티션을 마운트하지 못합니다. 위의 과정은 부트로더를 파티션에 쓰고, HFS 유틸리티를 사용해 Open Firmware가 부팅할 수 있도록 표시합니다. 다 끝나면, 일반적인 유닉스 유틸리티를 사용해 USB 메모리의 나머지를 준비할 수 있습니다. </para>
   </sect3>

   <sect3 arch="powerpc">
   <title
>설치 프로그램 이미지 추가하기</title>
<para
>파티션을 마운트하고 (<userinput
>mount /dev/<replaceable
>sdX2</replaceable
> /mnt</userinput
>) 다음 설치 프로그램 파일을 USB 메모리로 복사하십시오: <itemizedlist>
<listitem
><para
><filename
>vmlinux</filename
> (커널 바이너리) </para
></listitem>
<listitem
><para
><filename
>initrd.gz</filename
> (최초 램디스크 이미지) </para
></listitem>
<listitem
><para
><filename
>yaboot.conf</filename
> (yaboot 설정 파일) </para
></listitem>
<listitem
><para
><filename
>boot.msg</filename
> (추가 부팅 메세지) </para
></listitem>
</itemizedlist>

</para
><para
><filename
>yaboot.conf</filename
> 설정 파일에는 다음 줄이 들어 있습니다: <informalexample
><screen>
default=install
root=/dev/ram

message=/boot.msg

image=/vmlinux
        label=install
        initrd=/initrd.gz
        initrd-size=10000
        read-only
</screen
></informalexample
> <userinput
>initrd-size</userinput
> 파라미터는 부팅하려는 이미지에 따라 크기를 늘려야 할 수도 있습니다. </para
><para
><filename
>hd-media</filename
> 이미지를 사용하는 경우, 데비안 ISO 이미지를 USB 메모리에 복사해야 합니다. (비지니스 카드, 네트워크 설치, 전체 CD 이미지 중에서 용량에 맞는 이미지를 하나 고르십시오.) 복사했으면 USB 메모리 마운트를 해제합니다. (<userinput
>umount /mnt</userinput
>) </para>
   </sect3>
<!--   End of file install-methods/usb-setup/powerpc.xml -->

  </sect2>

  <!-- TODO: doesn't this section belong later? -->
  <sect2 arch="x86">
  <title
>USB 메모리 부팅하기</title>
<warning
><para
>USB 메모리에서 부팅하지 못한다면, USB 메모리의 마스터 부트 레코드가 잘못됐을 수 있습니다. 바로잡으려면 <classname
>mbr</classname
> 패키지에서 <command
>install-mbr</command
> 명령을 사용하십시오: <informalexample
><screen
># install-mbr /dev/<replaceable
>sdX</replaceable
>
</screen
></informalexample>

</para
></warning>
  </sect2>
 </sect1>
<!--   End of file install-methods/boot-usb-files.xml -->

<!-- Start of file install-methods/boot-drive-files.xml -->
<!-- $Id: boot-drive-files.xml 39614 2006-08-07 15:50:11Z fjp $ -->

 <sect1 condition="bootable-disk" id="boot-drive-files">
 <title
>하드 디스크 부팅에 필요한 파일 준비하기</title>
<para
>설치 프로그램은 기존 하드 드라이브 파티션에 들어 있는 부팅 파일을 이용해서 부팅할 수 있습니다. 다른 운영체제를 통해서 실행할 수도 있고, 아니면 BIOS에서 직접 부트로더를 실행할 수도 있습니다. </para
><para
><quote
>네트워크만</quote
> 사용해 완전히 설치하려면 이 방법을 사용하면 됩니다. 네트워크 설치를 사용하면 CD 이미지를 찾아서 구울 필요도 없고, 여러 장의 불안한 플로피와 씨름할 필요도 없습니다. </para
><para arch="x86"
>설치 프로그램은 NTFS 파일시스템의 파일에서는 부팅할 수 없습니다. </para
><para arch="powerpc"
>설치 프로그램은 HFS+ 파일 시스템에서는 부팅할 수 없습니다. 맥오에스 시스템 8.1과 그 후의 버전은 HFS+ 파일 시스템을 사용할 수도 있습니다. 뉴월드 파워맥은 전부 HFS+를 사용합니다. 기존 파일 시스템이 HFS+인지 아닌지 알아보려면, 해당 볼륨에서 <userinput
>Get Info</userinput
>를 선택하십시오. HFS 파일 시스템은 <userinput
>Mac OS Standard</userinput
>라고 나오고, HFS+ 파일 시스템은 <userinput
>Mac OS Extended</userinput
>라고 나옵니다. 맥오에스와 리눅스 사이에 파일을 교환하려면 HFS 파티션을 만들어야 합니다. 특히 설치에 쓸 파일을 다운로드할 때 이 파티션이 필요합니다. </para
><para arch="powerpc"
>시스템이 <quote
>뉴월드</quote
> 모델인지 <quote
>올드월드</quote
> 모델인지에 따라, 하드 디스크로 설치 시스템을 부팅할 때 여러 가지 프로그램을 사용합니다. </para>

  <sect2 arch="x86" id="files-lilo">
  <title
><command
>LILO</command
> 혹은 <command
>GRUB</command
>을 이용한 하드 디스크 설치 프로그램 부팅</title>
<para
>여기서는 <command
>LILO</command
> 혹은 <command
>GRUB</command
>을 이용해 기존에 설치한 리눅스에 새로 추가하거나 아니면 기존 리눅스를 덮어 쓰는 방법을 설명합니다. </para
><para
>부팅할 때 부트로더 두 가지 모두 커널은 물론이고, 디스크 이미지도 메모리에 올리는 기능을 지원합니다. 이 로우 디스크는 커널의 루트 파일 시스템으로 사용할 수 있습니다. </para
><para
>데비안 아카이브의 다음 파일을 하드 드라이브의 편리한 위치로 복사하십시오. 예를 들어 <filename
>/boot/newinstall/</filename
>같은 위치로 복사하십시오. <itemizedlist>
<listitem
><para
><filename
>vmlinuz</filename
> (커널 바이너리) </para
></listitem>
<listitem
><para
><filename
>initrd.gz</filename
> (램디스크 이미지) </para
></listitem>
</itemizedlist>

</para
><para
>마지막으로 부트로더를 설정하려면 <xref linkend="boot-initrd"/> 부분으로 진행하십시오. </para>
  </sect2>


  <sect2 arch="powerpc" id="files-oldworld">
  <title
>올드월드 맥에서 하드 디스크 설치 프로그램 부팅</title>
<para
><filename
>boot-floppy-hfs</filename
> 플로피는 <application
>miBoot</application
>를 사용해 리눅스 설치를 시작합니다. 하지만 <application
>miBoot</application
>는 하드 디스크 부팅에는 쉽사리 사용할 수 없습니다. 맥오에스에서 시작하는 <application
>BootX</application
>는 하드 디스크에 들어 있는 파일에서 부팅하는 기능을 지원합니다. <application
>BootX</application
>는 데비안 설치를 한 다음에도 맥오에스와 리눅스 사이에 선택 부팅하는 데 쓸 수도 있습니다. Performa 6360의 경우, <command
>quik</command
>로는 하드 디스크를 부팅 가능하게 만들 수 없습니다. 그래서 이 모델에서는 <application
>BootX</application
>가 필요합니다. </para
><para
><application
>BootX</application
>를 다운로드해서 압축을 푸십시오. <ulink url="&url-powerpc-bootx;"
></ulink
>, 혹은 데비안 http/ftp 미러나 공식 데비안 CD의 <filename
>dists/woody/main/disks-powerpc/current/powermac</filename
> 디렉토리에 들어 있습니다. 압축 파일을 풀려면 <application
>Stuffit Expander</application
>를 사용하십시오. 패키지 안을 보면, <filename
>Linux Kernels</filename
>라는 빈 폴더가 있습니다. <filename
>disks-powerpc/current/powermac</filename
> 폴더에서 <filename
>linux.bin</filename
> 및 <filename
>ramdisk.image.gz</filename
> 파일을 받아서, <filename
>Linux Kernels</filename
> 폴더에 넣으십시오. 그리고 <filename
>Linux Kernels</filename
> 폴더를 활성 시스템 폴더에 넣으십시오. </para>
  </sect2>

  <sect2 arch="powerpc" id="files-newworld">
  <title
>뉴월드 맥에서 하드 디스크 설치 프로그램 부팅</title>
<para
>뉴월드 파워맥은 하드 디스크에서 직접 ELF 바이너리를 읽어들이는 것 외에, 네트워크나 ISO9660 CD-ROM을 이용한 부팅을 지원합니다. 이러한 컴퓨터에서는 <command
>yaboot</command
>로 직접 리눅스를 부팅합니다. <command
>yaboot</command
>는 맥오에스와의 선택 부팅도 지원하고 EXT2 파티션에서 직접 커널과 램디스크를 읽어들이는 기능을 지원합니다. 설치 프로그램의 하드 디스크 부팅은 특히 플로피 드라이브가 없는 최신 컴퓨터에서 좋습니다. <command
>BootX</command
>는 지원하지 않고 뉴월드 파워맥에서는 사용해서는 안 됩니다. </para
><para
>앞에서 데비안 아카이브에서 다운로드한, 다음 4개 파일을 하드 디스크의 맨 위 디렉토리로 <emphasis
>복사</emphasis
>(옮기는 게 아님)하십시오. (각 파일을 <keycap
>option</keycap
> 키를 누르고 하드 드라이브 아이콘으로 끌어오면 됩니다.) <itemizedlist>
<listitem
><para>

<filename
>vmlinux</filename>

</para
></listitem>
<listitem
><para>

<filename
>initrd.gz</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot.conf</filename>

</para
></listitem>
</itemizedlist>

</para
><para
>이 파일을 넣어 둔 맥오에스 파티션의 파티션 번호를 적어 놓으십시오. 맥오에스의 <command
>pdisk</command
> 프로그램이 있으면, <command
>L</command
> 명령으로 파티션 번호를 알아낼 수 있습니다. 이 파티션 번호는 나중에 Open Firmware 프롬프트에서 설치 프로그램을 부팅하는 명령에서 사용합니다. </para
><para
>설치 프로그램을 부팅하려면, <xref linkend="boot-newworld"/> 부분으로 계속 진행하십시오. </para>
  </sect2>
 </sect1>
<!--   End of file install-methods/boot-drive-files.xml -->

<!-- Start of file install-methods/install-tftp.xml -->
<!-- $Id: install-tftp.xml 56425 2008-10-15 08:50:59Z fjp $ -->

 <sect1 condition="supports-tftp" id="install-tftp">
 <title
>TFTP 네트워크 부팅에 필요한 파일 준비하기</title>
<para
>LAN에 연결되어 있다면, 네트워크를 통해 TFTP를 사용해서 다른 컴퓨터에서 부팅할 수도 있습니다. 다른 컴퓨터에서 설치 시스템을 부팅하려고 한다면, 부팅 파일을 특정 위치에 복사해 놓고, 해당 컴퓨터의 부팅을 지원하도록 설정해 놓아야 합니다. </para
><para
>TFTP 서버를 설정해야 합니다. 그리고 많은 컴퓨터에서 DHCP 서버<phrase condition="supports-rarp"
> 아니면 RARP 서버</phrase
><phrase condition="supports-bootp"
>, 아니면 BOOTP 서버</phrase
>를 설정해야 합니다. </para
><para
><phrase condition="supports-rarp"
>Reverse Address Resolution Protocol은 (RARP) 어떤 클라이언트에게 어떤 IP 주소를 사용해야 하는 지 알려주는 한 방법입니다. 또 다른 방법은 BOOP 프로토콜을 사용하는 것입니다. </phrase
> <phrase condition="supports-bootp"
>BOOTP는 컴퓨터에게 그 IP 주소 및 네트워크의 어디에서 부팅 이미지를 가져와야 하는 지 알려주는 IP 프로토콜입니다. </phrase
> <phrase arch="m68k"
> VMEbus 시스템에서는 또 다른 방법이 있습니다. 부팅 ROM에 IP 주소를 수동으로 설정할 수 있습니다. </phrase
> DHCP는 (Dynamic Host Configuration Protocol) 더 유연하며, BOOTP와 호환되는 확장 기능입니다. 일부 시스템은 DHCP를 이용해야만 설정할 수 있습니다. </para
><para arch="powerpc"
>PowerPC의 경우, 뉴월드 파워 매킨토시 컴퓨터를 가지고 있다면, BOOTP 대신에 DHCP를 사용하는 게 좋습니다. 최근의 일부 컴퓨터는 BOOTP로는 부팅할 수 없습니다. </para
><para arch="alpha"
>Sparc과 PowerPC 컴퓨터에 들어 있는 Open Firmware와는 다르게, SRM 콘솔은 IP 주소를 가져올 때 RARP를 쓰지 <emphasis
>않습니다</emphasis
>. 그래서 Alpha를 네트워크 부팅할 때는 BOOTP를 사용해야 합니다<footnote
> <para
> Alpha 시스템은 DECNet MOP(Maintenance Operations Protocol)을 사용하여 네크워크로부팅할 수 있습니다. 그러나 이 방법은 여기서 다루지 않습니다. 아마도 해당 OpenVMS 관리자가 Alpha에서 리눅스를 부팅하는 데 MOP를 사용하는 방법에 대해 도움을 줄 것입니다</para
> </footnote
>. SRM 콘솔에서 네트워크를 위한 IP 설정을 직접 입력할 수도 있습니다. </para
><para arch="hppa"
>일부 오래된 HPPA 컴퓨터의 경우 (예를 들어 715/75) BOOTP를 쓰지 마시고 RBOOTD를 사용하십시오. 데비안에는 <classname
>rbootd</classname
> 패키지가 들어 있습니다. </para
><para
>Trivial File Transfer Protocol은 (TFTP) 부팅 이미지를 클라이언트에게 넘겨줄 때 사용합니다. 이론상 이 프로토콜을 사용한다면 어떤 플랫폼의 어떤 서버라도 사용할 수 있습니다. 여기서는 SunOS 4.x, SunOS 5.x (Solaris), 그리고 GNU/Linux에서 사용하는 명령을 예로 듭니다. <note arch="x86"
><para
>TFTP 부팅에서 Pre-boot Execution Environment (PXE) 방식을 사용하려면, <userinput
>tsize</userinput
>를 지원하는 TFTP 서버가 있어야 합니다. &debian; 서버에서는, <classname
>atftpd</classname
> 및 <classname
>tftpd-hpa</classname
> 패키지가 이 기능을 지원합니다. <classname
>tftpd-hpa</classname
>를 권장합니다. </para
></note>

</para>


<!-- Start of file install-methods/tftp/rarp.xml -->
<!-- $Id: rarp.xml 39897 2006-08-16 20:36:24Z fjp $ -->


  <sect2 condition="supports-rarp" id="tftp-rarp">
  <title
>RARP 서버 준비하기</title>
<para
>RARP를 설정하려면, 설치하려는 클라언트 컴퓨터의 이더넷 주소를 (다른 말로 MAC 주소) 알아야 합니다. 이 정보를 모른다면, <phrase arch="sparc"
> OpenPROM 부팅 메세지에서 보고 알아낼 수도 있고, OpenBoot <userinput
>.enet-addr</userinput
> 명령을 사용할 수도 있고, 아니면 </phrase
> <quote
>응급 복구</quote
> 모드로 부팅해서 (예를 들어 응급 복구 플로피로) <userinput
>/sbin/ifconfig eth0</userinput
> 명령을 이용할 수 있습니다. </para
><para
>리눅스 2.4 혹은 2.6 커널을 사용하는 RARP 서버 시스템이나 Solaris/SunOS에서는 <command
>rarpd</command
> 프로그램을 사용합니다. 클라이언트에 대한 이더넷 하드웨어 주소를 <quote
>ethers</quote
> 데이터베이스에 넣어야 합니다(<filename
>/etc/ethers</filename
> 파일이나 NIS/NIS+를 이용). 그 다음에 RARP 데몬을 시작합니다. 다음 명령을 (root로) 실행합니다: 대부분 리눅스 시스템이나 SunOS5(Solaris 2)에서는 <userinput
>/usr/sbin/rarpd -a</userinput
>, 기타 리눅스 시스템에서는 <userinput
>/usr/sbin/in.rarpd -a</userinput
>, SunOS4(Solaris 1)에서는 <userinput
>/usr/etc/rarpd -a</userinput
>. </para>
  </sect2>
<!--   End of file install-methods/tftp/rarp.xml -->

<!-- Start of file install-methods/tftp/bootp.xml -->
<!-- $Id: bootp.xml 43558 2006-12-26 19:46:26Z fjp $ -->


  <sect2 condition="supports-bootp" id="tftp-bootp">
  <title
>BOOTP 서버 준비하기</title>
<para
>GNU/리눅스용 BOOTP 서버는 두 가지가 있습니다. 하나는 CMU <command
>bootpd</command
>이고,다른 프로그램은 실제로 DHCP서버인, ISC <command
>dhcpd</command
>가 있습니다. 이 프로그램은 <classname
>bootp</classname
> 와 <classname
>dhcp3-server</classname
>라는 패키지로 포함되어 있습니다. </para
><para
>CMU <command
>bootpd</command
>를 사용하려면, <filename
>/etc/inetd.conf</filename
>에서 관련된 줄의 주석을 없애거나 한 줄을 추가해야 합니다. &debian;에선  <userinput
>update-inetd --enable bootps</userinput
>를 실행한 다음 적용하려면 <userinput
>/etc/init.d/inetd reload</userinput
> 명령을 실행합니다. 데비안에서 BOOTP서버가 실행이 되지 않는 다면, 문제에 나온 줄은 다음과 같은 모양입니다: <informalexample
><screen>
bootps  dgram  udp  wait  root  /usr/sbin/bootpd  bootpd -i -t 120
</screen
></informalexample
> 이제 <filename
>/etc/bootptab</filename
> 파일을 만들어야 합니다. 이 파일은 과거의 BSD <filename
>printcap</filename
>, <filename
>termcap</filename
>, <filename
>disktab</filename
> 파일과 유사한 형식으로 되어 있습니다. 더 자세한 정보는 <filename
>bootptab</filename
> 맨페이지를 참고하십시오. CMU <command
>bootpd</command
>에서는, 클라이언트의 하드웨어 (MAC) 주소를 알아야 합니다. 다음은 <filename
>/etc/bootptab</filename
>의 예입니다: <informalexample
><screen>
client:\
  hd=/tftpboot:\
  bf=tftpboot.img:\
  ip=192.168.1.90:\
  sm=255.255.255.0:\
  sa=192.168.1.1:\
  ha=0123456789AB:
</screen
></informalexample
> 위에서 최소한 <quote
>ha</quote
> 옵션은 바꿔야 합니다. 이 옵션은 클라이언트의 하드웨어 주소를 나타냅니다. <quote
>bf</quote
> 옵션은 TFTP로 클라이언트가 받게 될 파일을 지정합니다. 자세한 정보는 <xref linkend="tftp-images"/> 부분을 참고하십시오. <phrase arch="mips"
> SGI 컴퓨터에서는 커맨드 모니터로 들어가서 <userinput
>printenv</userinput
>라고 입력하면 됩니다. <userinput
>eaddr</userinput
> 변수의 값이 MAC 주소입니다. </phrase
> </para
><para
>반대로, ISC <command
>dhcpd</command
> 설정은 정말 쉽습니다. BOOTP 클라이언트를 DHCP 클라이언트의 일종의 특별한 케이스로 취급하기 때문입니다. 일부 아키텍쳐에서는 BOOTP로 부팅하게 하려면 복잡한 설정이 필요합니다. 그러한 아키텍처의 경우는 <xref linkend="dhcpd"/> 부분을 참고하십시오. 그러한 경우 <userinput
>allow bootp</userinput
>를 클라이언트가 들어 있는 서브넷의 설정 부분에 집어 넣고, <userinput
>/etc/init.d/dhcp3-server restart</userinput
> 명령으로 <command
>dhcpd</command
>를 다시 시작하면 됩니다. </para>
  </sect2>
<!--   End of file install-methods/tftp/bootp.xml -->

<!-- Start of file install-methods//tftp/dhcp.xml -->
<!-- $Id: dhcp.xml 43558 2006-12-26 19:46:26Z fjp $ -->

  <sect2 id="dhcpd">
   <title
>DHCP 서버 준비하기</title>
<para
>자유 소프트웨어 DHCP 서버의 하나로 ISC <command
>dhcpd</command
>가 있습니다. &debian;에서는 <classname
>dhcp3-server</classname
> 패키지를 권장합니다. 다음은 간단한 설정 파일 예제입니다 (<filename
>/etc/dhcp3/dhcpd.conf</filename
> 파일을 보십시오): <informalexample
><screen
>option domain-name "example.com";
option domain-name-servers ns1.example.com;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
server-name "servername";

subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.200 192.168.1.253;
  option routers 192.168.1.1;
}

host clientname {
  filename "/tftpboot/tftpboot.img";
  server-name "servername";
  next-server servername;
  hardware ethernet 01:23:45:67:89:AB;
  fixed-address 192.168.1.90;
}
</screen
></informalexample>

</para
><para
>이 예제에서는, DHCP 서버, TFTP 서버, 네트워크 게이트웨이 역할을 모두 하는 <replaceable
>servername</replaceable
>이라는 서버가 있다고 가정합니다. domain-name 옵션도 바꾸고, 서버 이름과 클라이언트 하드웨어 주소도 바꿔야 합니다. <replaceable
>filename</replaceable
> 옵션은 TFTP로 가져오려는 파일의 이름입니다. </para
><para
><command
>dhcpd</command
> 설정 파일을 편집한 다음에, <userinput
>/etc/init.d/dhcp3-server restart</userinput
> 명령으로 <command
>dhcpd</command
>를 다시 시작하십시오. </para>

   <sect3 arch="x86">
   <title
>DHCP 설정에서 PXE 부팅하게 만들기</title>
<para
>다음은 TFTP의 Pre-boot Execution Environment (PXE) 방식을 이용한 <filename
>dhcp.conf</filename
>의 예입니다. <informalexample
><screen>
option domain-name "example.com";

default-lease-time 600;
max-lease-time 7200;

allow booting;
allow bootp;

# 다음 부분은 여러분 경우에 맞춰 바꿔야 합니다
subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.200 192.168.1.253;
  option broadcast-address 192.168.1.255;
# 게이트웨이 주소입니다.
# (예를 들어 인터넷에 접근하는 방법에 따라 다를 수도 있습니다)
  option routers 192.168.1.1;
# 사용하려는 DNS
  option domain-name-servers 192.168.1.3;
}

group {
 next-server 192.168.1.3;
 host tftpclient {
# TFTP 클라이언트 하드웨어 주소
  hardware ethernet  00:10:DC:27:6C:15;
  filename "pxelinux.0";
 }
}
</screen
></informalexample
> PXE 부팅의 경우, 커널 이미지가 아니라 클라이언트 파일 이름 <filename
>pxelinux.0</filename
>이 부트로더입니다. (아래의 <xref linkend="tftp-images"/> 부분 참고) </para>
   </sect3>
  </sect2>
<!--   End of file install-methods//tftp/dhcp.xml -->

  <sect2 id="tftpd">
  <title
>TFTP 서버 사용하기</title>
<para
>TFTP 서버를 준비하려면, 먼저 <command
>tftpd</command
> 서버를 사용도록 해야 합니다. 보통 다음과 같은 줄을 <filename
>/etc/inetd.conf</filename
>에 넣으면 됩니다: <informalexample
><screen>
tftp dgram udp wait nobody /usr/sbin/tcpd in.tftpd /tftpboot
</screen
></informalexample
> 데비안 패키지의 경우에는 설치만 하면 기본적으로 이런 설정이 들어갑니다. </para>
<note
><para
>전통적으로 부팅 이미지를 저장하는 위치로 TFTP 서버는 <filename
>/tftpboot</filename
> 디렉토리를 사용합니다. 하지만, &debian; 패키지는 <ulink url="&url-fhs-home;"
>Filesystem Hierarchy Standard</ulink
>에 맞추기 위해 다른 디렉토리를 사용합니다. 예를 들어, <classname
>tftpd-hpa</classname
>는 기본값으로 <filename
>/var/lib/tftpboot</filename
>를 사용합니다. 여기서 설명하는 설정 파일 예제에서는 이 점을 고려해서 적용하십시오. </para
></note>
<para
><filename
>/etc/inetd.conf</filename
> 파일을 보고 <command
>in.tftpd</command
>의 인자로 사용하는 디렉토리를 기억해 두십시오<footnote
> <para
> 데비안에 들어 있는 모든 <command
>in.tftpd</command
> 프로그램은 TFTP 요청을 시스템 로그에 기록합니다. 일부 프로그램은 <userinput
>-v</userinput
> 옵션으로 자세히 기록할 수 있습니다. 부팅 문제가 있는 경우 이 로그 메세지를 확인하길 권합니다. 오류 원인을 진단할 때는 이 로그 메세지부터 시작해 보는 게 좋습니다. </para
> </footnote
>. 아래에서 이 디렉토리 이름이 필요합니다. <filename
>/etc/inetd.conf</filename
> 파일을 바꿨다면, 바꿨다는 사실을 <command
>inetd</command
> 프로세스에 알려야 합니다. 데비안 컴퓨터에서는 <userinput
>/etc/init.d/inetd reload</userinput
> 명령을 실행하고, 다른 곳에서는 <command
>inetd</command
>의 프로세스 ID를 찾아서 <userinput
>kill -HUP <replaceable
>inetd-pid</replaceable
></userinput
> 명령을 실행합니다. </para
><para arch="mips"
>데비안을 SGI 컴퓨터에 설치하려 하고, TFTP 서버가 리눅스 2.4로 동작하는 GNU/리눅스인 경우, 서버에서 다음을 설정해야 합니다: <informalexample
><screen>
# echo 1 &gt; /proc/sys/net/ipv4/ip_no_pmtu_disc
</screen
></informalexample
> 이 명령은 Path MTU discovery 기능을 끕니다. 이 기능을 끄지 하지 않으면 SGI의 PROM이 커널을 다운로드하지 못합니다. 또 32767보다 높지 않은 포트에서 TFTP 패킷을 보내도록 만드십시오. 그렇지 않으면 첫번째 패킷을 받은 다음에 멈춰버립니다. 이 문제는 PROM의 버그를 리눅스 2.4.x에서 들춰내는 것입니다. 다음 명령으로 이런 현상을 피할 수 있습니다: <informalexample
><screen>
# echo "2048 32767" &gt; /proc/sys/net/ipv4/ip_local_port_range
</screen
></informalexample
> 이 명령은 리눅스 TFTP 서버에서 사용할 포트의 범위를 조정합니다. </para>
  </sect2>

  <sect2 id="tftp-images">
  <title
>TFTP 이미지를 적당한 위치에 놓기</title>
<para
>그 다음에, 필요한 TFTP 부팅 이미지를 <xref linkend="where-files"/>에 쓰여 있는 것처럼 <command
>tftpd</command
> 부팅 이미지 디렉토리에 복사해 놓으십시오. 이 파일에서, <command
>tftpd</command
>가 특정 클라이언트를 부팅할 때 사용하는 특정 파일로 링크를 만들어야 할 것입니다. 불행히도 그 파일의 이름은 TFTP 클라이언트가 결정하고, 어떤 표준도 없습니다. </para
><para arch="powerpc"
>뉴월드 파워 매킨토시 컴퓨터에서는, TFTP 부팅 이미지로 <command
>yaboot</command
>를 설정해야 합니다. <command
>yaboot</command
>는 커널과 램디스크를 TFTP를 통해 가져옵니다. <filename
>netboot/</filename
> 디렉토리에서 다음 파일을 다운로드해야 합니다: <itemizedlist>
<listitem
><para>

<filename
>vmlinux</filename>

</para
></listitem>
<listitem
><para>

<filename
>initrd.gz</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot</filename>

</para
></listitem>
<listitem
><para>

<filename
>yaboot.conf</filename>

</para
></listitem>
<listitem
><para>

<filename
>boot.msg</filename>

</para
></listitem>
</itemizedlist>

</para
><para arch="x86"
>PXE 부팅의 경우, 필요한 모든 것이 <filename
>netboot/netboot.tar.gz</filename
> 압축 안에 준비되어 있습니다. 이 압축을 <command
>tftpd</command
> 부팅 이미지 디렉토리에서 풀기만 하십시오. <command
>tftpd</command
>에 부팅할 파일 이름으로 <filename
>pxelinux.0</filename
>을 넘기도록 DHCP 서버에 설정하십시오. </para
><para arch="ia64"
>PXE 부팅의 경우, 필요한 모든 것이 <filename
>netboot/netboot.tar.gz</filename
> 압축 안에 준비되어 있습니다. 이 압축을 <command
>tftpd</command
> 부팅 이미지 디렉토리에서 풀기만 하십시오. <command
>tftpd</command
>에 부팅할 파일 이름으로 <filename
>/debian-installer/ia64/elilo.efi</filename
>을 넘기도록 DHCP 서버에 설정하십시오. </para>

   <sect3 arch="alpha">
   <title
>Alpha TFTP 부팅</title>
<para
>Alpha에서는, SRM의 <userinput
>boot</userinput
> 명령에 <userinput
>-file</userinput
> 인자를 사용하거나, <userinput
>BOOT_FILE</userinput
> 환경 변수를 지정해 파일 이름을 지정해야 합니다.  (부팅 이미지 디렉토리의 상대 경로) 아니면 다른 방법으로, BOOP를 통해 파일 이름을 넘겨줄 수 있습니다. (ISC <command
>dhcpd</command
>에서는 <userinput
>filename</userinput
>을 사용합니다) Open Firmware와는 달리, SRM에는 <emphasis
>기본 파일 이름이 없습니다</emphasis
>. 그래서 이러한 방법 중의 하나를 이용해서 파일 이름을 <emphasis
>지정해야 합니다</emphasis
>. </para>
   </sect3>

   <sect3 arch="sparc">
   <title
>SPARC TFTP 부팅</title>
<para
>예를 들어 sparc 아키텍처에서는 서브 아키텍처 이름을 사용합니다. <quote
>SUN4M</quote
>, <quote
>SUN4C</quote
>과 같이 씁니다. 만약 아키텍처를 비워두면, 클라이언트에서 <filename
>16진수-클라이언트-IP</filename
>를 파일 이름으로 사용합니다. 시스템의 서브 아키텍처가 SUN4C이고 IP가 192.168.1.3이라면, 파일 이름은 <filename
>C0A80103.SUN4C</filename
>입니다. 이름을 알아내기 쉬운 방법은 쉘에서 다음 명령을 실행하는 것입니다: (컴퓨터의 IP가 10.0.0.4라고 가정) <informalexample
><screen>
$ printf '%.2x%.2x%.2x%.2x\n' 10 0 0 4
</screen
></informalexample
> 이렇게 하면 IP를 16진수로 표시합니다. 파일 이름은 모든 글자를 대문자로 바꿔야 하고 필요하다면 서브 아키텍처 이름을 뒤에 붙입니다. </para
><para
>모두 올바르게 했다면, OpenPROM에서 <userinput
>boot net</userinput
> 명령을 입력해 이미지를 읽어들입니다. 이미지를 찾지 못한다면 TFTP 서버의 로그 파일을 보고 어떤 이미지 이름을 요청했는 지 확인하십시오. </para
><para
>일부 sparc 시스템은 OpenPROM 부팅 명령 뒤에 특정 파일이름을 붙여서 이 파일을 찾도록 만들 수 있습니다. 예를 들어 <userinput
>boot net my-sparc.image</userinput
>. 파일은 TFTP 서버가 찾는 디렉토리 안에 들어 있어야 합니다. </para>
   </sect3>

   <sect3 arch="m68k">
   <title
>BVM/모토로라 TFTP 부팅</title>
<para
>BVM 및 모토로라 VMEbus 시스템에서는 &bvme6000-tftp-files; 파일을 <filename
>/tftpboot/</filename
> 디렉토리에 복사하십시오. </para
><para
>그 다음에, 최초에 <filename
>tftplilo.bvme</filename
> 혹은 <filename
>tftplilo.mvme</filename
> 파일을 TFTP 서버에서 읽어들이도록 부팅 ROM과 BOOTP 서버를 설정하십시오. 해당 시스템 관련 설정에 관한 추가 정보는 해당 서브 아키텍처의 <filename
>tftplilo.txt</filename
> 파일을 참고하십시오. </para>
   </sect3>

   <sect3 arch="mips">
   <title
>SGI TFTP 부팅</title>
<para
>SGI 컴퓨터에서는 <command
>bootpd</command
> 명령만을 이용해서 TFTP 파일 이름을 넙깁니다. 파일 이름은 <filename
>/etc/bootptab</filename
> 파일의 <userinput
>bf=</userinput
> 혹은 <filename
>/etc/dhcpd.conf</filename
> 파일의 <userinput
>filename=</userinput
> 옵션으로 지정합니다. </para>
   </sect3>

   <sect3 arch="mips">
   <title
>Broadcom BCM91250A과 BCM91480B TFTP 부팅</title>
<para
>CFE로 읽어들일 파일의 전체 경로를 넘기기 때문에 DHCP를 특별히 설정할 필요가 없습니다. </para>
   </sect3>

  </sect2>

<!-- FIXME: commented out since it seems too old to be usable and a current
            way is not known

  <sect2 id="tftp-low-memory">
  <title
>TFTP Installation for Low-Memory Systems</title>
<para>

On some systems, the standard installation RAMdisk, combined with the
memory requirements of the TFTP boot image, cannot fit in memory.  In
this case, you can still install using TFTP, you'll just have to go
through the additional step of NFS mounting your root directory over
the network as well.  This type of setup is also appropriate for
diskless or dataless clients.

</para
><para>

First, follow all the steps above in <xref linkend="install-tftp"/>.

<orderedlist>
<listitem
><para>

Copy the Linux kernel image on your TFTP server using the
<userinput
>a.out</userinput
> image for the architecture you are
booting.

</para
></listitem>
<listitem
><para>

Untar the root archive on your NFS server (can be the same system as
your TFTP server):

<informalexample
><screen
>
# cd /tftpboot
# tar xvzf root.tar.gz
</screen
></informalexample>

Be sure to use the GNU <command
>tar</command
> (other tar programs, like the
SunOS one, badly handle devices as plain files).

</para
></listitem>
<listitem
><para>

Export your <filename
>/tftpboot/debian-sparc-root</filename
> directory
with root access to your client.  E.g., add the following line to
<filename
>/etc/exports</filename
> (GNU/Linux syntax, should be similar
for SunOS):

<informalexample
><screen
>
/tftpboot/debian-sparc-root <replaceable>client</replaceable>(rw,no_root_squash)
</screen
></informalexample>

NOTE: <replaceable
>client</replaceable
> is the host name or IP address recognized
by the server for the system you are booting.

</para
></listitem>
<listitem
><para>

Create a symbolic link from your client IP address in dotted notation
to <filename
>debian-sparc-root</filename
> in the
<filename
>/tftpboot</filename
> directory.  For example, if the client
IP address is 192.168.1.3, do

<informalexample
><screen
>
# ln -s debian-sparc-root 192.168.1.3
</screen
></informalexample>

</para
></listitem>
</orderedlist>

</para>

  </sect2>

  <sect2 condition="supports-nfsroot">
  <title
>Installing with TFTP and NFS Root</title>
<para>

Installing with TFTP and NFS Root is similar to
<xref linkend="tftp-low-memory"/> because you don't want to
load the RAMdisk anymore but boot from the newly created NFS-root file
system.  You then need to replace the symlink to the tftpboot image by
a symlink to the kernel image (for example,
<filename
>linux-a.out</filename
>).

</para
><para>

RARP/TFTP requires all daemons to be running on the same server (the
workstation is sending a TFTP request back to the server that replied
to its previous RARP request).

</para>


  </sect2>
END FIXME -->
 </sect1>
<!--   End of file install-methods/install-tftp.xml -->

<!-- Start of file install-methods/automatic-install.xml -->
<!-- $Id: automatic-install.xml 33725 2006-01-03 19:39:07Z fjp $ -->

 <sect1 id="automatic-install">
 <title
>자동 설치</title>
<para
>여러 컴퓨터에 설치하려면 완전 자동 설치를 사용할 수도 있습니다. 이런 목적을 위한 데비안 패키지는 <classname
>fai</classname
> (설치 서버 사용), <classname
>replicator</classname
>, <classname
>systemimager</classname
>, <classname
>autoinstall</classname
>이 있고, 데비안 설치 프로그램 자체를 사용할 수도 있습니다. </para>

  <sect2 id="preseed">
  <title
>데비안 설치 프로그램을 이용한 자동 설치</title>
<para
>데비안 설치 프로그램은 미리 설정해 놓은 파일을 이용해 자동 설치를 지원합니다. 미리 설정해 놓은 파일은 네트워크 혹은 이동식 미디어로 읽어들일 수 있습니다. 이 파일 안에는 설치 과정에서 나오는 질문에 대한 대답이 들어 있습니다. </para
><para
><xref linkend="appendix-preseed"/>에 보면 미리 설정에 대한 문서가 있고, 약간 고쳐서 사용할 수 있는 잘 동작하는 예제가 있습니다. </para>
  </sect2>
 </sect1>
<!--   End of file install-methods/automatic-install.xml -->

</chapter>
<!--   End of file install-methods/install-methods.xml -->
