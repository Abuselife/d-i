#!/usr/bin/perl
# © 2012-2021 Cyril Brulebois <kibi@debian.org>
#
# Help the release manager prepare a release announcement for the
# Debian Installer. Compare the state of the Debian archive between
# old and new debian-installer uploads (and debian-cd builds), and
# extract interesting changelog entries, to be massaged into a
# possibly comprehensive release announcement.

use strict;
use warnings;

use Data::Dumper;
use Dpkg::Control;
use File::Slurp;
use IO::Uncompress::Gunzip qw(gunzip $GunzipError);
use Storable;

# XXX: this requires a Debian (<= 10) environment for now
use Parse::DebianChangelog;
use LWP::UserAgent;
use Text::TabularDisplay;
my $workdir = 'release-announce.tmp';
my $report_filename = 'report.txt';
my $changelogs_filename = 'changelogs.html';
open my $report, '>', $report_filename
    or die "Unable to write to $report_filename";
my $mirror = 'http://ftp.fr.debian.org/debian';


sub get_sources {
    my $path = shift;
    my $udeb_list = shift;
    my @results;
    my %sources;

    if (! -f $udeb_list) {
	print "E: use psql service=projectb on respighi to get the most recent list of udebs\n";
	exit 1;
    }
    my @udebs = map { chomp; $_ } read_file($udeb_list);
    #print "udebs:", @udebs, "\n";
    my ($p, $v, $s);
    my $sources_file = $path;
    my $buf_out = '';
    open my $buf_fh, '+<', \$buf_out or die $!;
    my $status = gunzip $sources_file => \$buf_out
        or die "gunzip failed: $GunzipError";
    while (not $buf_fh->eof()) {
        my $c = Dpkg::Control->new( type => CTRL_INDEX_SRC );
        my $item = $c->parse($buf_fh, $sources_file);
        my ($p, $v, $eso) = ($c->{Package}, $c->{Version}, $c->{'Extra-Source-Only'});
        next
            if $eso;
        if (grep { $p eq $_ } @udebs) {
            push @results, "$p/$v";
            $sources{$p}{binaries} = [sort split /, /, $c->{Binary}];
        }
    }
    return (\@results, \%sources);
}

# Remember those triplets as that information can be reused in other
# contexts:
my @VERSIONS = (
  # Snapshot TS        D-I vers.   D-I release name
  ['20190411T084713Z', '20190410', 'Buster RC 1'     ],
  ['20190624T091546Z', '20190623', 'Buster RC 2'     ],
  ['20190702T085226Z', '20190702', 'Buster RC 3'     ],
  ['20191130T031031Z', '20191129', 'Bullseye Alpha 1'],
  ['20200315T090339Z', '20200314', 'Bullseye Alpha 2'],
  ['20201203T092240Z', '20201202', 'Bullseye Alpha 3'],
  ['20210415T151642Z', '20210415', 'Bullseye RC 1'   ],
);

# Compare the last two:
my $ts1 = $VERSIONS[-2]->[0];
my $ts2 = $VERSIONS[-1]->[0];

`wget http://snapshot.debian.org/archive/debian/${ts1}/dists/bullseye/main/source/Sources.gz -O ${ts1}_Sources.gz`
    if ! -f "${ts1}_Sources.gz";
`wget http://snapshot.debian.org/archive/debian/${ts2}/dists/bullseye/main/source/Sources.gz -O ${ts2}_Sources.gz`
    if ! -f "${ts2}_Sources.gz";

if (! -f "${ts1}_udebs.db") {
    my ($x_ref, $y_ref) = get_sources "${ts1}_Sources.gz", 'udebs';
    my @a = @{$x_ref};
    store \@a, "${ts1}_udebs.db";
}
# XXX: storing sources only once
if (! -f "${ts2}_udebs.db") {
    my ($x_ref, $y_ref) = get_sources "${ts2}_Sources.gz", 'udebs';
    my @b = @{$x_ref};
    my %sources = %{$y_ref};
    store \@b, "${ts2}_udebs.db";
    store \%sources, "sources.db";
}

mkdir $workdir;

### Compatibility layer

my %versions;
my @a = @{ retrieve "${ts1}_udebs.db" };
my @b = @{ retrieve "${ts2}_udebs.db" };
my %sources = %{ retrieve "sources.db" };

foreach my $pkg (@a) {
    my ($source, $version) = $pkg =~ m{(.+)/(.+)};
    print "(a) found $source :: $version\n";
    $versions{$source}{old} = $version;
    $sources{$source}{min} = $version;
}
foreach my $pkg (@b) {
    my ($source, $version) = $pkg =~ m{(.+)/(.+)};
    print "(b) found $source :: $version\n";
    $versions{$source}{new} = $version;
    $sources{$source}{max} = $version;
}

print "Versions:\n", Dumper(\%versions);
print "Sources:\n", Dumper(\%sources);



### Start of the old script

# Diff old/new to build updated/removed/added lists:
my $vtb = Text::TabularDisplay->new('Updated package', 'Old version', 'New version');
my (@added, @removed);
my @modified;
foreach my $package (sort keys %versions) {
  if ($versions{$package}{'old'} &&
      $versions{$package}{'new'} &&
      $versions{$package}{'old'} ne $versions{$package}{'new'}) {
    $vtb->add( $package, $versions{$package}{'old'}, $versions{$package}{'new'} );
    push @modified, [$package, $versions{$package}{'old'}, $versions{$package}{'new'}];
  }
  if ($versions{$package}{'old'} &&
      not $versions{$package}{'new'}) {
    push @removed, $package;
  }
  if ($versions{$package}{'new'} &&
      not $versions{$package}{'old'}) {
    push @added, $package;
  }
}

=head

# Try and detect renamed packages, based on a linux ABI bump:
if ($old_linux_abi and $new_linux_abi) {
    # @renamed isn't actually used later, but keeping it around
    # doesn't hurt. Can be useful for later debugging.
    my @renamed;
    my @maybe_renamed = @removed;
    foreach my $p (@maybe_renamed) {
        if ($p =~ /-${old_linux_abi}-/) {
            my $rp = $p;
            $rp =~ s/-${old_linux_abi}-/-${new_linux_abi}-/;
            if (grep { $_ eq $rp } @added) {
                @removed = grep { $_ ne $p } @removed;
                @added = grep { $_ ne $rp } @added;
                push @renamed, "$p → $rp (linux)";
            }
        }
    }

    # Additionally, if archs for the maintainer uploads were
    # different, massage a bit more:
    if ($old_linux_arch and $new_linux_arch) {
        @removed = grep { $_ !~ /-${old_linux_abi}-${old_linux_arch}-/ } @removed;
        @removed = grep { $_ !~ /-${old_linux_abi}-${new_linux_arch}-/ } @removed;
        @added   = grep { $_ !~ /-${new_linux_abi}-${new_linux_arch}-/ } @added;
        @added   = grep { $_ !~ /-${new_linux_abi}-${old_linux_arch}-/ } @added;
    }
}

=cut


### Display modified, then removed, then added packages:
print $report $vtb->render, "\n\n";

my $removed_tb = Text::TabularDisplay->new("Removed package", "Version");
foreach my $p (@removed) {$removed_tb->add($p, $versions{$p}{old});}
print $report $removed_tb->render, "\n\n";

my $added_tb = Text::TabularDisplay->new("Added package", "Version");
foreach my $p (@added) {$added_tb->add($p, $versions{$p}{new});}
print $report $added_tb->render, "\n\n";


my $old = $ts1;
my $new = $ts2;

### Grab needed changelogs from packages.qa.d.o:
open my $changelogs, '>', $changelogs_filename
    or die "Unable to write to $changelogs_filename";

my $header = << "EOF";
<!DOCTYPE html
        PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
         "http://www.w3.org/TR/html4/loose.dtd">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<h1>Changelogs which might be relevant between $old and $new</h1>

<table border="1" style="border-collapse: collapse; border: 1px solid;">
<tr>
<th>Source package</th>
<th>Binary packages</th>
<th>Old version</th>
<th>New version</th>
</tr>
EOF
print $changelogs $header;

my $ua = LWP::UserAgent->new();
foreach my $source (sort keys %sources) {
    next if $source eq 'kfreebsd-10';

  print Dumper($sources{$source});

  if (not exists $sources{$source}{max}) {
    print "$source vanished\n";
    next;
  }

  if ($sources{$source}{min} eq $sources{$source}{max}) {
      print "$source didn't change, skipping\n";
      next;
  }

  my $name = $source ne '__error__' ? "<a href=\"#$source\">$source</a>" : "No source/changelog match";

  my $binaries = join(", ", @{$sources{$source}{binaries}});
  my $entry = << "EOF";
  <tr>
  <td style="white-space: nowrap">$name</td>
  <td>$binaries</td>
  <td>$sources{$source}{min}</td>
  <td>$sources{$source}{max}</td>
  </tr>
EOF
  print $changelogs $entry;

  # Skip error'd packages:
  next if $source eq '__error__';

  my $source_filename = "$workdir/$source.txt";
  if (not -f $source_filename) {
    # FIXME: This is assuming everything comes from main:
    my $location;
    if ($source =~ /^lib/) {
      $location = substr($source, 0, 4) . "/" . $source;
    }
    else {
      $location = substr($source, 0, 1) . "/" . $source;
    }
    # Strip the epoch:
    my $version = $sources{$source}{max};
    $version =~ s/^\d+://;
    # The 'current' symlink seems to point to the highest version
    # available, meaning experimental in a bunch of cases, so use the
    # 'max' version for each package:
    my $url = "http://metadata.ftp-master.debian.org/changelogs/main/$location/unstable_changelog";
    my $response = $ua->get($url);
    if ($response->is_success) {
      print STDERR "DEBUG: downloaded changelog: $source ($url)\n";
      open my $file, '>', $source_filename
          or die "Unable to open $source_filename";
      print $file $response->content;
      close $file
        or die "Unable to close $source_filename";
    }
    elsif ($mirror) {
      # FIXME: This is very ugly, but wheezy rc2 has been lagging
      # behind for a while already, so let's tolerate that for now.
      print STDERR "DEBUG: falling back to downloading source package to extract changelog\n";
      my $dsc = "$mirror/pool/main/$location/${source}_${version}.dsc";
      `dget -x $dsc`;
      `cp $source-*/debian/changelog $source_filename`;
      `rm -rf $source-*`;
      if (! -f $source_filename) {
        die "missing changelog after dget workaround: ${source}_${version} ($url -- $$dsc)";
      }
    }
    else {
      # FIXME: Would a fallback to the 'current' symlink help? One is
      # supposed to prepare the announce right after a build, so the
      # proper versions should be available, right?
      print STDERR "DEBUG: unable to download changelog: ${source}_${version}\n";
      print STDERR "DEBUG: try fetching the source package and copying its Debian changelog as $workdir/${source}_${version}\n";
      die "missing changelog: ${source}_${version} ($url)";
    }
  }
}

print $changelogs "</table>\n";


### Extract template:
my $template_filename = "$workdir/default.tmpl";
if (! -f $template_filename) {
    open my $template, '>', $template_filename
        or die "Unable to write to $template_filename";
    print $template $_ while (<DATA>);
    close $template
        or die "Unable to close $template_filename";
    close DATA
        or die "Unable to close DATA";
}


### Detect wanted changelogs excerpts:
foreach my $source (sort keys %sources) {
  # Skip error'd packages:
  next if $source eq '__error__';
  next if $source eq 'kfreebsd-10';

  if (not exists $sources{$source}{max}) {
      print "$source vanished\n";
      next;
  }
  if ($sources{$source}{min} eq $sources{$source}{max}) {
      print "$source didn't change, skipping\n";
      next;
  }

  my $source_filename = "$workdir/$source.txt";
  my $chglog = Parse::DebianChangelog->init( { infile => $source_filename } );
  # "since foo to bar" means "foo is excluded, bar is included":
  my $changes = $chglog->html_str( { since => $sources{$source}{min},
                                     to    => $sources{$source}{max},
                                     template => $template_filename,
                                   });
  # There are various reasons for having no entries: binaries moving
  # between source packages; uploads to experimental getting in the
  # way and shadowing unstable's changelogs; maybe others. Warn in
  # those cases.
  my @data = $chglog->data( { since => $sources{$source}{min},
                              to    => $sources{$source}{max}
                            });
  if (@data) {
    print $changelogs ("<hr>\n" . $changes . "\n");
  }
  else {
    print $changelogs ("<hr>\n" . "<b>warning:</b> no changelog available for $source (from $sources{$source}{min} to $sources{$source}{max})". "\n");
  }

}

print $changelogs "</html>\n";

close $changelogs
    or die "Unable to close $changelogs_filename";

close $report
    or die "Unable to close $report_filename";

print STDERR "Report saved as: $report_filename\n";
print STDERR "Changelogs saved as: $changelogs_filename\n";

### Explicit end:
exit 0;

# Populating the working directory with some template is needed, so
# let's ship it in the DATA section:
__END__
<!-- BEGIN: header.tmpl -->
<h1 class="document_header">
<a name=<TMPL_VAR NAME="SOURCE_NEWEST">>
  Debian Changelog for <TMPL_VAR NAME="SOURCE_NEWEST"> (up to <TMPL_VAR NAME="VERSION_NEWEST">)
</a>
</h1>
<ul class="navbar">
  <li>
    <a href="http://packages.debian.org/src:<TMPL_VAR NAME="SOURCE_NEWEST">">Package Information</a>
  </li>
  <li>
    <a href="http://tracker.debian.org/pkg/<TMPL_VAR NAME="SOURCE_NEWEST">">Package Developer Information</a>
  </li>
  <li>
    <a href="http://bugs.debian.org/src:<TMPL_VAR NAME="SOURCE_NEWEST">">Bug Information</a>
  </li>
</ul>
<!-- END: header.tmpl -->
<!-- BEGIN: content.tmpl -->
<div id="content">
<TMPL_LOOP NAME="CONTENT_YEARS">
<h2 class="year_header" id="year<TMPL_VAR NAME="CONTENT_YEAR">">
<TMPL_VAR NAME="CONTENT_YEAR">
</h2>
<TMPL_LOOP NAME="CONTENT_VERSIONS">
<h3 class="entry_header" id="<TMPL_VAR NAME="CONTENT_VERSION_ID">">
  <a class="packagelink" href="http://packages.debian.org/src:<TMPL_VAR ESCAPE="URL" NAME="CONTENT_SOURCE">"><TMPL_VAR NAME="CONTENT_SOURCE"></a>
   (<TMPL_VAR NAME="CONTENT_VERSION">)
  <span class="<TMPL_VAR NAME="CONTENT_DISTRIBUTION_NORM">"><TMPL_VAR NAME="CONTENT_DISTRIBUTION"></span>;
  urgency=<span class="<TMPL_VAR NAME="CONTENT_URGENCY_NORM">"><TMPL_VAR NAME="CONTENT_URGENCY"></span>
</h3>
<!-- NOTE: CONTENT_CHANGES can contain HTML -->
<pre><TMPL_VAR NAME="CONTENT_CHANGES"></pre>
<p class="trailer">&nbsp;-- <TMPL_VAR NAME="CONTENT_MAINTAINER_NAME"> &lt;<a href="http://qa.debian.org/developer.php?login=<TMPL_VAR NAME="CONTENT_MAINTAINER_EMAIL">"><TMPL_VAR NAME="CONTENT_MAINTAINER_EMAIL"></a>&gt;&nbsp;&nbsp;<TMPL_VAR NAME="CONTENT_DATE">
</p>
<!-- NOTE: CONTENT_PARSE_ERROR can contain HTML -->
<TMPL_VAR NAME="CONTENT_PARSE_ERROR">
</TMPL_LOOP>
</TMPL_LOOP>
</div>
<!-- END: content.tmpl -->
