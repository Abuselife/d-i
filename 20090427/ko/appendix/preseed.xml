<!-- Start of file appendix/preseed.xml -->
<!-- $Id: preseed.xml 58146 2009-04-05 23:13:35Z fjp $ -->

<!--
Be careful with the format of this file as it is parsed to generate
the example preconfiguration file.
In that file all text between <informalexample
> tags that have the
attribute 'role="example"' set is included, except if a 'condition'
attribute is in force that does not match the specified release or if an
'arch' attribute is in force that does not match the specified architecture.

Currently only a single variant of the example file is generated (for i386).
-->

<appendix id="appendix-preseed">
<title
>미리 설정을 이용한 설치 자동화</title>

<para
>이 부록에서는 &d-i;의 질문에 대한 대답을 미리 설정해서 설치를 자동화하는 방법을 설명합니다. </para
><para
>이 부록에서 사용한 설정은 &urlset-example-preseed;에 들어 있는 예제 파일에서도 구할 수 있습니다. </para>

 <sect1 id="preseed-intro">
 <title
>소개</title>
<para
>미리 설정을 하면 설치 프로그램이 실행하는 동안 나오는 질문에 대한 답을 수동으로 입력할 필요없이 미리 설정해 놓을 수 있습니다. 이렇게 하면 대부분 경우의 설치를 완전히 자동화할 수 있고, 보통 설치할 때는 쓸 수 없는 기능을 사용할 수도 있습니다. </para
><para
>미리 설정은 꼭 필요하진 않습니다. 미리 설정 파일을 비워 놓으면, 설치 프로그램은 일반 수동 설치와 똑같은 방식으로 동작합니다. 질문을 미리 설정해 놓으면 그 기준에 따라 설치가 다르게 동작합니다. </para>

  <sect2 id="preseed-methods">
  <title
>미리 설정 방법</title>
<para
>미리 설정에 사용할 수 있는 세 가지 방법이 있습니다: <firstterm
>initrd</firstterm
>, <firstterm
>파일</firstterm
> 그리고 <firstterm
>네트워크</firstterm
>입니다. initrd 미리 설정은 어떤 설치 방법과 사용해도 동작하고 더 많은 부분을 미리 설정할 수 있지만, 가장 많이 준비해야 합니다. </para
><para
>다음은 어떤 미리 설정을 어떤 설치 방법에서 사용할 수 있는 지 나타낸 표입니다. <informaltable
> <tgroup cols="4">
<thead>
<row>
  <entry
>설치 방법</entry
><entry
>initrd</entry>
  <entry
>file</entry
><entry
>network</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>CD/DVD</entry>
  <entry
>예</entry>
  <entry
>예</entry>
  <entry
>예<footnote id='apx-ps-net'
> <para
>하지만 네트워크에 연결된 경우에만 그렇게 하고, <literal
>preseed/url</literal
>을 적절히 설정합니다 </para>

  </footnote
></entry>
</row
><row>
  <entry
>netboot</entry>
  <entry
>예</entry>
  <entry
>아니오</entry>
  <entry
>예</entry>
</row
><row>
  <entry
>hd-media <phrase condition="bootable-usb"
>(usb-stick 포함)</phrase
></entry>
  <entry
>예</entry>
  <entry
>예</entry>
  <entry
>예<footnoteref linkend='apx-ps-net'/></entry>
</row
><row condition="supports-floppy-boot">
  <entry
>플로피 기반 (cd-drivers)</entry>
  <entry
>예</entry>
  <entry
>예</entry>
  <entry
>예<footnoteref linkend='apx-ps-net'/></entry>
</row
><row condition="supports-floppy-boot">
  <entry
>플로피 기반 (net-drivers)</entry>
  <entry
>예</entry>
  <entry
>아니오</entry>
  <entry
>예</entry>
</row
><row arch="s390">
  <entry
>generic/tape</entry>
  <entry
>예</entry>
  <entry
>아니오</entry>
  <entry
>예</entry>
</row>
</tbody>

</tgroup
></informaltable>

</para
><para
>미리 설정 방법 여러 가지 사이의 중요한 차이점은, 바로 미리 설정 파일을 읽어들이고 처리할 시점입니다. initrd 미리 설정의 경우 이 시점은 설치를 시작하는 시점으로, 맨 처음으로 질문하기도 전의 시점입니다. 파일 미리 설정의 경우 CD 혹은 CD 이미지를 읽어들인 다음입니다. 네트워크 미리 설정의 경우 네트워크를 설정한 다음입니다. </para
><para
>당연히 미리 설정 파일을 읽어들이기도 전에 처리하는 질문은 미리 설정할 수 없습니다. (여기에는 중간 혹은 낮은 우선순위에서만 표시되는 질문까지 포함합니다. 예를 들어 첫번째 하드웨어 검색이 그렇습니다.) <xref linkend="preseed-bootparms"/> 부분을 읽어보면 이 질문을 피하는 방법을 알 수 있습니다. </para
><para
>미리 설정 기능이 시작하기 전에 나타나는 질문을 피하려면, 설치 프로그램을 <quote
>자동</quote
> 모드로 시작하면 됩니다. 이렇게 하면 미리 설정하기 전에 물어보는 질문을 네트워크 연결한 다음으로 늦춰서 미리 설정이 가능합니다. 자동 모드에서는 설치를 필수 우선순위로 진행해서 중요하지 않은 많은 질문을 건너 뜁니다. 자세한 정보는 <xref linkend="preseed-auto"/> 부분을 참고하십시오. </para>
  </sect2>

  <sect2 id="preseed-limitations">
  <title
>한계</title>
<para
>&d-i;에서 사용하는 대부분의 질문을 이 방법으로 미리 설정할 수 있지만, 몇 가지 알아둬야 할 예외가 있습니다. 전체 디스크를 다시 파티션하거나, 디스크의 빈 공간을 사용해야 합니다. 기존의 파티션을 이용할 수 없습니다. </para>
  </sect2>

<!-- Joeyh feels this is too technical, so leave it out for now
  <sect2 id="preseed-debconf">
  <title
>Debconf basics</title>
<para>

Preseeding makes use of the <classname
>debconf</classname
> framework. This
framework is the preferred mechanism used in Debian to interact with the user
when configuring packages and also forms the heart of &d-i;.
In the <classname
>debconf</classname
> framework questions or dialogs are
based on <firstterm
>templates</firstterm
>. There are different types of
templates for different types of questions. The actual questions are
<quote
>generated</quote
> from templates at runtime;  multiple questions can
use the same template.

</para
><para>

The following types of templates are relevant for preseeding.

</para>

<itemizedlist spacing="compact">
<listitem
><para>
  string: allows the user to type any value
</para
></listitem>
<listitem
><para>
  password: similar to string but the value typed is not displayed
</para
></listitem>
<listitem
><para>
  boolean: for yes/no or true/false type of questions
</para
></listitem>
<listitem
><para>
  select: allows the user to select one option from a list
</para
></listitem>
<listitem
><para>
  multiselect: allows the user to select zero, one or more options from a list
</para
></listitem>
<listitem
><para>
  note: used to display a message
</para
></listitem>
</itemizedlist>

<para>

In &d-i; templates are stored in a readable file
<filename
>/var/cache/debconf/templates.dat</filename
>. This file contains all fixed
text and all translations. It can also contain a default value for the
template. The fixed text can include variables that will be replaced at
runtime.

</para
><para>

Another readable file <filename
>/var/cache/debconf/questions.dat</filename>
is used to store the values for variables and the answers given to questions.
A question always refers to the template used to ask it. For obvious
security reasons the values for questions of type <quote
>password</quote>
are stored in a separate, non-readable file in the same directory.

</para>
  </sect2>
-->
 </sect1>


 <sect1 id="preseed-using">
 <title
>미리 설정 사용하기</title>
<para
>먼저 미리 설정 파일을 만들고, 그 파일을 사용하려는 위치에 놓아야 합니다. 미리 설정 파일 만들기는 이 부록의 뒤부분에서 설명합니다. 네트워크 미리 설정이나 플로피 혹은 USB 메모리에서 파일을 읽어들이는 경우, 미리 설정 파일의 위치는 아주 뻔합니다. CD나 DVD에 파일을 포함하려면 ISO 이미지를 다시 만들어야 합니다. 미리 설정 파일을 initrd에 포함하는 일은 이 문서의 범위를 벗어납니다. &d-i; 개발자 문서를 참고하십시오. </para
><para
>미리 설정 파일을 만들 때 기초로 사용할 수 있는 예제 파일이 &urlset-example-preseed;에 있습니다. 이 파일은 이 부록에 포함된 설정을 이용해서 만들었습니다. </para>

  <sect2 id="preseed-loading">
  <title
>미리 설정 파일 읽어들이기</title>
<para
>initrd 미리 설정을 사용하려면, <filename
>preseed.cfg</filename
> 파일을 initrd의 루트 디렉토리에 놓기만 하면 됩니다.  자동으로설치 프로그램이 이 파일이 있는 지 검사한 다음 읽어들입니다. </para
><para
>그 밖의 미리 설정 방법의 경우 부팅할 때 어떤 파일을 읽어들일 지 설치 프로그램에  지정해야 합니다. 커널에 부팅 파라미터를 전달하면 됩니다. 부팅할 때 수동으로 넣거나 부트로더 설정 파일을 (예를 들어 <filename
>syslinux.cfg</filename
>) 편집해서 커널의 append 줄의 끝에 파라미터를 추가하면 됩니다. </para
><para
>부트로더 설정에서 미리 설정 파일을 지정하는 경우, 설정을 바꾸면 부팅할 때 Enter를 누를 필요도 없게 할 수 있습니다. syslinux의 경우 <filename
>syslinux.cfg</filename
> 파일에서 timeout을 <literal
>1</literal
>로 하면 됩니다. </para
><para
>설치 프로그램이 올바른 미리 설정 파일을 읽어들이도록, 파일의 체크섬을 지정할 수도 있습니다. 현재는 md5sum만 사용 가능하고, 미리 설정 파일을 읽어들였을 때 지정한 md5sum과 체크섬이 맞지 않으면 그 파일을 사용하지 않습니다. </para>

<informalexample
><screen
>지정해야 하는 부팅 파라미터:
- 네트워크 부팅의 경우:
  preseed/url=http://호스트/파일에/대한/경로/preseed.cfg
  preseed/url/checksum=5da499872becccfeda2c4872f9171c3d

- 이미지를 다시 만든 CD로 부팅하는 경우:
  preseed/file=/cdrom/preseed.cfg
  preseed/file/checksum=5da499872becccfeda2c4872f9171c3d

- USB 미디어에서 설치하는 경우 (미리 설정 파일을 USB 메모리의 맨 위
  디렉토리에 넣으십시오)
  preseed/file=/hd-media/preseed.cfg
  preseed/file/checksum=5da499872becccfeda2c4872f9171c3d
</screen
></informalexample>

<para
><filename
>preseed/url</filename
>은 간단히 <filename
>url</filename
>로 줄여 쓸 수 있고 <filename
>preseed/file</filename
>은 <filename
>file</filename
>로 줄여서 부팅 파라미터로 쓸 수 있습니다. </para>
  </sect2>
  
  <sect2 id="preseed-bootparms">
  <title
>부팅 파라미터로 미리 설정하기</title>
<para
>일부 단계에서는 미리 설정 파일을 사용할 수 없는 경우에도, 설치를 완전히 자동화할 수 있습니다. 설치 프로그램이 부팅할 때 미리 설정할 값을 하나하나 파라미터로 넘길 수 있습니다. </para
><para
>미리 설정 기능을 사용하려는 게 아니더라도, 특정 질문에 대한 답을 지정하고 싶으면 부팅 파라미터를 이용할 수 있습니다. 이 안내서의 다른 곳에 부팅 파라미터가 유용한 예제가 몇 가지 있습니다. </para
><para
>&d-i;에서 사용할 값을 설정하려면, 이 부록의 예제에 들어 있는 미리 설정 변수에 대해 <userinput
><replaceable
>변수에/대한/경로</replaceable
>=<replaceable
>값</replaceable
></userinput
> 형식으로 넘깁니다. 설치할 시스템의 패키지를 설정하는 데 어떤 값을 사용한다면, 그 변수의 <firstterm
>소유자</firstterm
><footnote
> <para
> 어떤 debconf 변수(혹은 템플리트)의 소유자는 보통 그 debconf 템플리트가 들어 있는 패키지의 이름을 말합니다. 템플리트와 변수는 소유자가 여러 개일 수도 있습니다. 그래서 패키지의 설정까지 지워버릴 때 소유자 정보를 이용해 해당 템플리트와 변수까지 지워질지 여부가 결정됩니다. </para
> </footnote
>를 <userinput
><replaceable
>소유자</replaceable
>:<replaceable
>변수에/대한/경로</replaceable
>=<replaceable
>값</replaceable
></userinput
> 형식으로 씁니다. 소유자를 지정하지 않으면 해당 변수의 값은 설치한 시스템의 debconf 데이터베이스에는 들어가지 않으므로 해당 패키지의 설정에 사용하지 않게 됩니다. </para
><para
>이런 식으로 질문을 미리 설정하면, 그 질문을 하지 않습니다. 질문에 대해 특정 기본값을 지정하면서, 질문을 하게 만들고 싶으면, 연산자에 <quote
>=</quote
>이 아니라 <quote
>?=</quote
>라고 쓰십시오. <xref linkend="preseed-seenflag"/> 부분도 참고하십시오. </para
><para
>부팅 파라미터에서 자주 사용하는 변수 몇개는 짧게 쓸 수 있습니다. 이 부록에 있는 예제에서는 그렇게 짧은 형식이 있으면 완전한 변수명을 쓰지 않고 짧은 형식을 사용합니다. 예를 들어 <literal
>preseed/url</literal
> 변수는 예제에서 <literal
>url</literal
>로 씁니다. 또 예제에서 <literal
>tasks</literal
>라고 쓰면 <literal
>tasksel:tasksel/first</literal
>에 해당합니다. </para
><para
>부팅 옵션의 <quote
>--</quote
>는 특별한 의미가 있습니다. 마지막 <quote
>--</quote
> 뒤에 오는 커널 파라미터는 설치한 시스템의 부트로더 설정으로 복사되어 들어갑니다. (설치 프로그램에서 설치하는 부트로더가 지원하는 경우.) 설치 프로그램은 (미리 설정 옵션과 마찬가지로) 설치 프로그램에서 인식하는 옵션만 모두 걸러냅니다. </para>
<note
><para
>현재 리눅스 커널은 (2.6.9 이후) 최대 32개까지의 명령행 파라미터와 32개까지의 환경 파라미터만 쓸 수 있습니다. (설치 프로그램에서 기본으로 추가하는 파라미터 포함해서 32개입니다.) 이보다 많으면 커널이 멎어 버립니다. (이보다 오래된 버전의 커널에서는 파라미터 개수 제한이 이보다 더 작습니다.) </para
></note>
<para
>대부분 설치할 때 (<literal
>vga=normal</literal
>같은) 기본 옵션 중에 안 써도 되는 옵션이 있습니다. 그러면 미리 설정 옵션을 몇 개 더 쓸 수 있습니다. </para>
<note
><para
>부팅 파라미터에서는 공백이 들어간 값을 지정할 수 없습니다. 따옴표로 묶어도 할 수 없습니다. </para
></note>
  </sect2>
  
  <sect2 id="preseed-auto">
  <title
>자동 모드</title>
<para
>데비안 설치 프로그램의 기능을 이용하면 부팅 프롬프트에서 간단한 명령행으로 임의의 복잡한 자동 설치를 입맛에 맞게 할 수 있습니다. 부팅 프롬프트에서 사용할 수 있는 예제로 이 기능을 설명합니다. <informalexample
><screen>
auto url=autoserver
</screen
></informalexample
> 이렇게 하면 DHCP 서버가 있다고 가정하고 DHCP 서버에서 <literal
>autoserver</literal
>의 IP 주소를 받아옵니다. DHCP가 보내주는 로컬 도메인을 뒤에 붙일 수도 있습니다. 도메인이 <literal
>example.com</literal
>인 사이트에서 위와 같이 하고 DHCP 설정이 올바르다면, 미리 설정 파일을 <literal
>http://autoserver.example.com/d-i/&releasename;/./preseed.cfg</literal
> 위치에서 가져 옵니다. </para
><para
>URL의 뒤쪽 부분은 (<literal
>d-i/&releasename;/./preseed.cfg</literal
>) <literal
>auto-install/defaultroot</literal
>에서 가져옵니다. 기본값으로 여기에는 <literal
>&releasename;</literal
> 디렉토리가 들어 있습니다. 다음 버전에서는 그 버전에 해당되는 코드네임을 이 값으로 사용할 예정이고, 그러면 사람들이 정해진 방법을 통해 다음 버전으로 업그레이드할 수 있습니다. <literal
>/./</literal
> 부분은 맨 위 디렉토리를 가리키는 것으로, 지정한 해당 경로에 (preseed/include 및 preseed/run에서 사용) 대한 상대값입니다. 이를 이용해 파일을 완전한 URL로 지정할 수도 있고, /로 시작하는 경로로 지정할 수도 있고, 마지막 미리 지정 파일이 있던 위치에 대한 상대 경로로 지정할 수도 있습니다. 이 점을 이용하면 전체 스크립트를 완전히 새로운 위치에 옮겨도 문제가 없는 포터블한 스크립트를 구성할 수 있습니다. 예를 들어 웹서버에 있던 파일을 USB 메모리에 옮겨도 문제가 없게 됩니다. 이 예제의 미리 지정 파일에서는 <literal
>preseed/run</literal
> 값을 <literal
>/scripts/late_command.sh</literal
>라고 지정하면 <literal
>http://autoserver.example.com/d-i/&releasename;/./scripts/late_command.sh</literal
>에서 파일을 가져옵니다. </para
><para
>로컬 네트워크에 DHCP 혹은 DNS 서버 따위가 없거나 <filename
>preseed.cfg</filename
>에 대한 기본값 경로를 바꾸고 싶으면, URL을 직접 사용할 수도 있습니다. <literal
>/./</literal
> 부분을 사용하지 않으면 경로의 첫 부분에 대한 (즉 URL에서 세번째 <literal
>/</literal
>) 경로가 됩니다. 다음은 로컬 네트워크에서 최소한의 지원이 있어야 동작하는 예제입니다: <informalexample
><screen>
auto url=<replaceable
>http://192.168.1.2/파일에/대한/경로/mypreseed.file</replaceable>
</screen
></informalexample
> 위와 같이 하면 다음과 같이 동작합니다: <itemizedlist spacing="compact">
<listitem
><para
>URL의 프로토콜 부분을 생략하면 http라고 가정합니다. </para
></listitem>
<listitem
><para
>호스트 이름에 점이 없으면, DHCP에서 넘겨준 도메인을 뒤에 붙입니다. </para
></listitem>
<listitem
><para
>호스트 이름 뒤에 <literal
>/</literal
>가 없으면 기본 경로를 뒤에 붙입니다. </para
></listitem>
</itemizedlist>

</para
><para
>URL을 지정하는 것 외에, &d-i;의 동작과 직접 관계없지만 미리 설정 파일의 <literal
>preseed/run</literal
>에서 지정한 스크립트로 넘길 사항을 지정할 수도 있습니다. 현재 관련 예제는 <literal
>auto-install/classes</literal
>로 <literal
>classes</literal
>라고 줄여 쓸 수 있습니다. 다음과 같이 사용합니다: <informalexample
><screen>
auto url=<replaceable
>example.com</replaceable
> classes=<replaceable
>클래스_A;클래스_B</replaceable>
</screen
></informalexample
> 클래스는 설치하려는 시스템의 종류를 지정하거나, 지역화를 지정합니다. </para
><para
>이 개념을 확장할 수도 있고, 확장하는 경우 auto-install 네임스페이스를 사용하는 게 보기 좋습니다. 즉 <literal
>auto-install/style</literal
>과 같이 스크립트에서 사용할 수 있습니다. 이렇게 해야 겠다고 생각이 들면, <email
>debian-boot@lists.debian.org</email
> 메일링 리스트에 알려 주십시오. 그래야 네임스페이스 충돌을 피하고, 여러분의 파라미터에 해당하는 줄임말을 추가할 수도 있을 것입니다. </para
><para
><literal
>auto</literal
> 부팅 레이블은 아직 정의하지 않은 아키텍처가 있습니다. 커널 명령행에 파라미터 두 개, <literal
>auto=true priority=critical</literal
>이라고 추가하기만 하면 같은 효과를 거둘 수 있습니다. <literal
>auto</literal
> 파라미터는 <literal
>auto-install/enable</literal
>의 줄임말이고 미리 설정할 수 있도록 로캘 및 키보드 질문을 뒤로 늦춥니다. 또 <literal
>priority</literal
>는 <literal
>debconf/priority</literal
>의 줄임말이고 <literal
>critical</literal
>로 설정하면 필수 우선순위보다 낮은 우선순위의 질문을 하지 않게 됩니다. </para
><para
>그 외에 DHCP를 사용할 때 설치를 자동화하면서 관심 가질만한 옵션은 다음과 같습니다: <literal
>interface=auto netcfg/dhcp_timeout=60</literal
>이라고 하면 처음 찾은 네트워크 인터페이스를 이용하고 DHCP 요청에 대한 응답을 좀 더 오래 기다립니다. </para>
<tip
><para
>예제 스크립트와 클래스 등, 이 프레임워크를 사용하는 다양한 예제가 <ulink url="http://hands.com/d-i/"
>개발자의 웹사이트</ulink
>에 있습니다. 이 사이트에 있는 예제는 미리 설정을 통해 기발하고 다양한 멋진 기능을 수행하는 예제도 있습니다. </para
></tip>
  </sect2>

  <sect2 id="preseed-aliases">
  <title
>미리 설정할 때 쓸모 있는 줄임말</title>
<para
>(자동 모드) 미리 설정을 사용할 경우 다음 줄임말이 쓸모가 많습니다. </para>

<!-- Setting column width does not seem to work; use non-breaking spaces
     to separate columns a bit -->
<informaltable frame="none">
<tgroup cols="2"
><tbody>
<row
><entry
>auto</entry
><entry
>auto-install/enable</entry
></row>
<row
><entry
>classes</entry
><entry
>auto-install/classes</entry
></row>
<row
><entry
>fb</entry
><entry
>debian-installer/framebuffer</entry
></row>
<row
><entry
>locale</entry
><entry
>debian-installer/locale</entry
></row>
<row
><entry
>priority</entry
><entry
>debconf/priority</entry
></row>
<row
><entry
>file</entry
><entry
>preseed/file</entry
></row>
<row
><entry
>url</entry
><entry
>preseed/url</entry
></row>
<row
><entry
>interface</entry
><entry
>netcfg/choose_interface</entry
></row>
<row
><entry
>hostname&nbsp;&nbsp;&nbsp;</entry
><entry
>netcfg/get_hostname</entry
></row>
<row
><entry
>domain</entry
><entry
>netcfg/get_domain</entry
></row>
<row
><entry
>protocol</entry
><entry
>mirror/protocol</entry
></row>
<row
><entry
>suite</entry
><entry
>mirror/suite</entry
></row>
</tbody
></tgroup>
</informaltable>

  </sect2>
  
  <sect2 id="preseed-dhcp">
  <title
>미리 설정 파일을 지정하는 데 DHCP 서버 사용하기</title>
<para
>DHCP를 이용해 설정사항을 미리 기록한 파일을 네트워크에서 다운로드하게 만들 수 있습니다. DHCP에서 파일 이름을 지정할 있습니다. 이 파일은 대부분 네트워크 부팅을 하는 파일이지만, URL인 경우 네트워크 미리 설정을 지원하는 설치 방식에서는 그 URL에서 파일을 다운로드한 다음 설정 파일로 사용합니다. ISC DHCP 버전 3 서버에서 (데비안의 dhcp3-server 패키지) 이 방식을 사용하는 dhcpd.conf 파일은 아래와 같습니다. </para>

<informalexample
><screen
>if substring (option vendor-class-identifier, 0, 3) = "d-i" {
    filename "http://host/preseed.cfg";
}
</screen
></informalexample>

<para
>위의 예에서 자신을 "d-i"라고 주장하는 DHCP 클라이언트에만 이 파일 이름을 전달하므로 일반 DHCP 클라이언트에는 아무런 영향이 없습니다. 특정 호스트에 대해서만 설정하면 네트워크의 모든 시스템을 미리 설정하지 않게 만들 수 있습니다. </para
><para
>DHCP 미리 설정을 하려면 네트워크에 해당하는 값만 미리 설정하는 게 좋습니다. 예를 들어 데비안 미러 사이트를 설정하면 네트워크 안에서 설치하는 시스템에 알맞는 미러를 설정하면서, 나머지 설치는 직접 지정할 수 있습니다. 전체 데비안 설치를 자동으로 하는 DHCP 미리 설정은 주의해서 해야 합니다. </para>
  </sect2>
 </sect1>


 <sect1 id="preseed-creating">
 <title
>미리 설정 파일 만들기</title>
<para
>미리 설정 파일은 <command
>debconf-set-selections</command
> 명령어에서 사용하는 형식으로 되어 있습니다. 미리 설정 파일의 일반적인 형식은 다음과 같습니다: <informalexample
><screen
>&lt;소유자&gt; &lt;질문 이름&gt; &lt;질문 형식&gt; &lt;값&gt;
</screen
></informalexample>

</para
><para
>미리 설정 파일을 작성할 때 지켜야 할 규칙이 있습니다. </para>

<itemizedlist>
<listitem
><para
>형식과 값 사이에 한 개의 공백이나 탭을 넣으십시오. 공백이나 탭을 이보다 많이 쓰면 값에 그 문자가 들어갔다고 취급합니다. </para
></listitem>
<listitem
><para
>백슬래시(<quote
><literal
>\</literal
></quote
>)를 이음 문자로 맨 뒤에 붙여서 한 줄을 여러 줄로 나눌 수 있습니다. 줄을 나눌 때 좋은 부분은 질문 이름 뒤부분입니다. 나쁜 부분은 형식과 값 사이입니다. 나눠진 줄이 한 줄로 합쳐질 때 앞/뒤의 공백 문자들은 모두 공백 하나로 취급됩니다. </para
></listitem>
<listitem
><para
>설치 프로그램에서 사용하는 debconf 변수(템플리트)의 경우, 소유자를 <quote
>d-i</quote
>라고 해야 합니다. 설치한 시스템에서 사용할 변수를 미리 설정하려면, 해당 debconf 템플리트가 들어 있는 패키지의 이름을 사용해야 합니다. 소유자가 <quote
>d-i</quote
>가 아닌 변수만 설치한 시스템의 debconf 데이터베이스에 적용됩니다. </para
></listitem>
<listitem
><para
>보통 질문을 미리 설정할 때 번역한 값이 아니라 영어로 된 올바른 값을 사용해야 합니다. 하지만 일부 질문의 경우 번역한 값을 사용해야 합니다. (예를 들어 <classname
>partman</classname
>에서.) </para
></listitem>
<listitem
><para
>어떤 질문은 눈에 보이는 영문 텍스트가 아니라 코드를 값으로 받습니다. </para
></listitem>
</itemizedlist>

<para
>미리 설정 파일을 만드려면, <xref linkend="preseed-contents"/>에 들어 있는 예제 파일을 기초로 시작하는 방법이 가장 쉽습니다. </para
><para
>다른 방법으로 수동으로 설치하고 다시 부팅한 다음에, <classname
>debconf-utils</classname
> 패키지에서 <command
>debconf-get-selections</command
> 명령으로 debconf 데이터베이스 및 설치 프로그램의 cdebconf 데이터베이스를 한 파일로 만드는 방법이 있습니다: <informalexample
><screen
>$ debconf-get-selections --installer &gt; <replaceable
>파일</replaceable>
$ debconf-get-selections &gt;&gt; <replaceable
>파일</replaceable
>
</screen
></informalexample>

</para
><para
>하지만, 이런 방법으로 만든 파일에는 미리 설정하면 안 되는 항목도 들어 있으므로, 보통 예제 파일에서 시작하는 방법이 더 좋습니다. </para>

<note
><para
>이 방법은 설치가 끝났을 때 설치 프로그램의 cdebconf 데이터베이스가 설치한 시스템의 <filename
>/var/log/installer/cdebconf</filename
>에 들어 있다는 점을 이용한 것입니다. 하지만 이 데이터베이스에는 비밀 정보가 들어 있을 수도 있기 때문에 루트만 이 파일을 읽을 수 있게 되어 있습니다. </para
><para
><classname
>installation-report</classname
> 패키지를 지우면 <filename
>/var/log/installer</filename
> 디렉토리 및 그 안의 모든 파일을 시스템에서 지웁니다. </para
></note>

<para
>각 질문에 대해 올바른 값이 무엇인지 알려면, 설치할 때 <command
>nano</command
>로 <filename
>/var/lib/cdebconf</filename
> 파일의 내용을 보면 됩니다. 원본 템플리트를 보려면 <filename
>templates.dat</filename
> 파일을 보고, 현재 값과 각 변수에 할당된 값을 보려면 <filename
>questions.dat</filename
> 파일을 보면 됩니다. </para
><para
>설치하기 전에 미리 설정 파일의 형식이 올바른 지 확인하려면, <command
>debconf-set-selections -C <replaceable
>preseed.cfg</replaceable
></command
> 명령을 사용할 수 있습니다. </para>
 </sect1>


 <sect1 id="preseed-contents">
 <title
>미리 설정 파일의 내용 (&releasename;용)</title>
<para
>이 부록에서 사용한 설정은 &urlset-example-preseed;에 들어 있는 예제 파일에서도 구할 수 있습니다. </para
><para
>이 예제 파일은 인텔 x86 아키텍처용으로 만들어졌습니다. 다른 아키텍처에서 설치하는 경우, 예제에서 어떤 부분은 (예를 들어 키보드 선택이나 부트로더 설치) 해당 아키텍처에서 필요 없을 수도 있고 해당 아키텍처에 맞는 debconf 값으로 바꿔야 할 수도 있습니다. </para>
 
  <sect2 id="preseed-l10n">
  <title
>지역화</title>
<para
>지역화 설정은 initrd 미리 설정을 하는 경우만 동작합니다. 그 외의 방법을 사용하면 지역화 설정 질문을 한 다음에 미리 설정 파일을 읽어들입니다. </para
><para
>로캘은 언어와 국가를 지정합니다. &d-i;에서 지원하는 언어와 국가라면 뭐든지 붙여서 사용할 수 있습니다. 해당 언어/국가 조합이 올바른 로캘이 아닌 경우 해당 언어에 대한 로캘을 자동으로 하나 선택합니다. 부팅 파라미터로 로캘을 지정하려면, <userinput
>locale=<replaceable
>ko_KR</replaceable
></userinput
>과 같이 사용하십시오. <informalexample role="example"
><screen
># 로캘은 언어와 국가를 설정합니다.
d-i debian-installer/locale string ko_KR
</screen
></informalexample>

</para
><para
>키보드 설정은 키보드 아키텍처와 키맵을 선택하는 일입니다. 대부분 기본값으로 키보드 아키텍처가 올바르게 선택되어 있으므로, 보통 미리 설정할 필요가 없습니다. 선택한 키보드 아키텍처에 대해 &d-i;에 들어 있는 키맵을 지정해야 합니다. <informalexample role="example"
><screen
># 키보드 선택.
#d-i console-tools/archs select at
d-i console-keymaps-at/keymap select us
# 다른 키보드 아키텍처를 사용하는 예제.
#d-i console-keymaps-usb/keymap select mac-usb-us
</screen
></informalexample>

</para
><para
>키보드 설정을 건너뛰려면 <classname
>console-tools/archs</classname
> 값을 <userinput
>skip-config</userinput
>로 하면 됩니다. 그러면 커널 키맵을 사용합니다. </para>

<note
><para
>2.6 커널의 입력 레이어때문에 키보드 아키텍처는 사실상 필요없게 되었습니다. 2.6 커널의 경우 <quote
>PC</quote
> (<userinput
>at</userinput
>) 키맵을 선택해야 합니다. </para
></note>
  </sect2>

  <sect2 id="preseed-network">
  <title
>네트워크 설정</title>
<para
>네트워크에서 미리 설정 파일을 읽어들이는 경우 네트워크 설정은 당연히 동작하지 않습니다. 하지만 CD나 USB 메모리로 부팅하는 경우에 네트워크 설정을 하면 좋을 것입니다. 미리 설정 파일을 네트워크에서 읽어들이는 경우, 커널 부팅 파라미터로 네트워크 설정을 건너 뛸 수 있습니다. </para
><para
>미리 설정 파일을 네트워크에서 읽어들이기 전에 특정 인터페이스에서 네트워크 부팅하려면, <userinput
>interface=<replaceable
>eth1</replaceable
></userinput
>처럼 부팅 파라미터를 사용하십시오. </para
><para
>네트워크를 통해 미리 설정을 하는 경우 (<quote
>preseed/url</quote
> 사용) 네트워크 설정을 미리 설정하는 게 보통 불가능하지만, 다음 방법을 이용해 피해갈 수 있습니다. 예를 들어 네트워크 인터페이스에 고정 주소를 부여하는 방법입니다. 다음 명령이 들어 있는 <quote
>preseed/run</quote
> 스크립트를 만들어서 미리 설정 파일을 읽어들인 후에 네트워크 설정을 다시 실행합니다: <informalexample
><screen
>killall.sh; netcfg
</screen
></informalexample>

</para
><para
>다음 debconf 변수가 네트워크 설정과 관계가 있습니다. </para>

<informalexample role="example"
><screen
># 연결되어 있는 인터페이스를 선택합니다. 이러면 인터페이스가
# 여러 개 있는 경우 목록을 건너 뜁니다.
d-i netcfg/choose_interface select auto

# 특정 인터페이스를 선택할 경우:
#d-i netcfg/choose_interface select eth1

# DHCP 서버가 느려서 응답을 기다리다가 시간이 초과되는 경우
# 다음 설정을 쓰면 됩니다.
#d-i netcfg/dhcp_timeout string 60

# 네트워크 설정을 수동으로 하려면, 아래 줄의 주석을 지우고 그 아래에 있는
# 고정 네트워크 설정의 주석도 지우십시오.
#d-i netcfg/disable_dhcp boolean true

# DHCP 서버가 있든 없든 모두 미리 설정 파일이 동작하게 만드려면, 아래 
# 줄의 주석을 지우고 그 아래에 있는 고정 네트워크 설정의 주석도 지우십시오.
#d-i netcfg/dhcp_failed note
#d-i netcfg/dhcp_options select Configure network manually

# 고정 IP 네트워크 설정
#d-i netcfg/get_nameservers string 192.168.1.1
#d-i netcfg/get_ipaddress string 192.168.1.42
#d-i netcfg/get_netmask string 255.255.255.0
#d-i netcfg/get_gateway string 192.168.1.1
#d-i netcfg/confirm_static boolean true

# DHCP에서 지정한 호스트 이름과 도메인 이름이 여기에서 설정한 것보다
# 우선합니다. 하지만 DHCP에서 호스트 이름과 도메인 이름이 넘어오는
# 경우라고 해도, 여기서 값을 설정해야 질문을 하지 않게 됩니다.
d-i netcfg/get_hostname string unassigned-hostname
d-i netcfg/get_domain string unassigned-domain

# 성가신 WEP 키 대화 상자를 사용하지 않습니다.
d-i netcfg/wireless_wep string
# 일부 DHCP 서버는 호스트이름을 암호처럼 사용합니다.
#d-i netcfg/dhcp_hostname string radish

# 네트워크 등의 하드웨어에 자유롭게 배포되지 않는 펌웨어가 필요한 경우, 물어보지
# 않고 그 펌웨어를 읽어들이도록 설정할 수 있습니다. 아니면 false로 하면
# 물어보지도 않게 할 수 있습니다.
#d-i hw-detect/load_firmware boolean true
</screen
></informalexample>

<para
><classname
>netcfg/get_netmask</classname
>를 미리 지정하지 않으면 <command
>netcfg</command
>는 자동으로 네트마스크를 지정합니다. 자동 설치에서는 이 변수를 <literal
>seen</literal
>으로 표시해야 합니다. 마찬가지로 <classname
>netcfg/get_gateway</classname
>를 지정하지 않으면 <command
>netcfg</command
>는 적당한 주소로 게이트웨이를 설정합니다. 특별한 경우로, <classname
>netcfg/get_gateway</classname
>를 <quote
>none</quote
>으로 설정하면 게이트웨이를 사용하지 않습니다. </para>

  </sect2>

  <sect2 id="preseed-network-console">
  <title
>네트워크 콘솔</title>

<informalexample role="example"
><screen
># SSH을 통해 원격 설치를 하면서 network-console 컴포넌트를 사용할 경우 다음
# 설정을 사용합니다. 이후의 모든 설치를 수동으로 하는 경우에만 이렇게 합니다.
#d-i anna/choose_modules string network-console
#d-i network-console/password password r00tme
#d-i network-console/password-again password r00tme
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-mirror">
  <title
>미러 사이트 설정</title>
<para
>사용하는 설치 방법에 따라서, 미러 사이트를 이용해 설치 프로그램의 추가 컴포넌트, 베이스 시스템을 다운로드할 수 있습니다. 또 설치를 끝낸 시스템에서 <filename
>/etc/apt/sources.list</filename
> 파일을 설정하는 데 미러 사이트를 이용할 수 있습니다. </para
><para
><classname
>mirror/suite</classname
> 파라미터로 설치할 시스템의 세트를 결정합니다. </para
><para
><classname
>mirror/udeb/suite</classname
> 파라미터로 설치 프로그램의 추가 컴포넌트의 세트를 결정합니다. 이 설정은 컴포넌트를 네트워크로 다운로드하면서, initrd를 빌드할 때 사용한 그 세트의 컴포넌트일 경우에만 쓸 수 있습니다. <classname
>mirror/udeb/suite</classname
>의 기본값은 <classname
>mirror/suite</classname
>와 같습니다. </para>

<informalexample role="example"
><screen
># ftp의 경우, mirror/country 문자열은 설정할 필요가 없습니다.
#d-i mirror/protocol string ftp
d-i mirror/country string manual
d-i mirror/http/hostname string &archive-mirror;
d-i mirror/http/directory string /debian
d-i mirror/http/proxy string

# 설치할 세트
#d-i mirror/suite string testing
# 설치 프로그램을 읽어들일 세트 (옵션).
#d-i mirror/udeb/suite string testing
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-time">
  <title
>시계 및 시간대 설정</title>

<informalexample role="example"
><screen
># 하드웨어 시계를 UTC로 할 지 여부를 결정합니다
d-i clock-setup/utc boolean true

# $TZ로 설정 가능한 값은 뭐든지 쓸 수 있습니다. 설정 가능한
# 값은 /usr/share/zoneinfo/ 아래의 내용을 참고하십시오.
d-i time/zone string US/Eastern

# 설치하면서 시계를 맞출 때 NTP를 사용할 지 여부를 설정합니다.
d-i clock-setup/ntp boolean true
# 사용할 NTP 서버. 보통 기본값을 사용하는 게 좋습니다.
#d-i clock-setup/ntp-server string ntp.example.com
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-partman">
  <title
>파티션하기</title>
<para
>하드디스크 파티션에 사용하는 미리 설정은 <classname
>partman-auto</classname
>에서 지원하는 방식만 쓸 수 있습니다. 디스크의 빈 공간을 파티션하거나, 전체 디스크를 파티션하거나 둘 중의 하나를 선택해야 합니다. 디스크의 구성은 미리 정의된 방식에 따라 할 수 있고, 특별히 설정한 방식을 파일로 사용할 수도 있고 미리 설정 파일에 포함할 수도 있습니다. 현재는 미리 설정으로 여러 개의 디스크를 파티션할 수 없습니다. </para>

<warning
><para
>디스크의 ID는 디스크의 드라이버를 읽어들이는 순서에 따라 다릅니다. 시스템에 디스크가 여러 개 있는 경우, 미리 설정을 이용하기 전에 올바른 디스크를 선택하도록 하십시오. </para
></warning>

<informalexample role="example"
><screen
># 시스템에 빈 공간이 있으면 거기에 한 개의 파티션을 만들 수 있습니다.
#d-i partman-auto/init_automatically_partition select biggest_free

# 다른 방법으로, 파티션할 디스크를 지정할 수 있습니다. 장치 이름은
# 전통적인 DEVFS가 아닌 형식으로 지정해야 합니다.
# 주의: 디스크를 지정해야 합니다. 단 디스크가 한 개이면 하지 않아도 됩니다.
# 예를 들어 첫번째 SCSI/SATA 하드디스크를 사용하려면:
#d-i partman-auto/disk string /dev/sda
# 또 어떤 방법을 사용할 지 지정해야 합니다.
# 현재 가능한 방법은: "regular", "lvm", "crypto"입니다.
d-i partman-auto/method string lvm

# 만약 자동으로 파티션하려는 디스크에 예전의 LVM 설정이 남아 있다면,
# 사용자에게 경고 메세지를 보여줍니다. 이 경고도 미리 설정해서
# 없앨 수 있습니다...
d-i partman-lvm/device_remove_lvm boolean true
# 마찬가지로 기존의 소프트웨어 RAID 어레이에도 적용됩니다:
d-i partman-md/device_remove_md boolean true
# 그리고 LVM 파티션을 쓰는 순간에 확인 질문도 미리 설정합니다.
d-i partman-lvm/confirm boolean true

# 미리 정의한 파티션 방식 중의 하나를 선택할 수 있습니다:
# - atomic: 모든 파일을 한 파티션에
# - home:   별도의 /home 파티션
# - multi:  별도의 /home, /usr, /var, /tmp 파티션
d-i partman-auto/choose_recipe select atomic

# 아니면 자신만의 파티션 방식을 만듭니다...
# 파티션 방식 형식은 devel/partman-auto-recipe.txt 파일에 있습니다.
# 파티션 방식 파일을 d-i 환경에 집어 넣을 수 있으면, 그 파일 위치를
# 지정하기만 하면 됩니다.
#d-i partman-auto/expert_recipe_file string /hd-media/recipe

# 그게 아니면, 전체 파티션 방식을 미리 설정 파일에 (논리적인) 한 줄로
# 집어넣을 수 있습니다. 다음 예는 작은 /boot 파티션을 만들고, 적당한
# 스왑 파티션을 만들고, 나머지 공간을 루트 파티션으로 사용합니다.
#d-i partman-auto/expert_recipe string                         \
#      boot-root ::                                            \
#              40 50 100 ext3                                  \
#                      $primary{ } $bootable{ }                \
#                      method{ format } format{ }              \
#                      use_filesystem{ } filesystem{ ext3 }    \
#                      mountpoint{ /boot }                     \
#              .                                               \
#              500 10000 1000000000 ext3                       \
#                      method{ format } format{ }              \
#                      use_filesystem{ } filesystem{ ext3 }    \
#                      mountpoint{ / }                         \
#              .                                               \
#              64 512 300% linux-swap                          \
#                      method{ swap } format{ }                \
#              .

# 다음과 같이 하면 partman에서 확인 질문을 하지 않고 자동으로 파티션합니다.
# 단 위에서 방법 중의 하나를 사용해서 무엇을 할 지 지정한 경우입니다.
d-i partman/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-partman-raid">
  <title
>RAID를 사용해 파티션하기</title>
<para
>소프트웨어 RAID를 설정할 때 미리 설정을 할 수 있습니다. RAID 레벨 0, 1, 5, 6, 10을 지원하고, 비상용 어레이 및 예비 장치를 지정합니다. RAID 1을 사용한다면 GRUB을 미리 설정해서 어레이 안의 모든 장치에 GRUB을 설치할 수 있습니다. <xref linkend="preseed-bootloader"/> 부분을 참고하십시오. </para>

<warning
><para
>이런 방식의 자동 파티션은 잘못되기 쉽습니다. 또 이 기능은 &d-i; 개발자들이 별로 테스트하지 않는 기능입니다.여러가지 방식을 올바르게 (규칙에 맞으면서 충돌하지 않게) 설정하는 책임은 사용자에게 있습니다. 문제가 발생하면 <filename
>/var/log/syslog</filename
> 파일을 확인하십시오. </para
></warning>

<informalexample
><screen
># 주의: 이 옵션은 베타 상태이므로 주의해서 사용해야 합니다

# 파티션 방법은 "raid"로 설정합니다.
#d-i partman-auto/method string raid
# 파티션할 디스크를 지정합니다. 디스크 모두 같은 레이아웃이므로
# 디스크 크기가 동일할 때만 아래 설정이 동작합니다.
#d-i partman-auto/disk string /dev/discs/disc0/disc /dev/discs/disc1/disc

# 그 다음 사용할 물리적 파티션을 지정합니다.
#d-i partman-auto/expert_recipe string \
#      multiraid ::                                         \
#              1000 5000 4000 raid                          \
#                      $primary{ } method{ raid }           \
#              .                                            \
#              64 512 300% raid                             \
#                      method{ raid }                       \
#              .                                            \
#              500 10000 1000000000 raid                    \
#                      method{ raid }                       \
#              .

# 마지막으로 예전에 정의한 파티션을 RAID 설정에서 어떻게 사용할 지
# 지정합니다. 논리 파티션에 대해 올바른 파티션 번호를 사용하도록 하십시오.
# 파라미터는 다음과 같습니다:
# &lt;raidtype&gt; &lt;devcount&gt; &lt;sparecount&gt; &lt;fstype&gt; &lt;mountpoint&gt; \
#          &lt;devices&gt; &lt;sparedevices&gt;
# RAID 레벨 0, 1, 5, 6, 10을 지원합니다. 각 장치는 "#"으로 구분합니다.
#d-i partman-auto-raid/recipe string \
#    1 2 0 ext3 /                                           \
#          /dev/discs/disc0/part1#/dev/discs/disc1/part1    \
#    .                                                      \
#    1 2 0 swap -                                           \
#          /dev/discs/disc0/part5#/dev/discs/disc1/part5    \
#    .                                                      \
#    0 2 0 ext3 /home                                       \
#          /dev/discs/disc0/part6#/dev/discs/disc1/part6    \
#    .

# 다음과 같이 하면 파티션 프로그램에서 확인 질문을 하지 않고 파티션합니다.
d-i partman-md/confirm boolean true
d-i partman/confirm_write_new_label boolean true
d-i partman/choose_partition select finish
d-i partman/confirm boolean true
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-base-installer">
  <title
>기본 시스템  설치</title>
<para
>이 상태에서는 미리 설정할 수 있는 부분이 별로 많지 않습니다. 유일하게 신경 쓸 부분은 커널 설치에 관한 질문입니다. </para>

<informalexample role="example"
><screen
># 2.6 커널의 initrd를 만드는 initramfs를 선택합니다
#d-i base-installer/kernel/linux/initramfs-generators string yaird

# 설치할 커널 이미지 (메타) 패키지입니다. "none"을 사용하면 커널을 설치하지
# 않습니다.
#d-i base-installer/kernel/image string linux-image-2.6-486
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-account">
  <title
>계정 설정</title>
<para
>루트 계정의 암호와 맨 처음 만들 일반 사용자의 이름 및 암호도 미리 설정할 수 있습니다. 암호의 경우 일반 텍스트 값을 그대로 쓸 수도 있고 MD5 <emphasis
>해시값</emphasis
>을 쓸 수도 있습니다. </para>
<warning
><para
>미리 설정한 암호는 안전하지 않습니다. 미리 설정 파일을 읽을 수 있는 사람은 암호도 알 수 있기 때문입니다. MD5 해시를 사용하면 보안 측면에서 약간 낫지만, MD5 해시 역시 암호를 계속해서 입력해 보는 방식의 공격에 약하므로 제대로 된 보안이라고 할 수 없습니다. </para
></warning>

<informalexample role="example"
><screen
># 루트 계정을 만들지 않고 넘어갑니다.  (일반 유저는 sudo를 사용할 
# 수 있습니다.).
#d-i passwd/root-login boolean false
# 아니면 일반 사용자를 만들지 않고 넘어갈 수 있습니다.
#d-i passwd/make-user boolean false

# 루트 암호, 암호 원문 텍스트를 직접 쓸 수도 있고
#d-i passwd/root-password password r00tme
#d-i passwd/root-password-again password r00tme
# 아니면 MD5 해시로 암호화된 암호를 쓸 수도 있습니다.
#d-i passwd/root-password-crypted password [MD5 hash]

# 아니면 일반 사용자 계정을 하나 만듭니다.
#d-i passwd/user-fullname string Debian User
#d-i passwd/username string debian
# 일반 사용자 암호, 암호 원문 텍스트를 직접 쓸 수도 있고
#d-i passwd/user-password password insecure
#d-i passwd/user-password-again password insecure
# 아니면 MD5 해시로 암호화된 암호를 쓸 수도 있습니다.
#d-i passwd/user-password-crypted password [MD5 hash]
# 기본값이 아닌 지정한 UID 값으로 첫번째 사용자를 만듭니다.
#d-i passwd/user-uid string 1010

# 사용자 계정은 표준으로 정해진 그룹에 들어갑니다. 강제로
# 그룹을 지정하려면 다음과 같이 합니다.
#d-i passwd/user-default-groups string audio cdrom video
</screen
></informalexample>

<para
><classname
>passwd/root-password-crypted</classname
> 및 <classname
>passwd/user-password-crypted</classname
> 변수의 값으로 <quote
>!</quote
>를 써서 미리 설정할 수 있습니다. 이 경우 해당하는 계정을 사용할 수 없습니다. 루트 계정은 이렇게 하는 게 편리할 수도 있습니다. 물론 루트 계정을 이렇게 하면 시스템 관리를 할 수 있는 다른 방법이 있거나 루트 로그인을 할 수 있는 다른 방법이 있어야 합니다. (예를 들어 SSH 키 인증을 쓰거나 <command
>sudo</command
>를 사용하는 방법) </para
><para
>암호에 대한 MD5 해시를 만드려면 다음 명령을 사용할 수 있습니다: <informalexample
><screen
>$ echo "r00tme" | mkpasswd -s -m md5
</screen
></informalexample>

</para>
  </sect2>

  <sect2 id="preseed-apt">
  <title
>APT 설정</title>
<para
><filename
>/etc/apt/sources.list</filename
>의 설정과 기본 설정 옵션은 설치 방법과 그 이전의 질문에 어떻게 답했냐에 따라 완전히 자동화합니다. 추가적으로 다른 저장소를 지정할 수 있습니다. </para>

<informalexample role="example"
><screen
># non-free와 contrib 소프트웨어를 설치할 수 있습니다.
#d-i apt-setup/non-free boolean true
#d-i apt-setup/contrib boolean true
# 네트워크 미러를 사용하지 않으려면 다음의 주석을 지우십시오.
#d-i apt-setup/use_mirror boolean false
# 어떤 업데이트 서비스를 사용할 지 선택합니다. 사용할 미러를 지정합니다.
# 아래의 값은 보통 사용하는 기본값입니다.
#d-i apt-setup/services-select multiselect security, volatile
#d-i apt-setup/security_host string security.debian.org
#d-i apt-setup/volatile_host string volatile.debian.org

# 추가 저장소, local[0-9] 사용가능
#d-i apt-setup/local0/repository string \
#       http://local.server/debian stable main
#d-i apt-setup/local0/comment string local server
# deb-src 줄을 만듭니다
#d-i apt-setup/local0/source boolean true
# 가까운 저장소의 공개키 URL. 키를 제공하지 않으면 APT가 인증되지 않은
# 저장소에 대해서 오류 메세지를 출력하고 관련 sources.list 줄을 주석
# 처리합니다.
#d-i apt-setup/local0/key string http://local.server/key

# 기본값으로 저장소는 알려진 GPG 키로 인증할 수 있어야 합니다. 아래와 같이
# 설정하면 인증을 검사하지 않습니다. 경고: 안전하지 않으므로, 추천하지 않는
# 방법입니다.
#d-i debian-installer/allow_unauthenticated string true
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-pkgsel">
  <title
>패키지 선택</title>
<para
>태스크는 원하는 대로 설치할 수 있습니다. 현재 이 문서를 쓰는 시점에 사용할 수 있는 태스크는 다음과 같습니다: </para>

<itemizedlist>
<listitem
><para>
  <userinput
>표준 시스템</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>데스크탑</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>gnome-desktop</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>kde-desktop</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>웹 서버</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>인쇄 서버</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>DNS 서버</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>파일 서버</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>메일 서버</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>SQL 데이터베이스</userinput>
</para
></listitem>
<listitem
><para>
  <userinput
>노트북 컴퓨터</userinput>
</para
></listitem>
</itemizedlist>

<para
>태스크를 설치하지 않을 수도 있고, 다른 방법으로 패키지를 설치할 수 있습니다. <userinput
>표준 시스템</userinput
> 태스크는 항상 포함하시길 권장합니다. </para
><para
>태스크로 설치한 패키지 외에 패키지를 더 설치하려면, <classname
>pkgsel/include</classname
> 파라미터를 사용하면 됩니다. 이 파라미터의 값은 쉼표나 공백으로 구분할 수 있으므로, 커널 명령행에서도 쉽게 사용할 수 있습니다. </para>

<informalexample role="example"
><screen
>#tasksel tasksel/first multiselect standard, web-server
# 데스크탑 태스크를 선택했을 때, 기본값인 그놈 대신에 kde와 xfce
# 데스크탑을 설치하기
#tasksel tasksel/desktop multiselect kde, xfce

# 추가로 설치할 패키지
#d-i pkgsel/include string openssh-server build-essential
# debootstrap 다음에 패키지를 업그레이드할 지 여부
# 사용 가능한 값은: none, safe-upgrade, full-upgrade
#d-i pkgsel/upgrade select none

# 어떤 소프트웨어를 설치했는지 설치 프로그램에서 보고서를 보낼 수
# 있습니다. 보고하지 않는 게 기본값이지만, 보고서를 보내면 데비안
# 프로젝트에서 어떤 소프트웨어를 더 많이 사용하고 CD에 포함하는 게
# 좋을 지 결정하는 데 도움이 됩니다.
#popularity-contest popularity-contest/participate boolean false
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-bootloader">
  <title
>부트로더 설치</title>

<informalexample role="example"
><screen
># GRUB은 (x86용) 기본 부트로더입니다. GRUB이 아니라 LILO를 설치하려면,
# 다음의 주석을 지우십시오:
#d-i grub-installer/skip boolean true
# LILO 설치를 건너뛰고, 부트로더를 설치하지도 않으려면, 다음 주석을
# 지우십시오:
#d-i lilo-installer/skip boolean true

# 다음과 같이 설정하는 게 안전합니다. 다음과 같이 하면 컴퓨터에 다른 운영
# 체제를 찾지 못한 경우 자동으로 GRUB을 MBR에 설치합니다.
d-i grub-installer/only_debian boolean true

# 다음과 같이 하면 다른 운영 체제가 있더라도 GRUB을 MBR에 설치합니다.
# 다른 운영 체제를 부팅할 수 없을 수도 있기 때문에 좀 덜 안전한 방법입니다.
d-i grub-installer/with_other_os boolean true

# 다른 방법으로 MBR이 아닌 위치에 설치하려면, 다음 주석을 지우고
# 편집하십시오.
#d-i grub-installer/only_debian boolean false
#d-i grub-installer/with_other_os boolean false
#d-i grub-installer/bootdev  string (hd0,0)
# GRUB을 여러 디스크에 설치하려면:
#d-i grub-installer/bootdev  string (hd0,0) (hd1,0) (hd2,0)

# GRUB 암호를 쓸 수도 있습니다. 일반 텍스트로 쓰거나,
#d-i grub-installer/password password r00tme
#d-i grub-installer/password-again password r00tme
# 아니면 MD5 해시로 암호화한 암호를 쓸 수 있습니다. grub-md5-crypt(8) 참고.
#d-i grub-installer/password-crypted password [MD5 해시]
</screen
></informalexample>

<para
><classname
>grub</classname
>에 대한 암호의 MD5 해시는 <command
>grub-md5-crypt</command
> 명령을 사용해 만들어 낼 수 있습니다. 아니면 <xref linkend="preseed-account"/> 부분의 예제 명령을 사용해서 만들어 낼 수 있습니다. </para>
  </sect2>

  <sect2 id="preseed-finish">
  <title
>설치 마치기</title>

<informalexample role="example"
><screen
># 시리얼 콘솔에서 설치하면, 일반 가상 콘솔은 (VT1-VT6) /etc/inittab에서
# 막습니다. 다음의 주석을 지우면 가상 콘솔을 막지 않습니다.
#d-i finish-install/keep-consoles boolean true

# 설치가 끝났다는 마지막 메세지를 표시하지 않습니다.
d-i finish-install/reboot_in_progress note

# 다음과 같이 하면 다시 시작할 때 CD를 빼지 않습니다.
# 경우에 따라서는 CD를 빼지 않는 게 좋을 수 있습니다.
#d-i cdrom-detect/eject boolean false

# 다음과 같이 하면 설치가 끝났을 때, 설치한 시스템으로
# 다시 시작하지 않고 셧다운합니다.
#d-i debian-installer/exit/halt boolean true
# 다음과 같이 하면 컴퓨터의 전원도 끕니다.
#d-i debian-installer/exit/poweroff boolean true
</screen
></informalexample>

  </sect2>

  <sect2 id="preseed-other">
  <title
>기타 패키지 미리 설정</title>

<informalexample role="example"
><screen
># 어떤 소프트웨어를 설치하느냐에 따라, 혹은 설치하는 중에 무언가 잘못되는
# 경우, 다른 질문을 물어볼 수도 있습니다. 물론 이 질문도 미리 설정할 수
# 있습니다. 설치하는 동안 물어볼 수 있는 모든 질문의 목록을 받고 싶다면, 
# 설치를 한 다음에 다음 명령어를 실행하십시오:
#   debconf-get-selections --installer 
> file
#   debconf-get-selections 
>
> file
</screen
></informalexample>

  </sect2>
 </sect1>


 <sect1 id="preseed-advanced">
 <title
>고급 옵션</title>

  <sect2 id="preseed-hooks">
  <title
>설치할 때 임의의 명령어 실행하기</title>
<para
>미리 설정 도구의 매우 강력하고도 유연한 옵션은, 설치 특정 시점에 명령어와 스크립트를 실행하는 기능입니다. </para>

<informalexample role="example"
><screen
># d-i 미리 설정은 원래부터 보안에 안전하지 않습니다. 설치 프로그램 중의
# 어느 부분도 버퍼 오버플로우나 그 밖의 방법으로 미리 설정 파일의 값을
# 조작하는 공격을 검사하지 않습니다. 믿을 만한 곳에 있는 미리 설정 파일만
# 사용하십시오! 설치 프로그램 안에서 어떤 쉘 명령어라도 실행할 수 있는
# 방법이 만들어져 있습니다. 위험하지만 이 방법은 매우 유용하므로,
# 다음과 같이 설치 프로그램 내에서 쉘 명령어를 실행할 수 있습니다.

# 다음 첫 번째 명령어는 미리 설정 파일을 읽어들인 직후에 가능한 빨리
# 실행합니다. 
#d-i preseed/early_command string anna-install some-udeb
<phrase condition="squeeze">
# 다음 명령은 파티션 프로그램이 시작하기 직전에 실행합니다. 여기에는
# 디스크의 상태에 따라 다르게 동적으로 파티션하는 미리 설정을 사용하면
# 편리합니다. (preseed/early_command 명령이 실행하는 시점에서는
# 디스크의 상태를 알 수 없습니다.)
#d-i partman/early_command \
#       string debconf-set partman-auto/disk "$(list-devices disk | head -"
n1)"
</phrase>
# 다음 명령은 설치를 끝내기 직전에 실행합니다. 그러나 /target디렉토리는 아직
# 사용할 수 있는 시점입니다. /target디렉토리로 chroot해서 직접 사용할
# 수 있고 패키지를 쉽게 설치하기 위해서 apt-install과 in-target명령을 사용
# 할 수 있습니다.
#d-i preseed/late_command string apt-install zsh; in-target chsh -s /bin/zsh
</screen
></informalexample>

  </sect2>
  
  <sect2 id="preseed-seenflag">
  <title
>미리 설정을 이용해 기본값 바꾸기</title>
<para
>미리 설정으로 질문에 대한 기본값을 바꾸면서, 그래도 그 질문을 받도록 만들 수 있습니다. 이렇게 하려면 해당 템플리트에 대한 값을 설정한 다음에 <firstterm
>seen</firstterm
> 플래그를 <quote
>false</quote
>로 놓으면 됩니다.<informalexample
><screen>
d-i foo/bar string value
d-i foo/bar seen false
</screen
></informalexample
> 부팅 파라미터로 <classname
>preseed/interactive=true</classname
>라고 설정하면 <emphasis
>모든</emphasis
> 질문에 대해서 같은 효과를 거둘 수 있습니다. 이 기능은 미리 설정 파일을 테스트하거나 디버깅하는 데도 좋습니다. </para
><para
>주의할 점이, <quote
>d-i</quote
> 소유자는 설치 프로그램에서 사용하는 변수에만 사용해야 합니다. 대상 시스템에 설치한 패키지에 관련된 변수에 대해서는 그 패키지의 이름을 사용해야 합니다. <xref linkend="preseed-bootparms"/> 부분의 각주를 보십시오. </para
><para
>부팅 파라미터를 이용해 미리 설정을 하는 경우, <quote
>?=</quote
> 연산자를 사용해서 해당 질문을 물어보도록 만들 수 있습니다. 예를 들어 <userinput
><replaceable
>어쩌구</replaceable
>/<replaceable
>저쩌구</replaceable
>?=<replaceable
>값</replaceable
></userinput
>와 같이 (아니면 <userinput
><replaceable
>소유자</replaceable
>:<replaceable
>어쩌구/저쩌구</replaceable
>?=<replaceable
>값</replaceable
></userinput
>) 합니다. </para
> 
  </sect2>

  <sect2 id="preseed-chainload">
  <title
>미리 설정 파일을 분리해서 사용하기</title>
<para
>미리 설정 파일에서 다른 미리 설정 파일을 포함할 수도 있습니다. 파일에 들어 있는 설정은 앞에서 읽어들인 파일에 들어 있는 설정을 덮어 씁니다. 이 방법을 이용해서, 예를 들어 파일 하나에 일반적인 네트워크 설정을 집어 넣고 세세한 설정을 다른 파일에 집어 넣는 식으로 활용이 가능합니다. </para>

<informalexample
><screen
># 여러 개 파일을 공백으로 구분해서 쓸 수도 있습니다. 그러면 모든
# 파일을 읽어들입니다. 물론 포함한 파일은 그 안에 preseed/include가
# 들어 있을 수 있습니다. 주의할 점으로, 파일 이름이 상대 경로인 경우 그
# 파일이 포함되어 들어가는 파일이 있는 같은 디렉토리에서 찾게 됩니다.
#d-i preseed/include string x.cfg

# 설치 프로그램은 미리 설정 파일을 사용하기 전에 그 파일의 체크섬을
# 검사합니다. 현재는 md5sum만 지원하고, md5sum을 포함하는 파일과 같은
# 순서로 쓰십시오.
#d-i preseed/include/checksum string 5da499872becccfeda2c4872f9171c3d

# 좀 더 유연하게 하려면, 다음과 같이 하면 미리 설정 파일의 이름을
# 출력하는 쉘 명령어를 출력하고, 그 파일을 포함합니다.
#d-i preseed/include_command \
#      string if [ "`hostname`" = bob ]; then echo bob.cfg; fi

# 이 중에거 가장 유연한 것으로, 프로그램을 다운로드하고 이를 실행할 수 
# 있습니다. 이 프로그램은 debconf 데이터베이스를 조작하기 위해 
# debconf-set과 같은 명령을 사용할 수 있습니다. 여러 개의 스크립트를
# 공백으로 구분해서 쓸 수도 있습니다. 파일 이름이 상대경로로 되어 있으면
# 프로그램을 실행하는 미리 설정 파일이 있는 디렉토리에서 파일을 찾습니다.
#d-i preseed/run string foo.sh
</screen
></informalexample>

<para
>initrd 혹은 파일을 이용한 미리 설정 단계에서, 파일 안에 다시 preseed/url을 설정해서 네트워크 미리 설정을 겹쳐 넣을 수도 있습니다. 이렇게 하면 네트워크가 연결되었을 때 미리 설정을 읽어들이게 됩니다. 이와 같이 하는 경우에는 주의해야 합니다. 미리 설정을 실행하는 두 개의 별도의 단계가 있기 때문입니다. 예를 들어서 preseed/early 명령을 한 번 더 실행할 수 있고, 두 번째가 네트워크가 연결된 다음에 실행될 수 있습니다. </para>

  </sect2>
 </sect1>
</appendix>
<!--   End of file appendix/preseed.xml -->
