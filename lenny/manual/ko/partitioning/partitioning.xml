<!-- Start of file partitioning/partitioning.xml -->
<!-- $Id: partitioning.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<appendix id="partitioning">
<title
>데비안에서 파티션하기</title>


<!-- Start of file partitioning/sizing.xml -->
<!-- $Id: sizing.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


 <sect1 id="partition-sizing">
 <title
>데비안 파티션 및 크기 정하기</title>
<para
>GNU/리눅스는 전용 파티션이 최소한 하나 필요합니다. 파티션 한 개에 전체 운영 체제와, 응용 프로그램과, 개인 파일을 집어 넣을 수도 있습니다. 보통 스왑 파티션이 따로 있어야 하지만, 꼭 필요하지는 않습니다. <quote
>스왑</quote
>은 운영체제가 사용하는 임시 공간으로, 스왑을 이용해 디스크를 <quote
>가상 메모리</quote
>로 사용합니다. 스왑을 별도의 파티션에 만들면, 스왑을 더 효율적으로 사용할 수 있습니다. 일반 파일을 스왑으로 사용할 수도 있지만, 추천하는 방식은 아닙니다. </para
><para
>하지만 대부분은 (최소한 필요한 파티션 보다는) 더 많은 파티션을 GNU/리눅스에 사용합니다. 파일 시스템을 여러 개의 작은 파티션에 나누는 게 좋은 두 가지 이유가 있습니다. 첫째는 안전 문제입니다. 무슨 이유에서든 파일 시스템이 손상될 경우, 보통 한 파티션만 손상됩니다. 즉 (잘 보관해 두고 있던 백업에서) 시스템의 일부분만 복구하면 됩니다. <quote
>루트 파티션</quote
>이라고 하는 파티션을 최소한으로 만드는 게 좋습니다. 루트 파티션에는 시스템의 가장 핵심 컴포넌트만 들어 있습니다. 다른 파티션이 손상되더라도 이 루트 파티션이 정상이면 GNU/리눅스 시스템으로 들어가서 시스템을 바로잡을 수 있습니다. 시스템을 처음부터 다시 설치하는 것보다는 수고를 덜 수 있습니다. </para
><para
>두번째 이유는 보통 업무용 컴퓨터에서 더 중요하지만, 컴퓨터를 어떻게 사용하느냐에 따라 다릅니다. 예를 들어 대량을 스팸 메일을 받는 메일 서버에서는 금방 파티션 하나가 꽉 찹니다. 그 메일 서버에서 <filename
>/var/mail</filename
>을 별도의 파티션에 만들었다면, 스팸메일을 받더라도 시스템의 다른 부분은 계속 동작할 것입니다. </para
><para
>파티션 여러 개의 사용할 경우 유일한 단점은, 파티션에 필요한 크기를 미리 알기 힘들다는 점입니다. 파티션을 너무 작게 만들면 시스템을 새로 설치하거나 그 파티션에 있는 파일을 자주 다른 파티션으로 옮겨야 합니다. 반면 파티션을 너무 크게 만들면 다른 곳에서 쓸 수 있는 용량을 낭비하는 셈이 됩니다. 디스크 가격이 저렴해 졌지만 낭비할 필요는 없습니다. </para>
 </sect1>
<!--   End of file partitioning/sizing.xml -->

<!-- Start of file partitioning/tree.xml -->
<!-- $Id: tree.xml 39465 2006-07-30 15:03:12Z fjp $ -->


 <sect1 id="directory-tree">
 <title
>디렉토리 구조</title>
<para
>&debian;는 디렉토리와 파일의 이름을 정할 때 <ulink url="&url-fhs-home;"
>Filesystem Hierarchy Standard</ulink
>를 따릅니다. 이 표준을 준수하면 사용자와 소프트웨어에서 처음 접하는 시스템이라도 파일과 디렉토리의 위치가 어디인지 알 수 있습니다. 루트 디렉토리는 간단히 슬래쉬 <filename
>/</filename
>로 표시합니다. 데비안은 루트 디렉토리 아래에 다음과 같은 디렉토리가 있습니다: <informaltable
> <tgroup cols="2">
<thead>
<row>
  <entry
>디렉토리</entry
><entry
>내용</entry>
</row>
</thead>

<tbody>
<row>
  <entry
><filename
>bin</filename
></entry>
  <entry
>핵심 명령어 바이너리</entry>
</row
><row>
  <entry
><filename
>boot</filename
></entry>
  <entry
>부트로더에서 필요한 고정 파일</entry>
</row
><row>
  <entry
><filename
>dev</filename
></entry>
  <entry
>장치 파일</entry>
</row
><row>
  <entry
><filename
>etc</filename
></entry>
  <entry
>이 호스트의 시스템 설정</entry>
</row
><row>
  <entry
><filename
>home</filename
></entry>
  <entry
>사용자 홈 디렉토리</entry>
</row
><row>
  <entry
><filename
>lib</filename
></entry>
  <entry
>핵심 공유 라이브러리 및 커널 모듈</entry>
</row
><row>
  <entry
><filename
>media</filename
></entry>
  <entry
>이동식 미디어의 마운트 위치가 들어 있습니다</entry>
</row
><row>
  <entry
><filename
>mnt</filename
></entry>
  <entry
>파일 시스템을 임시로 마운트하는 마운트 위치</entry>
</row
><row>
  <entry
><filename
>proc</filename
></entry>
  <entry
>시스템 정보를 저장하는 가상 디렉토리 (커널 2.4 및 2.6 버전)</entry>
</row
><row>
  <entry
><filename
>root</filename
></entry>
  <entry
>루트 사용자의 홈 디렉토리</entry>
</row
><row>
  <entry
><filename
>sbin</filename
></entry>
  <entry
>핵심 시스템 바이너리</entry>
</row
><row>
  <entry
><filename
>sys</filename
></entry>
  <entry
>시스템 정보를 저장하는 가상 디렉토리 (커널 2.6 버전)</entry>
</row
><row>
  <entry
><filename
>tmp</filename
></entry>
  <entry
>임시 파일</entry>
</row
><row>
  <entry
><filename
>usr</filename
></entry>
  <entry
>이차 디렉토리 구조</entry>
</row
><row>
  <entry
><filename
>var</filename
></entry>
  <entry
>자주 바뀌는 데이터</entry>
</row
><row>
  <entry
><filename
>srv</filename
></entry>
  <entry
>시스템 서비스의 데이터</entry>
</row
><row>
  <entry
><filename
>opt</filename
></entry>
  <entry
>별도의 응용 소프트웨어 패키지</entry>
</row>
</tbody
></tgroup
></informaltable>
</para>

<para
>아래의 목록은 디렉토리와 파티션에 대해 고려할 사항입니다. 실제 시스템 사용량은 시스템의 설정과 사용 용도에 따라 달라집니다. 아래 권장 사항은 파티션할 때 참고만 하십시오. </para>
<itemizedlist>
<listitem
><para
><filename
>/etc</filename
>, <filename
>/bin</filename
>, <filename
>/sbin</filename
>, <filename
>/lib</filename
>, <filename
>/dev</filename
>는 반드시 루트 파티션(<filename
>/</filename
>)에 들어 있어야 합니다. 그렇지 않으면 부팅에 문제가 발생합니다. 루트 파티션은 일반적으로 150&ndash;250MB 정도가 필요합니다. </para
></listitem>
<listitem
><para
><filename
>/usr</filename
>: 모든 유저 프로그램(<filename
>/usr/bin</filename
>)과 라이브러리(<filename
>/usr/lib</filename
>)와 시스템 문서(<filename
>/usr/share/doc</filename
>) 등이 들어 있습니다. 보통 파일 시스템에서 가장 하드 디스크 공간을 많이 차지하는 부분입니다. 최소한 500MB를 할당하십시오. 시스템에 설치할 패키지의 수와 종류에 따라 더 늘려야 할 수도 있습니다. 보통 워크스테이션이나 서버로 설치하려면 4&ndash;6GB 정도가 필요합니다. </para
></listitem>
<listitem
><para
><filename
>/var</filename
>: 뉴스그룹 기사, 전자메일, 웹 페이지, 데이터베이스, 패키지 시스템의 캐시 등 자주 바뀌는 정보가 이 디렉토리에 들어갑니다. 이 디렉토리의 크기는 시스템에 따라 크게 차이가 나지만, 대부분 사용자의 시스템에서는 패키지 관리 도구가 대부분을 사용할 것입니다. 데비안에 포함된 프로그램을 한 번에 거의 전부 설치하실 경우 <filename
>/var</filename
>에 2 혹은 3GB 정도면 됩니다. 한번에 설치하지 않고 서비스와 유틸리티 따로, 문서 작업용 프로그램 따로, X 윈도우 따로 하는 식으로 나눠서 설치하실 경우 300&ndash;500MB로도 가능합니다. 하드디스크 크기가 부족하고 시스템을 대규모로 업데이트할 계획이 없으면 이 파티션을 30이나 40MB정도로 작게 하실 수도 있습니다. </para
></listitem>
<listitem
><para
><filename
>/tmp</filename
>: 프로그램이 만든 임시 데이터를 저장합니다. 40&ndash;100MB 정도면 충분합니다. 압축 유틸리티, CD/DVD 굽기 유틸리티, 멀티미디어 프로그램의 경우 이미지 파일을 <filename
>/tmp</filename
>에 임시로 저장하기도 합니다. 이러한 프로그램을 사용한다면 <filename
>/tmp</filename
>의 크기를 적절히 조절하십시오. </para
></listitem>
<listitem
><para
><filename
>/home</filename
>: 모든 사용자는 이 디렉토리의 서브디렉토리에 개인 데이터를 저장합니다. 이 디렉토리의 크기는 이 시스템을 사용하는 사용자가 몇 명이고 디렉토리에 어떤 파일을 넣을 지에 따라 달라집니다. 예정된 사용량에 따라 다르지만, 각 사용자에게 100MB씩 할당하고, 필요에 따라 이 값을 조정하십시오. 홈 디렉토리에 다수의 멀티미디어 파일(사진, MP3, 동영상)을 저장할 예정이면 더 많은 용량을 잡아 주십시오. </para
></listitem>
</itemizedlist>

 </sect1>
<!--   End of file partitioning/tree.xml -->

<!-- Start of file partitioning/schemes.xml -->
<!-- $Id: schemes.xml 39465 2006-07-30 15:03:12Z fjp $ -->


 <sect1>
 <title
>권장하는 파티션 구조</title>
<para
>처음 사용하거나, 개인용, 가정용 등 기타 혼자서 사용하는 시스템의 경우 <filename
>/</filename
> 파티션 한 개를 (그리고 스왑 파티션도 사용) 이용하는 편이 가장 쉬우면서도 간단한 방법입니다. 하드디스크의 크기가 6GB보다 클 경우 파일 시스템을 EXT3으로 하십시오. EXT2 파티션은 주기적으로 파일 시스템이 올바른지 검사해야 하는데, 그러면 하드디스크의 크기가 클 경우 부팅 시간이 너무 오래 걸립니다. </para
><para
>여러명이 사용하는 시스템이거나 하드디스크의 용량이 큰 시스템에서는 <filename
>/usr</filename
>, <filename
>/var</filename
>, <filename
>/tmp</filename
>, <filename
>/home</filename
> 각각을 <filename
>/</filename
> 파티션과는 별도의 파티션에 두는 것이 좋습니다. </para
><para
>데비안에 없는 프로그램을 많이 설치하려면 <filename
>/usr/local</filename
>을 별도의 파티션에 두는 것이 좋을 수도 있습니다. 메일 서버일 경우에는 <filename
>/var/mail</filename
>을 별도의 파티션에 두는 것이 좋고, <filename
>/tmp</filename
> 역시 20&ndash;50MB 정도되는 별도 파티션에 두는 것이 좋습니다. 사용자가 많은 서버일 경우 <filename
>/home</filename
>의 크기를 충분히 잡고 별도의 파티션에서 만드는 편이 좋습니다. 이렇게 파티션 구성은 어떻게 사용하느냐에 따라 달라집니다. </para
><para
>매우 복잡한 시스템의 경우, <ulink url="&url-multidisk-howto;"
> 멀티디스크 HOWTO</ulink
>를 참고하십시오. ISP나 서버 관리자가 관심있어할 만한 심도 있는 내용을 다루고 있습니다. </para
><para
>스왑 파티션의 크기에 대해서는 여러가지 생각이 다릅니다. 한 가지 방법은 시스템 메모리만큼 스왑 공간을 잡는 것입니다. 또 16MB보다 작으면 안 됩니다. 물론 이런 규칙에도 예외는 있습니다. 256MB 메모리가 들어 있는 컴퓨터에서 10000개의 수식을 동시에 풀려고 한다면, 스왑을 1GB (혹은 그 이상) 필요할 것입니다. </para
><para arch="m68k"
>하지만 Atari Falcon과 매킨토시는 가상 메모리를 사용할 때마다 성능이 크게 떨어집니다. 그러므로 스왑 파티션을 크게 하지 말고 (가능하면) 램을 더 구해 부착하십시오. </para
><para
>32비트 아키텍처에서는 (i386, m68k, 32비트 SPARC, PowerPC), 스왑 파티션 최대 용량이 2GB입니다. 2GB면 어떤 경우에도 충분한 용량입니다. 하지만 정말로 이만큼 많은 스왑이 필요하다면, 스왑을 디스크 여러 개에 나눠 보는 것도 좋습니다. 가능하면 여러 개의 SCSI 및 IDE 채널에 분산하면 더 좋습니다. 스왑 파티션을 여러 개 사용하면 커널이 알아서 작업을 분배하므로 시스템의 성능이 좋아집니다. </para
><para
>예를 들어 좀 오래된 컴퓨터에 램이 32 MB 있고 <filename
>/dev/hda</filename
>에 1.7 GB짜리 IDE 하드디스크가 있습니다. 500MB짜리 <filename
>/dev/hda1</filename
>에 다른 운영체제가 설치되어 있으며, <filename
>/dev/hda3</filename
>는 32MB의 스왑공간으로 사용합니다. <filename
>/dev/hda2</filename
>에는 1.2GB 용량에 리눅스를 사용합니다. </para
><para
>시스템 설치가 끝났을 때 얼마나 공간을 차지할 지 알고 싶으면, <xref linkend="tasksel-size-list"/> 부분을 참고하십시오. </para>

 </sect1>
<!--   End of file partitioning/schemes.xml -->

<!-- Start of file partitioning/device-names.xml -->
<!-- $Id: device-names.xml 56142 2008-09-26 10:45:40Z lunar $ -->


 <sect1 id="device-names">
 <title
>리눅스의 장치 이름</title>
<para
>리눅스에서 디스크와 파티션을 부르는 이름이 다른 운영 체제와 다르기도 합니다. 파티션을 만들고 파티션할 때 이 리눅스 이름을 알고 있어야 합니다. 기본적으로는 다음 규칙을 따릅니다: </para>
<itemizedlist arch="not-s390">
<listitem
><para
>첫번째 플로피 디스크 드라이브는 <filename
>/dev/fd0</filename
>이라고 합니다. </para
></listitem>
<listitem
><para
>두번째 플로피 디스크 드라이브는 <filename
>/dev/fd1</filename
>이라고 합니다. </para
></listitem>
<listitem
><para
>첫번째 (SCSI ID 주소로 생각할 경우 첫번째) SCSI 디스크는 <filename
>/dev/sda</filename
>라고 합니다. </para
></listitem>
<listitem
><para
>두번째 디스크는 <filename
>/dev/sdb</filename
>라고 하고, 세번째와 네번째 그 이후 모두 이런 방식으로 이름이 붙습니다. </para
></listitem>
<listitem
><para
>첫번째 SCSI CD-ROM은 <filename
>/dev/scd0</filename
>이라고 하고, <filename
>/dev/sr0</filename
>이라고도 합니다. </para
></listitem>
<listitem
><para
>IDE 주 컨트롤러의 마스터 디스크는 <filename
>/dev/hda</filename
>라고 합니다. </para
></listitem>
<listitem
><para
>IDE 주 컨트롤러의 슬레이브는 <filename
>/dev/hdb</filename
>라고 합니다. </para
></listitem>
<listitem
><para
>IDE 부 컨트롤러의 마스터와 슬레이브는 각각 <filename
>/dev/hdc</filename
>, <filename
>/dev/hdd</filename
>라고 합니다. 최근의 IDE 컨트롤러는 채널도 2개이므로 컨트롤러 2개처럼 동작할 수도 있습니다. <phrase arch="m68k"
> pdisk 매킨토시 프로그램에 표시하는 이름과는 글자가 다를 수도 있습니다. 예를 들어 pdisk에서는 <filename
>/dev/hdc</filename
>인 하드 디스크가 데비안에서는 <filename
>/dev/hda</filename
>일 수도 있습니다. </phrase
> </para
></listitem>

<listitem arch="m68k"
><para
>첫번째 ACSI 장치의 이름은 <filename
>/dev/ada</filename
>이고, 두번째는 <filename
>/dev/adb</filename
>입니다. </para
></listitem>
</itemizedlist>

<itemizedlist arch="s390">
<listitem
><para
>첫번째 DASD 장치의 이름은 <filename
>/dev/dasda</filename
>입니다. </para
></listitem>
<listitem
><para
>두번째 DASD 장치는 <filename
>/dev/dasdb</filename
>이고, 세번째와 네번째 이후 모두 이런 방식으로 이름이 붙습니다. </para
></listitem>
</itemizedlist>

<para arch="not-s390"
>드라이브의 파티션 이름은 디스크 이름 뒤에 숫자를 붙입니다. <filename
>sda1</filename
>와 <filename
>sda2</filename
>는 각각 첫번째 SCSI 디스크의 첫번째와 두번째 파티션을 말합니다. </para
><para arch="not-s390"
>실제 예를 들어보면 다음과 같습니다. SCSI 디스크가 2개 있어서, 하나는 SCSI 주소 2에 연결되어 있고 다른 하나는 4에 연결되어 있습니다. 첫번째 (2번 주소에 연결된) 디스크가 <filename
>sda</filename
>이고, 두번째 (4번 주소에 연결된) 디스크가 <filename
>sdb</filename
>입니다. <filename
>sda</filename
>에 파티션이 3개이면, 그 파티션의 이름은 <filename
>sda1</filename
>, <filename
>sda2</filename
>, <filename
>sda3</filename
>입니다. <filename
>sdb</filename
> 디스크와 그 파티션도 같은 방식입니다. </para
><para arch="not-s390"
>SCSI 호스트 버스 어댑터(컨트롤러)가 2개 있으면 어느 드라이브가 첫번째가 될지 알기 어려울 수도 있습니다. 이 경우엔 부팅할 때 메세지를 잘 보고, 드라이브의 모델과 용량으로 파악하는 게 최선의 방법입니다. </para
><para arch="x86"
>리눅스에서 주 파티션은 드라이브 이름 뒤에 숫자 1에서 4까지가 붙습니다. 예를 들어 첫번째 IDE 드라이브의 첫번째 파티션은 <filename
>/dev/hda1</filename
>입니다. 논리파티션은 5번부터 시작하므로, 이 드라이브의 첫번째 논리파티션은 <filename
>/dev/hda5</filename
>입니다. 논리파티션이 들어있는 확장 파티션은 직접 쓸 수 없습니다. SCSI 디스크, IDE 디스크 모두 적용됩니다. </para
><para arch="m68k"
>VMEbus 시스템에서 TEAC FC-1 SCSI 플로피 드라이브는 일반 SCSI 디스크로 인식합니다. 설치하면 이 디스크 드라이브를 쉽게 알아보도록 심볼릭 링크로 <filename
>/dev/sfd0</filename
>이라고 심볼릭 링크를 만듭니다. </para
><para arch="sparc"
>Sun 디스크 파티션은 8개 파티션(슬라이스)을 지원합니다. 세번째 파티션은 보통 <quote
>디스크 전체</quote
>를 말합니다. 이 파티션은 디스크의 모든 섹터를 포함하고, 부트로더에서 (SILO나 Sun의 부트로더) 사용합니다. </para
><para arch="s390"
>각 디스크의 파티션은 디스크 이름 뒤에 십진수 숫자를 붙입니다. 예를 들어 <filename
>dasda1</filename
>과 <filename
>dasda2</filename
>는 각각 시스템에 설치한 첫번째와 두번째 DASD 장치를 가리킵니다. </para>
 </sect1>
<!--   End of file partitioning/device-names.xml -->

<!-- Start of file partitioning/partition-programs.xml -->
<!-- $Id: partition-programs.xml 42302 2006-10-28 23:28:36Z fjp $ -->

 <sect1 id="partition-programs">
 <title
>데비안의 파티션 프로그램</title>
<para
>데비안에서는, 여러가지 종류의 하드디스크와 여러가지 컴퓨터 아키텍처에 동작하는 여러가지 파티션 프로그램이 있습니다. 다음은 이 아키텍처에서 사용활 수 있는 프로그램 목록입니다. </para>

<variablelist>

<varlistentry>
<term
><command
>partman</command
></term>
<listitem
><para
>데비안에서 권장하는 파티션용 프로그램. 이 만능 프로그램은 파티션의 크기를 조정할 수도 있고, 파일 시스템을 만들고<phrase arch="x86"
> (윈도우즈에서 말하는 <quote
>포맷</quote
>)</phrase
>, 마운트 위치도 설정할 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry condition="fdisk.txt">
<term
><command
>fdisk</command
></term>
<listitem
><para
>처음부터 있던 리눅스 파티션 프로그램. 전문가용. </para
><para
>FreeBSD용 파티션이 디스크에 있으면 주의해야 합니다. 설치용 커널은 이 형식의 파티션을 지원하지만, <command
>fdisk</command
> 프로그램에서 이 파티션을 화면에 표시하는 형식이 다릅니다. <ulink url="&url-linux-freebsd;"
>리눅스+FreeBSD 하우투</ulink
>를 참고하십시오. </para
></listitem>
</varlistentry>

<varlistentry condition="cfdisk.txt">
<term
><command
>cfdisk</command
></term>
<listitem
><para
>간단하고 널리 사용하는 전체 화면 파티션 프로그램. </para
><para
><command
>cfdisk</command
>는 FreeBSD 파티션을 전혀 인식하지 못하기 때문에 (다시 말하지만) 장치의 이름이 다를 수도 있으니 주의하십시오. </para
></listitem>
</varlistentry>

<varlistentry condition="atari-fdisk.txt">
<term
><command
>atari-fdisk</command
></term>
<listitem
><para
>Atari용 <command
>fdisk</command
>입니다. </para
></listitem>
</varlistentry>

<varlistentry condition="amiga-fdisk.txt">
<term
><command
>amiga-fdisk</command
></term>
<listitem
><para
>Amiga용 <command
>fdisk</command
>입니다. </para
></listitem>
</varlistentry>

<varlistentry condition="mac-fdisk.txt">
<term
><command
>mac-fdisk</command
></term>
<listitem
><para
>매킨토시용 <command
>fdisk</command
>입니다. </para
></listitem>
</varlistentry>

<varlistentry condition="pmac-fdisk.txt">
<term
><command
>pmac-fdisk</command
></term>
<listitem
><para
>PowerMac용 <command
>fdisk</command
>로, BVM과 모토로라 VMEbus 시스템에서도 사용할 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry condition="fdasd.txt">
<term
><command
>fdasd</command
></term>
<listitem
><para
><command
>fdisk</command
>의 &arch-title; 버전입니다. 자세한 내용은 fdasd 맨페이지나 <ulink url="http://oss.software.ibm.com/developerworks/opensource/linux390/docu/l390dd08.pdf"
> Device Drivers and Installation Command</ulink
>의 13장을 참고하십시오. </para
></listitem>
</varlistentry>
</variablelist>

<para
><guimenuitem
>디스크 파티션하기</guimenuitem
> 메뉴를 선택하면 위 프로그램 중 하나를 실행합니다. VT2에서 명령행을 이용해 다른 파티션 도구를 사용할 수도 있지만, 이 방법은 추천하지 않습니다. </para
><para arch="x86"
>반드시 부팅 파티션을 <quote
>Bootable</quote
>로 지정하십시오. </para
><para condition="mac-fdisk.txt"
>매킨토시용 디스크를 파티션할 때 주의할 점은, 스왑파티션을 이름으로 구분한다는 점입니다. <quote
>swap</quote
>이라는 이름으로 해야 합니다. 매킨토시용 리눅스 파티션은 모두 같은 타입으로 Apple_UNIX_SRV2입니다. 자세한 사항은 문서를 참고하십시오. 맥오에스와 디스크를 공유하려고 할 때 방법을 설명한, <ulink url="&url-mac-fdisk-tutorial;"
>mac-fdisk Tutorial</ulink
>도 읽어 보십시오. </para>


<!-- Start of file partitioning/partition/alpha.xml -->
<!-- $Id: alpha.xml 39920 2006-08-17 17:52:44Z fjp $ -->


  <sect2 arch="alpha"
><title
>&arch-title;에서 파티션하기</title>
<para
>SRM 콘솔에서 데비안을 부팅할 경우 (&releasename;에서 유일하게 지원하는 방식) 부팅 디스크에 DOS 파티션 테이블이 아니라 BSD 디스크 레이블이 필요합니다. (SRM 부트 블록은 MS-DOS 파티션 테이블과 호환되지 않습니다. <xref linkend="alpha-firmware"/> 부분을 참고하십시오.) 그래서 <command
>partman</command
> 명령을 &architecture;에서 실행하면 BSD 디스크 레이블을 만듭니다. 하지만 디스크에 DOS 파티션 테이블이 이미 들어 있는 경우엔 기존 파티션을 지운 다음에 <command
>partman</command
> 명령어로 디스크 레이블을 만들어야 합니다. </para
><para
><command
>fdisk</command
> 명령어로 디스크를 파티션면서 BSD 디스크 레이블을 아직 만들지 않은 디스크의 경우, <quote
>b</quote
> 명령어로 디스크 레이블 모드로 들어가서 디스크 레이블을 만들어야 합니다. </para
><para
>Tru64 Unix나 4.4BSD-Lite 기반 운영체제(FreeBSD, OpenBSD, NetBSD)와 디스크를 공유하려는 경우가 아니면, 세번째 파티션을 전체 디스크 파티션으로 하지 (시작과 끝 섹터로 전체 디스크를 포함하지) <emphasis
>말아야 합니다</emphasis
>. 그렇게 하면 aboot로 부팅할 때 사용하는 프로그램과 호환되지 않습니다. 즉 설치 프로그램으로 만든 데비안 부팅 디스크를 다른 운영 체제에서 접근하지 못합니다. </para
><para
>그리고 <command
>aboot</command
>는 디스크의 가장 앞 부분에 (현재 약 70KB, 혹은 150섹터 차지) 들어 가므로, 디스크 시작 부분에 충분한 빈 공간을 비워두어야 합니다. 예전에는 디스크 시작 부분에 작은 파티션을 포맷하지 않은 상태로 만들도록 권장했습니다. 하지만 지금은 GNU/리눅스 전용 디스크는 이렇게 하지 않기를 권합니다. <command
>partman</command
>을 사용하면 여전히 <command
>aboot</command
>용 파티션을 만듭니다. </para
><para condition="FIXME"
>ARC에 설치할 경우 디스크 맨 앞에 <command
>MILO</command
>와 <command
>linload.exe</command
> 명령어가 들어가는 작은 FAT 파티션을 만드십시오. 5 MB 정도면 충분합니다. <xref linkend="non-debian-partitioning"/> 부분을 참고하십시오. 아쉽게도 메뉴에서는 FAT 파티션을 만들 수 없고, 쉘에서 수동으로 <command
>mkdosfs</command
> 명령을 사용하여 파티션을 만든 다음 부트로더를 설치하십시오. </para>
  </sect2>
<!--   End of file partitioning/partition/alpha.xml -->

<!-- Start of file partitioning/partition/hppa.xml -->
<!-- $Id: hppa.xml 35595 2006-03-18 21:15:59Z fjp $ -->


  <sect2 arch="hppa"
><title
>&arch-title;에서 파티션하기</title>
<para
>HPPA 부트로더인 PALO의 경우, 맨 처음 2GB 안에 <quote
>F0</quote
> 타입 파티션이 필요합니다. 여기에 부트로더, 커널, 램디스크를 저장하므로, 최소 4MB 정도 (8 &ndash; 16MB 권장) 할당하십시오. 펌웨어의 제약때문에 리눅스 커널도 이 2GB 안에 들어 있어야 합니다. 간단히 루트 EXT2 파티션을 2GB 부분 안에 들어가도록 만들면 됩니다. 다른 방법으로 디스크 앞 부분에 작은 EXT2형 파티션을 만든 후 이 파티션을 <filename
>/boot</filename
>에 마운트하는 방법도 있습니다. 리눅스 커널은 이 디렉토리에 저장되기 때문입니다. 리눅스 커널이 (그리고 백업한 커널이) 들어가야 하므로 약 25 &ndash;50MB 정도 할당하면 충분합니다. </para>
  </sect2>
<!--   End of file partitioning/partition/hppa.xml -->

<!-- Start of file partitioning/partition/x86.xml -->
<!-- $Id: x86.xml 42250 2006-10-26 15:29:36Z fjp $ -->


  <sect2 arch="x86"
><title
>&arch-title;에서 파티션하기</title>
<para
>DOS나 윈도우즈같은 기존 운영 체제가 있고, 그 운영체제를 유지하면서 데비안을 설치하시려면, 이 운영 체제의 파티션 크기를 조정해서 데비안을 설치할 빈 공간을 만들어야 할 것입니다. 설치 프로그램은 FAT와 NTFS 파일 시스템의 크기 조정을 지원합니다. 설치 프로그램의 파티션 단계에 들어갔을 때, <guimenuitem
>수동으로</guimenuitem
>를 선택하고 기존 파티션을 선택해 크기를 바꾸십시오. </para
><para
>PC BIOS때문에 디스크를 파티션할 때 제약 사항이 있습니다. 드라이브 한 개에 들어갈 수 있는 <quote
>주 파티션</quote
>과 <quote
>논리 파티션</quote
>의 개수에 제한이 있습니다. 또 1994&dash;1998년 이전의 BIOS에는 부팅할 수 있는 위치에도 제약이 있습니다. 자세한 내용은 <ulink url="&url-partition-howto;"
>Linux Partition HOWTO</ulink
>와 <ulink url="&url-phoenix-bios-faq-large-disk;"
>Phoenix BIOS FAQ</ulink
>를 참고하십시오. 여기에서도 기초적인 사항을 설명합니다. </para
><para
><quote
>주 파티션</quote
>은 PC용 디스크에서 사용하던 파티션 방식입니다. 이 방식은 파티션을 4개만 만들 수 있습니다. 이 한계를 벗어나려고 <quote
>확장 파티션</quote
>과 <quote
>논리 파티션</quote
>이 만들어졌습니다. 주 파티션 하나를 확장 파티션으로 두면 그 파티션을 최대 60개의 논리 파티션으로 나눌 수 있습니다. 하지만 디스크 하나에는 확장 파티션을 하나만 만들 수 있습니다. </para
><para
>리눅스는 파티션을 SCSI 디스크의 경우 15개(주 파티션 3개, 논리 파티션 12개), IDE 디스크의 경우 63개(주 파티션 3개, 논리 파티션 60개)까지 쓸 수 있습니다. 하지만 일반적인 &debian; 시스템은 기본으로 파티션용 장치 파일이 20개만 들어 있으므로 20개보다 많은 파티션을 만드려면 직접 파티션용 장치를 추가해야 합니다. </para
><para
>대용량 IDE 디스크를 사용하면서, LBA 어드레싱이나 오버레이 드라이브를  (일부 하드디스크 제조사에서 제공) 사용하지 않으면, 부팅 파티션(커널 이미지를 저장하는 파티션)을 하드 디스크의 앞 1024 실린더 (BIOS 주소 변환이 없으면 약 524MB입니다) 안에 둬야 합니다. </para
><para
>1995&ndash;1998년 이후 (제조사에 따라 다릅니다) 출시한 BIOS에는 이런 제약이 없습니다. 새 BIOS는 <quote
>Enhanced Disk Drive Support Specification</quote
>을 지원합니다. 리눅스 부트로더인 LILO와 데비안용 <command
>mbr</command
> 모두 BIOS를 이용해 디스크에서 램으로 커널을 읽어들입니다. BIOS int 0x13의 대용량 디스크 접근 확장 기능이 있으면 그 기능을 사용합니다. 이 기능이 없으면 구식 인터페이스를 대신 사용하는데, 여기서는 1024 실린더 이후 위치의 주소를 사용하지 못합니다. BIOS에 무슨 제약이 있든 간에 리눅스가 부팅하기만 하면 이런 제약이 없습니다. 리눅스는 디스크에 접근할 때 BIOS를 이용하지 않습니다. </para
><para
>대용량 디스크가 있으면, 실린더 주소 변환 기법이 필요할 것입니다. 이 기능은 BIOS 설정에서 설정하고 LBA(Logical Block Addressing)나 CHS translation mode(<quote
>Large</quote
>) 따위를 말합니다. 대용량 디스크에 대해 좀 더 알고 싶으시면 <ulink url="&url-large-disk-howto;"
>Large Disk HOWTO</ulink
>를 참고하십시오. 실린더 변환 기법을 사용하지만 BIOS에서 대용량 디스크 접근 확장 기능을 지원하지 않는 경우에도, 부팅용 파티션이 <emphasis
>변환 후</emphasis
>의 앞 1024번째 실린더 안에 들어가야 합니다. </para
><para
>이 경우 디스크의 맨 앞에 작은 파티션을 만들어서 (25&ndash;50MB 정도면 충분) 부팅 파티션으로 사용하고 나머지를 원하는 대로 파티션하시면 됩니다. 이 부팅 파티션은 <emphasis
>반드시</emphasis
> <filename
>/boot</filename
>에 마운트해야 합니다. 이 위치가 리눅스 커널을 저장할 위치입니다. 이 방법은 시스템이 LBA를 사용하든 대용량 디스크 CHS 변환을 사용하든, BIOS에서 대용량 디스크 접근을 지원하든 안하든 관계 없이 모든 상황에 적용할 수 있습니다. </para>
  </sect2>
<!--   End of file partitioning/partition/x86.xml -->

<!-- Start of file partitioning/partition/ia64.xml -->
<!-- $Id: ia64.xml 43254 2006-12-09 19:03:58Z fjp $ -->


  <sect2 arch="ia64"
><title
>&arch-title;에서 파티션하기</title>
<para
><command
>partman</command
> 디스크 파티션 프로그램은 설치 프로그램이 기본으로 사용하는 파티션 프로그램입니다. 파티션과 마운트 위치를 자동으로 관리하고, 설치가 성공하도록 디스크와 파일 시스템을 올바르게 설정합니다. 이 프로그램은 실제 파티션을 할 때 <command
>parted</command
>를 사용합니다. </para>

   <note>
   <title
>EFI가 지원하는 포맷</title>
<para
>IA-64 EFI 펌웨어는 GPT와 MS-DOS 방식의 파티션 테이블을 모두 지원합니다. (파티션 테이블은 디스크 레이블이라고도 합니다.) i386 PC에서 많이 사용했던 MS-DOS 방식은 IA-64 시스템에서는 이제 권장하지 않습니다. 설치 프로그램에 <command
>cfdisk</command
>가 들어 있지만, <ulink url="parted.txt"
><command
>parted</command
></ulink
>만 사용해야 합니다. GPT와 MS-DOS 방식을 모두 지원하는 프로그램이 <command
>parted</command
>뿐입니다. </para
></note>

<para
><command
>partman</command
>에서 자동으로 파티션하면 EFI 파티션이 디스크의 첫번째 파티션으로 잡힙니다. 메인 메뉴의 <guimenuitem
>자동 파티션</guimenuitem
>에서 <emphasis
>스왑</emphasis
> 설정과 비슷한 방법으로 EFI 파티션을 설정해도 됩니다. </para
><para
><command
>partman</command
> 파티션 프로그램에서 대부분의 디스크 구성을 지원합니다. 드물게 수동으로 디스크를 구성해야 하는 경우도 있습니다. 이런 경우에는 앞에서 설명한 것처럼 쉘에서 <command
>parted</command
> 프로그램을 직접 실행하면 됩니다. 디스크를 전부 지우고 GPT 테이블을 만들고 파티션을 몇 개 만드려면 아래 순서대로 하면 됩니다. <informalexample
><screen>
      mklabel gpt
      mkpartfs primary fat 0 50
      mkpartfs primary linux-swap 51 1000
      mkpartfs primary ext2 1001 3000
      set 1 boot on
      print
      quit
</screen
></informalexample
> 이러면 새 파티션 테이블을 만들고, EFI 부팅 파티션, 스왑 파티션과 루트 파일 시스템 총 3개 파티션을 만듭니다. 그리고 마지막으로 EFI 파티션에 부팅 플래그를 1로 설정합니다. 파티션 크기는 메가바이트(MB) 단위로 지정하고, 시작과 끝 오프셋은 디스크의 맨 앞이 기준입니다. 그러므로 위의 예에서는 1999MB 짜리 EXT2 파일 시스템을 디스크 처음에서 1001MB 위치에 설치합니다. <command
>parted</command
>으로 스왑 파티션을 포맷하면 이 프로그램이 배드 블럭을 검사하는데 몇 분 정도 걸릴 수 있습니다. </para>
  </sect2>

  <sect2 arch="ia64"
><title
>부트로더 파티션의 제약</title>
<para
>IA-64 부트로더인 ELILO는 <userinput
>boot</userinput
> 플래그를 설정한 FAT 파티션이 필요합니다. 이 파티션은 부트로더, 커널, 램디스크가 들어갈 정도로 충분히 커야 합니다. 최소로 20MB는 되야 하지만, 커널을 여러 개 이용할 수도 있으면 128MB 정도가 더 좋습니다. </para
><para
>EFI Boot Manager와 EFI 쉘 모두 GPT 테이블을 지원하므로 부팅 파티션을 디스크의 맨 앞에 두거나 같은 디스크에 두지 않아도 됩니다. 부팅 파티션 만들기를 잊어버리고 파티션을 포맷했더라도 상관 없습니다. <command
>partman</command
> 파티션 프로그램에서 EFI 파티션이 있는지 확인하고 <emphasis
>루트</emphasis
> 파티션을 제대로 설정했는지 확인합니다. 그러므로 패키지를 설치를 시작하기 전에 디스크의 구성을 바로잡을 수 있습니다. EFI 파티션을 빼었을 때 바로잡으려면 디스크의 마지막 파티션의 크기를 조정해 빈 공간에 EFI형 파티션을 만들면 됩니다. </para
><para
>EFI 부팅 파티션과 <emphasis
>루트</emphasis
> 파일 시스템을 같은 디스크에 할당하길 강력히 권장합니다. </para>
  </sect2>

  <sect2 arch="ia64"
><title
>EFI 진단용 파티션</title>
<para
>EFI 펌웨어는 x86 PC에서 사용하는 BIOS보다 훨씬 더 복잡합니다. 어떤 시스템 제조사는 하드 디스크의 파일에 접근하고 하드 프로그램을 실행시킬 수도 있는 EFI의 기능을 이용해, 디스크 안에 각종 진단 결과를 저장하고 EFI용 시스템 관리 프로그램을 저장하기도 합니다. 진단용 파티션은 별도의 FAT 파티션입니다. 자세한 사항은 시스템에 들어 있는 문서 및 기타 부속품을 참고하십시오. 시스템 진단용 파티션은 EFI 부팅 파티션을 설정할 때 같이 설정하면 편합니다. </para>
  </sect2>
<!--   End of file partitioning/partition/ia64.xml -->

<!-- Start of file partitioning/partition/mips.xml -->
<!-- $Id: mips.xml 35613 2006-03-19 04:18:28Z tbm $ -->


  <sect2 arch="mips"
><title
>&arch-title;에서 파티션하기</title>
<para
>SGI 컴퓨터에서 하드 디스크로 부팅을 하려면 SGI 디스크 레이블이 필요합니다. fdisk의 expert 메뉴에서 만들 수 있습니다. 이 때 만드는 볼륨 헤더(9번 파티션)는 크기가 최소한 3MB가 되야 합니다. 볼륨 헤더를 너무 작게 만들었다면 파티션 9번을 지우고 다시 크게 만드십시오. 볼륨헤더는 0번 섹터부터 시작해야 합니다. </para>
  </sect2>
<!--   End of file partitioning/partition/mips.xml -->

<!-- Start of file partitioning/partition/powerpc.xml -->
<!-- $Id: powerpc.xml 48741 2007-07-27 00:59:02Z lunar $ -->


  <sect2 arch="powerpc"
><title
>최신 PowerMac 파티션하기</title>
<para
>뉴월드 PowerMac에 데비안을 설치할 경우 부트로더를 저장할 전용 부트스트랩 파티션을 만드셔야 합니다. 이 파티션은 최소한 819200 바이트여야 하고 <emphasis
>Apple_Bootstrap</emphasis
> 파티션이어야 합니다. <emphasis
>Apple_Bootstrap</emphasis
> 파티션이 아닐 경우 하드디스크로 부팅이 안 됩니다. 이 형식의 파티션은 <command
>partman</command
> 프로그램으로 새 파티션을 만드신 후 <quote
>NewWorld boot partition</quote
>으로 설정하거나, <command
>mac-fdisk</command
>프로그램에서 <userinput
>b</userinput
> 명령을 사용하면 됩니다. </para
><para
>Apple_Bootstrap이라는 파티션 형식은 부트스트랩 파티션을 맥오에스에서 마운트해서 그 내용을 망가뜨리지 않으려면 필요합니다. 이 파티션은 OpenFirmware에서 자동으로 부팅하도록 설정되어 있기 때문입니다. </para
><para
>부트스트랩 파티션에는 작은 파일 3개만 저장하게 되어 있습니다: <command
>yaboot</command
> 바이너리, 그 설정파일 <filename
>yaboot.conf</filename
>, OpenFirmware의 일단계 부트로더인 <command
>ofboot.b</command
>입니다. 파일 시스템에 마운트할 필요도 없고 마운트해서도 안 되고, 커널이나 기타 다른 내용을 이 파티션에 저장해도 안 됩니다. 이 파티션은 <command
>ybin</command
> 프로그램과 <command
>mkofboot</command
> 프로그램을 통해서 관리할 수 있습니다. </para
><para
>OpenFirmware에서 &debian;가 부팅하려면, 부트스트랩 파티션이 다른 나머지 부팅 파티션보다 앞에 와야 합니다. 특히 맥오에스 부팅 파티션보다 앞에 와야 합니다. 부트스트랩 파티션을 가장 먼저 만드는 것이 좋습니다. 나중에 부트스트랩 파티션을 만든 경우에는 <command
>mac-fdisk</command
>의 <userinput
>r</userinput
> 명령을 사용해 부트스트랩 파티션이 파티션맵(파티션 1) 바로 다음에 오도록 조정할 수 있습니다. 물리적인 주소의 순서가 중요한 게 아니라 논리적인 맵 순서가 중요합니다. </para
><para
>애플 디스크는 보통 여러 개의 작은 파티션으로 되어 있습니다. MacOSX와 듀얼 부팅하려면, 이 파티션을 유지하고 작은 HFS 파티션을 (최소 800KB) 두어야 합니다. MacOSX가 부팅할 때마다 맥오에스 파티션이나 드라이버 파티션이 들어 있지 않은 디스크를 초기화하기 때문입니다. </para>
  </sect2>
<!--   End of file partitioning/partition/powerpc.xml -->

<!-- Start of file partitioning/partition/sparc.xml -->
<!-- $Id: sparc.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


  <sect2 arch="sparc"
><title
>&arch-title;에서 파티션하기</title>
<para
>부팅디스크에 <quote
>Sun 디스크 레이블</quote
>을 꼭 만들어두십시오. OpenBoot PROM이 유일하게 인식하는 파티션 방식이기 때문이고, 부팅 디스크를 이 방식으로 파티션하지 않으면 부팅을 할 수 없습니다. <quote
>Sun 디스크 레이블</quote
>은 <command
>fdisk</command
>를 실행할 때 <keycap
>s</keycap
>키를 눌러 만듭니다. </para
><para
>또 &arch-title;용 디스크에서는, 첫번째 파티션이 반드시 0번 실린더에서 시작하도록 하십시오. 이렇게 하면 첫번째 파티션에 파티션 테이블과 부트블록이 들어갑니다. (파티션 테이블과 부트블록은 디스크의 처음 2개 섹터에 들어갑니다.) 부팅 드라이브의 첫번째 파티션에 스왑을 만들면 <emphasis
>안 됩니다</emphasis
>. (스왑 파티션은 파티션 앞 섹터를 보존하지 않습니다.) 첫번째 파티션에 EXT2나 UFS 파일 시스템은 사용할 수 있습니다. 이 파일 시스템은 파티션 테이블과 부트블록을 망가뜨리지 않을 것입니다. </para
><para
>세번째 파티션은 <quote
>전체 디스크</quote
>로 해서 (타입 5) 디스크 전체가 여기 들어가도록 만드는 게 좋습니다. <quote
>Sun 디스크 레이블</quote
>에서 사용하는 방식이고, SILO 부트로더가 정상 동작하는 데 필요합니다. </para>
  </sect2>
<!--   End of file partitioning/partition/sparc.xml -->

 </sect1>
<!--   End of file partitioning/partition-programs.xml -->

</appendix>
<!--   End of file partitioning/partitioning.xml -->
