<!-- Start of file boot-installer/boot-installer.xml -->
<!-- $Id: boot-installer.xml 58161 2009-04-07 08:44:16Z fjp $ -->

<chapter id="boot-installer"
><title
>설치 시스템 부팅하기</title>

<!-- Include only archs that are documented to avoid build-errors -->
<!-- The arch="..." condition can be deleted when al archs are present -->
 <sect1 arch="alpha;arm;x86;ia64;m68k;mips;mipsel;s390;powerpc;sparc">
 <title
>&arch-title;에서 설치 프로그램 부팅하기</title>

<!-- This info is so architecture dependent, that I have turned the   -->
<!-- structure inside out for this chapter. Each arch has a document. -->
<!-- Note: arch hppa is currently missing -->

<warning arch="x86;powerpc"
><para
>계속 유지하려는 다른 운영 체제가 (부팅 설정할 때) 들어 있는 경우, 설치 프로그램으로 부팅하기 <emphasis
>전에</emphasis
> 그 운영 체제를 완전히 셧다운해야 합니다. 운영 체제가 최대 절전중에 (하이버네이션, 디스크에 상태를 기록한 상태) 또 다른 운영 체제를 설치하면, 일시 정지했던 운영체제의 상태를 잃어버리거나 상태가 손상될 수 있고 다시 시작했을 때 문제를 일으킬 수도 있습니다. </para
></warning>
<note condition="gtk"
><para
>그래픽 설치 프로그램을 부팅하는 방법은, <xref linkend="graphical"/> 부분을 참고하십시오. </para
></note>


<!-- Start of file boot-installer/alpha.xml -->
<!-- $Id: alpha.xml 43789 2007-01-03 09:27:39Z vorlon $ -->

 <sect2 arch="alpha" id="alpha-firmware">
 <title
>Alpha 콘솔 펌웨어</title>
<para
>콘솔 펌웨어는 플래시 ROM에 들어 있고 Alpha 시스템의 전원을 켜거나 리셋할 때 시작합니다. Alpha 시스템에는 두 가지 콘솔 방식이 있어서, 두 종류의 콘솔 펌웨어를 사용할 수 있습니다: </para>

<itemizedlist>
<listitem
><para
><emphasis
>SRM 콘솔</emphasis
>은, Alpha Console Subsystem 명세서에 기반하며, OpenVMS, Tru64 UNIX 및 리눅스 운영체제를 위한 운영 환경이 있습니다. </para
></listitem>
<listitem
><para
><emphasis
>ARC, AlphaBIOS, 혹은 ARCSBIOS 콘솔</emphasis
>은, Advanced RISC Computing (ARC) 명세서에 기반하며, 윈도우즈 NT를 위한 운영 환경이 있습니다. </para
></listitem>
</itemizedlist>

<para
>사용자 측면에서 SRM과 ARC의 가장 중요한 차이점은, 어떤 콘솔을 선택하느냐에 따라서 부팅하려는 하드 디스크에 사용할 수 있는 파티션 방식이 다르다는 점입니다. </para
><para
>ARC에서는 부팅 디스크에 MS-DOS 파티션 테이블을 사용해야 합니다. (<command
>cfdisk</command
> 명령으로 만듭니다.) 즉 MS-DOS 파티션 테이블은 ARC에서 부팅할 때 <quote
>네이티브</quote
> 파티션 형식입니다. AlphaBIOS에 디스크 파티션 유틸리티가 들어 있기 때문에, 원한다면 리눅스를 설치하기 전에 펌웨어 메뉴에서 디스크를 파티션할 수도 있습니다. </para
><para
>그 반대로, SRM은 MS-DOS 파티션 테이블과 <emphasis
>호환되지 않습니다</emphasis
>. <footnote
><para
>특히, Console Subsystem Specification에서 필요한 부트섹터 형식이 DOS 파티션 테이블의 위치와 충돌합니다</para
></footnote
> Tru64 Unix는 BSD 디스크레이블 형식을 사용하기 때문에, BSD 디스크레이블이 SRM 설치의 경우 <quote
>네이티브</quote
> 파티션 형식입니다. </para
><para
>Alpha에서 GNU/리눅스는 이 두 콘솔에서 모두 부팅할 수 있는 유일한 운영체제입니다. 하지만 &debian; &release; 릴리스는 SRM 기반 시스템에서만 부팅을 지원합니다. SRM이 없는 Alpha 시스템을 가지고 있다면, 윈도우즈 NT와 같이 선택 부팅을 할 것이고, BIOS 초기화에 ARC 콘솔 기능이 필요하다면, &debian; &release; 설치 프로그램을 사용할 수 없을 것입니다. ARC 콘솔이 필요한 경우에도 다른 설치 미디어를 이용해서 &debian; &release; 릴리스를 실행할 수 있습니다. 예를 들어 MILO로 데비안 우디(woody)를 설치하고 업그레이드할 수 있습니다. </para
><para
>현재 제조되는 (2000년 2월 이후로) Alpha 시스템에서는 <command
>MILO</command
>를 사용할 수 없으므로, 그리고 옛날 Alpha 시스템에서 SRM 펌웨어를 쓰려고 OpenVMS나 Tru64 유닉스 라이선스를 구입할 필요는 없으므로, 가능하면 SRM을 사용하기를 권장합니다. </para
><para
>다음 표는 지원하는 시스템 종류/콘솔을 요약한 것입니다 (시스템 종류 이름에 관해서는 <xref linkend="alpha-cpus"/> 참고). 아래의 <quote
>ARC</quote
>라는 말은 ARC와 호환되는 모든 콘솔을 뜻합니다. </para
><para>

<informaltable
><tgroup cols="2">
<thead>
<row>
  <entry
>시스템 종류</entry>
  <entry
>지원하는 콘솔 종류</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>alcor</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>avanti</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>book1</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>cabriolet</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>dp264</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>eb164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb64p</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb66</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>eb66p</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>jensen</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>lx164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>miata</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>mikasa</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>mikasa-p</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>nautilus</entry>
  <entry
>ARC (마더보드 설명서 참고) 혹은 SRM</entry>
</row
><row>
  <entry
>noname</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>noritake</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>noritake-p</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>pc164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>rawhide</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>ruffian</entry>
  <entry
>ARC 전용</entry>
</row
><row>
  <entry
>sable</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>sable-g</entry>
  <entry
>SRM 전용</entry>
</row
><row>
  <entry
>sx164</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>takara</entry>
  <entry
>ARC 혹은 SRM</entry>
</row
><row>
  <entry
>xl</entry>
  <entry
>ARC 전용</entry>
</row
><row>
  <entry
>xlt</entry>
  <entry
>ARC 전용</entry>
</row>

</tbody>
</tgroup>
</informaltable>

</para
><para
>이 콘솔 중에 어느 것도 직접 리눅스를 부팅할 수는 없습니다. 그래서 중간 역할을 하는 부트로더를 활용해야 합니다. SRM 콘솔의 경우 작은 플랫폼 독립 부트로더인, <command
>aboot</command
>를 사용합니다. <command
>aboot</command
>에 대한 더 자세한 정보는 <ulink url="&url-srm-howto;"
>SRM HOWTO</ulink
>를 참고하십시오. (아쉽지만 좀 오래 된 내용) </para
><para condition="FIXME"
>다음 문단은 우디(woody) 설치 안내서에서 가져온 부분으로 참고하십시오. 나중에 데비안이 MILO 기반 설치를 다시 지원할 때 유용할 것입니다. </para
><para condition="FIXME"
>이 콘솔 중에 어느 것도 리눅스를 직접 부팅할 수 없습니다. 그래서 중간 역할을 하는 부트로더를 활용해야 합니다. 주로 쓰는 리눅스 로더 프로그램은 두 가지로, <command
>MILO</command
>와 <command
>aboot</command
>입니다. </para
><para condition="FIXME"
><command
>MILO</command
>는 그 자체가 콘솔이며, 메모리에서 ARC나 SRM을 덮어 씁니다. <command
>MILO</command
>는 ARC나 SRM에서 부팅할 수 있으며 ARC 콘솔에서는 리눅스를 부팅할 수 있는 유일한 방법입니다. <command
>MILO</command
>는 플랫폼에 따라 다르고 (각 시스템 종류에 따라 다른 <command
>MILO</command
>가 필요합니다) 위의 표에서 ARC를 지원하는 시스템에만 있습니다. <ulink url="&url-milo-howto;"
>MILO HOWTO</ulink
>도 참고하십시오. (아쉽지만 좀 오래된 내용입니다.) </para
><para condition="FIXME"
><command
>aboot</command
>는 작은 플랫폼 독립 부트로더로, SRM에서만 동작합니다. <command
>aboot</command
>에 대한 더 자세한 정보는 <ulink url="&url-srm-howto;"
>SRM HOWTO</ulink
>를 참고하십시오. (역시 아쉽지만 좀 오래된 내용입니다.) </para
><para condition="FIXME"
>즉 시스템의 콘솔 펌웨어가 무엇인가와, <command
>MILO</command
>를 사용할 수 있는지 여부에 따라 다음 세 가지 방법이 가능합니다: <informalexample
><screen>
SRM -&gt; aboot
SRM -&gt; MILO
ARC -&gt; MILO
</screen
></informalexample
> 현재 제조되는 (2000년 2월 이후로) Alpha 시스템에서는 <command
>MILO</command
>를 사용할 수 없으므로, 그리고 옛날 Alpha 시스템에서 SRM 펌웨어를 쓰려고 OpenVMS나 Tru64 유닉스 라이선스를 구입할 필요는 없으므로, 가능하면 SRM을 사용하기를 권장합니다. (윈도우즈 NT와 듀얼 부팅을 하는 경우가 아니라면.) </para
><para
>AlphaServer의 대다수와 현재의 모든 서버와 워크스테이션 제품에는 펌웨어 안에 SRM과 AlphaBIOS가 모두 들어 있습니다. 여러가지 평가보드처럼 <quote
>반쪽-플래시</quote
> 컴퓨터의 경우에는, 펌웨어를 플래시에 다시 쓰는 방법을 통해 두 가지 사이를 전환할 수 있습니다. 또 SRM을 설치하면 플로피 디스크에서 ARC/AlphaBIOS를 실행할 수 있습니다 (<command
>arc</command
> 명령어 사용). 위에서 설명한 이유때문에, 우리는 &debian;를 설치하기 전에 SRM으로 바꾸기를 권장합니다. </para
><para
>다른 아키텍처와 마찬가지로, &debian;를 설치하기 전에 항상 최신 버전의 펌웨어를 <footnote
><para
>Jensen의 경우는 예외입니다. Jensen에서는 1.7 뒤 버전의 펌웨어에서 리눅스를 사용할 수 없습니다. 자세한 정보는 <ulink url="&url-jensen-howto;"
></ulink
> 참고.</para
></footnote
> 설치해야 합니다. Alpha의 경우, 펌웨어 업데이트는 <ulink url="&url-alpha-firmware;"
>Alpha Firmware Updates</ulink
>에서 구할 수 있습니다. </para>
 </sect2>


  <sect2 arch="alpha"
><title
>TFTP로 부팅하기</title>
<para
>SRM에서 이더넷 인터페이스는 이름 앞에 <userinput
>ewa</userinput
>가 붙고, <userinput
>show dev</userinput
> 명령을 실행하면 다음과 같은 인터페이스 목록을 볼 수 있습니다: <informalexample
><screen>
&gt;&gt;&gt; show dev
ewa0.0.0.9.0               EWA0              08-00-2B-86-98-65
ewb0.0.0.11.0              EWB0              08-00-2B-86-98-54
ewc0.0.0.2002.0            EWC0              00-06-2B-01-32-B0
</screen
></informalexample
> 먼저 부팅 프로토콜을 설정해야 합니다: <informalexample
><screen>
&gt;&gt;&gt; set ewa0_protocol bootp
</screen
></informalexample
> 그 다음에 미디어 종류를 올바르게 맞추십시오: <informalexample
><screen>
&gt;&gt;&gt; set ewa0_mode <replaceable
>mode</replaceable>
</screen
></informalexample
>  <userinput
>&gt;&gt;&gt;set ewa0_mode</userinput
> 명령으로 가능한 모드 목록을 볼 수 있습니다. </para
><para
>그 다음, 첫번째 이더넷 인터페이스로 부팅하려면 다음을 입력하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot ewa0 -flags ""
</screen
></informalexample
> 그러면 netboot 이미지에 들어 있는 대로 기본 커널 파라미터를 사용해 부팅하게 됩니다. </para
><para
>시리얼 콘솔을 사용하려면, <userinput
>console=</userinput
> 파라미터를 커널에 넘겨야 <emphasis
>합니다</emphasis
>. <userinput
>-flags</userinput
> 파라미터를 SRM <userinput
>boot</userinput
> 명령에 사용하면 됩니다. 시리얼 포트의 이름은 <userinput
>/dev</userinput
> 아래 있는 해당 장치 파일 이름과 같습니다. 또, 추가 커널 파라미터를 지정할 경우, &d-i; 이미지에서 필요한 기본 옵션을 다시 집어 넣어야 합니다. 예를 들어 <userinput
>ewa0</userinput
>에서 부팅해서 첫번째 시리얼 포트를 사용하려면, 다음과 같이 입력합니다: <informalexample
><screen
>&gt;&gt;&gt; boot ewa0 -flags &quot;root=/dev/ram ramdisk_size=16384 console=ttyS0&quot;
</screen
></informalexample>

</para>
  </sect2>

  <sect2 arch="alpha"
><title
>SRM 콘솔로 CD-ROM에서 부팅하기</title>
<para
>&debian; 설치 CD에는 VGA 및 시리얼 콘솔용 부팅 옵션이 들어 있습니다. 다음을 입력하면 VGA 콘솔을 사용합니다. <informalexample
><screen>
&gt;&gt;&gt; boot xxxx -flags 0
</screen
></informalexample
> 여기서 <replaceable
>xxxx</replaceable
>는 CD-ROM 드라이브로 SRM 방식으로 표기합니다. 시리얼 콘솔을 첫번째 시리얼 장치에서 사용하려면 다음을 입력합니다. <informalexample
><screen>
&gt;&gt;&gt; boot xxxx -flags 1
</screen
></informalexample
> 그리고 두번째 시리얼 장치를 사용하려면 다음을 입력합니다. <informalexample
><screen
>&gt;&gt;&gt; boot xxxx -flags 2
</screen
></informalexample>

</para>
  </sect2>

  <sect2 arch="alpha" condition="FIXME">
  <title
>ARC 혹은 AlphaBIOS 콘솔로 CD-ROM에서 부팅하기</title>
<para
>ARC 콘솔에서 CD-ROM을 부팅하려면, 서브 아키텍처 코드 이름을 찾아서 (<xref linkend="alpha-cpus"/> 참고), <filename
>\milo\linload.exe</filename
>를 부트로더로 입력하고 <filename
>\milo\<replaceable
>subarch</replaceable
></filename
>를 (여기서 <replaceable
>subarch</replaceable
>는 해당 서브 아키텍처 이름) `OS Selection Setup' 메뉴의 OS Path로 입력하십시오. Ruffian의 경우는 예외로, 부트로더로 <filename
>\milo\ldmilo.exe</filename
>를 입력하십시오. </para>
  </sect2>


  <sect2 arch="alpha" condition="supports-floppy-boot">
  <title
>SRM 콘솔로 플로피에서 부팅하기</title>
<para
>SRM 프롬프트에서 (<prompt
>&gt;&gt;&gt;</prompt
>), 다음 명령을 실행하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot dva0 -flags 0
</screen
></informalexample
> 여기서 <filename
>dva0</filename
>을 실제 장치 이름으로 바꿔야 할 수도 있습니다. 보통 <filename
>dva0</filename
>이 플로피입니다. 다음을 실행해 장치 목록을 보려면 (CD에서 부팅하려거나 할 때) 다음을 실행하십시오: <informalexample
><screen>
&gt;&gt;&gt; show dev
</screen
></informalexample
> MILO를 통해 부팅하는 경우, <command
>-flags</command
> 파라미터는 무시하기 때문에, <command
>boot dva0</command
>라고만 입력할 수도 있습니다. 모두 문제 없이 동작한다면, 마침내 리눅스 커널 부팅을 볼 수 있을 것입니다. </para
><para
><command
>aboot</command
>를 통해 부팅할 때 커널 파라미터를 지정하려면, 다음 명령을 사용하십시오: <informalexample
><screen>
&gt;&gt;&gt; boot dva0 -file linux.bin.gz -flags "root=/dev/fd0 load_ramdisk=1 arguments"
</screen
></informalexample
> (한 줄에 입력하십시오) 필요한 경우 <filename
>dva0</filename
>을 실제 SRM 부팅 장치 이름으로, <filename
>fd0</filename
>을 리눅스 부팅 장치 이름으로, <filename
>arguments</filename
>를 사용하려는 커널 파라미터로 바꾸십시오. </para
><para
>MILO를 통해 부팅할 때 커널 파라미터를 지정하려면, 부팅할 때 MILO로 들어간 다음 일시정지해야 합니다. <xref linkend="booting-from-milo"/> 참고. </para>
  </sect2>


  <sect2 arch="alpha" condition="supports-floppy-boot">
  <title
>ARC 혹은 AlphaBIOS 콘솔로 플로피에서 부팅하기</title>

<para
>OS Selection 메뉴에서, <command
>linload.exe</command
>를 부트로더로, <command
>milo</command
>를 OS Path로 설정하십시오. 새로 만든 항목을 이용해 부팅하십시오. </para>
  </sect2>

 <sect2 arch="alpha" condition="FIXME" id="booting-from-milo"
><title
>MILO로 부팅하기</title>
<para
>부팅 미디어에 들어 있는 MILO는 자동으로 리눅스로 들어가도록 되어 있습니다. 중간에 멈추려면 MILO 카운트다운동안에 스페이스 키를 누르면 됩니다. </para
><para
>모든 부분을 하나 하나 지정하려면 (예를 들어, 파라미터를 추가로 지정하려면), 다음과 같은 명령을 사용하십시오: <informalexample
><screen>
MILO
> boot fd0:linux.bin.gz root=/dev/fd0 load_ramdisk=1 <!-- arguments -->
</screen
></informalexample
> 플로피 외에 다른 장치에서 부팅하는 경우에는, 위의 예에서 <filename
>fd0</filename
>을 적당한 리눅스 장치 이름으로 바꾸십시오. <command
>help</command
> 명령을 실행하면 간단한 MILO 명령어 도움말을 볼 수 있습니다. </para>
 </sect2>
<!--   End of file boot-installer/alpha.xml -->

<!-- Start of file boot-installer/arm.xml -->
<!-- $Id: arm.xml 36639 2006-04-23 06:26:34Z jfs $ -->

  <sect2 arch="arm" id="boot-tftp"
><title
>TFTP에서 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

   <sect3 arch="arm"
><title
>NetWinder에서 TFTP에서 부팅하기</title>
<para
>Netwinder에는 네트워크 인터페이스가 2개 있습니다. 하나는 10Mbps NE2000과 호환되는 카드로, 주로 <literal
>eth0</literal
>라고 합니다. 다른 하나는 100Mbps Tulip 카드입니다. 100Mbps 카드를 통해 TFTP로 이미지를 읽어들일 때 문제가 발생할 수 있으므로 <literal
>10 Base-T</literal
>라는 라벨이 붙어있는 10Mbps 인터페이스를 사용하기를 권합니다. </para>
<note
><para
>설치 시스템을 부팅하려면 NeTTrom 2.2.1 혹은 그 이후의 버전을 사용해야 합니다. 2.3.3버전을 권장합니다. 불행히도 펌웨어 파일은 라이선스 문제때문에 다운로드가 불가능합니다. 이 상황이 바뀌면, <ulink url="http://www.netwinder.org/"
></ulink
>에서 새 이미지를 받을 수 있을 것입니다. </para
></note>
<para
>Netwinder 장치를 부팅할 때 카운트다운이 끝나기 전에 부팅 과정을 중단시켜야합니다. 부팅 과정을 중단시켜야 설치 프로그램으로 부팅하는 데 필요한 펌웨어 설정을 바꿀 수 있습니다. 우선 다음 명령을 입력하여 기본 설정을 읽어들입니다: <informalexample
><screen>
    NeTTrom command-&gt; load-defaults
</screen
></informalexample
> 그 다음 네트워크 주소를 설정합니다. 네트워크 주소를 설정하는 방법에는 몇 가지가 있습니다. 우선 정적 주소를 설정하는 방법은 다음과 같습니다: <informalexample
><screen>
    NeTTrom command-&gt; setenv netconfig_eth0 flash
    NeTTrom command-&gt; setenv eth0_ip 192.168.0.10/24
</screen
></informalexample
> 이 때 24는 넷마스크에서 1로 설정된 비트의 개수를 뜻합니다. 동적 주소를 사용하려면 다음과 같이 입력하시면 됩니다: <informalexample
><screen>
    NeTTrom command-&gt; setenv netconfig_eth0 dhcp
</screen
></informalexample
> 로컬 서브넷에 TFTP서버가 없는 경우 <userinput
>route1</userinput
>도 설정해야합니다. 다음 순서대로 TFTP 서버와 이미지 파일의 경로를 설정하십시오. 설정을 바꾼 다음에 플래시에 저장하시면 됩니다.<informalexample
><screen>
    NeTTrom command-&gt; setenv kerntftpserver 192.168.0.1
    NeTTrom command-&gt; setenv kerntftpfile boot.img
    NeTTrom command-&gt; save-all
</screen
></informalexample
> 그 다음은 펌웨어가 TFTP 이미지를 부팅하도록 만듭니다. <informalexample
><screen>
    NeTTrom command-&gt; setenv kernconfig tftp
    NeTTrom command-&gt; setenv rootdev /dev/ram
</screen
></informalexample
> 시리얼 콘솔을 이용하여 Netwinder를 설치하고 있다면, 다음 설정도 추가해야 합니다: <informalexample
><screen>
    NeTTrom command-&gt; setenv cmdappend root=/dev/ram console=ttyS0,115200
</screen
></informalexample
> 시리얼 콘솔이 아니라 키보드와 모니터를 이용해 설치하고 있다면: <informalexample
><screen>
    NeTTrom command-&gt; setenv cmdappend root=/dev/ram
</screen
></informalexample
> 환경 설정을 보려면 <command
>printenv</command
> 명령을 사용하시면 됩니다. 모두 정확하다면 다음 명령으로 이미지를 읽어들이십시오: <informalexample
><screen>
    NeTTrom command-&gt; boot
</screen
></informalexample
> 설치 도중 문제가 발생하면 <ulink url="http://www.netwinder.org/howto/Firmware-HOWTO.html"
>Netwinder Firmware HOWTO</ulink
>를 참조하십시오. </para>
   </sect3>

   <sect3 arch="arm"
><title
>CATS에서 TFTP에서 부팅하기</title>
<para
>CATS 컴퓨터에서는 Cyclone 프롬프트에서 <command
>boot de0:</command
>과 같이 명령을 사용하십시오. </para>
   </sect3>
  </sect2>


  <sect2 arch="arm"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>Cyclone 콘솔 프롬프트에서 CD-ROM 부팅을 하려면, <command
>boot cd0:cats.bin</command
> 명령을 사용하십시오. </para>
  </sect2>


  <sect2 arch="arm" id="boot-firmware"
><title
>펌웨어에서 부팅하기</title>


<!-- Start of file boot-installer/intro-firmware.xml -->
<!-- $Id: intro-firmware.xml 35309 2006-03-07 19:31:05Z tbm $ -->

<para
>최근에는 플래시 칩에서 직접 부팅하는 전자 제품이 점점 많아지고 있습니다. 설치 프로그램을 플래시에 기록하고, 다시 부팅하면 설치 프로그램을 자동으로 실행할 수 있습니다. </para
><note
><para
>내장형 장치의 펌웨어를 변경할 경우 제품 보증이 무효가 되는 경우가 많습니다. 플래시에 기록하다가 문제가 발생하면 장치를 복구하지 못하는 경우도 간혹 발생합니다. 그러므로 다음 과정을 신중하게 따라하십시오. </para
></note>

<!--   End of file boot-installer/intro-firmware.xml -->

   <sect3 arch="arm" id="boot-firmware-nslu2"
><title
>NSLU2로 부팅하기</title>
<para
>설치 프로그램을 플래시에 기록하는 3가지 방법이 있습니다: </para>

    <sect4 arch="arm"
><title
>NSLU2 웹 인터페이스 사용</title>
<para
>administration 섹션으로 가서 <literal
>Upgrade</literal
> 메뉴를 선택하십시오. 이 메뉴를 선택하면 이전에 디스크에서 다운로드한 설치 프로그램의 이미지 파일이 있습니다. 그 다음 <literal
>Start Upgrade</literal
> 단추를 누르고, 확인한 다음, 몇 분을 기다리고 다시 확인하십시오. 이제 시스템이 시작하면 설치 프로그램으로 바로 부팅합니다. </para>
    </sect4>

    <sect4 arch="arm"
><title
>리눅스/유닉스를 사용해 네트워크를 통해</title>
<para
>다른 리눅스나 유닉스 컴퓨터에서 <command
>upslug2</command
>를 사용할 수 있습니다. 이 소프트웨어는 데비안 패키지로 있습니다. 우선 NSLU2를 업그레이드 모드로 놓습니다.<orderedlist
> <listitem
><para
> USB 포트에서 모든 디스크나 장치의 연결을 해제합니다.</para
></listitem
> <listitem
><para
> NSLU2를 종료합니다. </para
></listitem
> <listitem
><para
> 리셋 단추를 눌러서 고정합니다. (리셋 단추는 뒷면에 전원 입력 바로 위에 작은 구멍으로 누릅니다.) </para
></listitem
> <listitem
><para
> 전원 단추를 눌렀다 놓아서 NSLU2를 켭니다.</para
></listitem
> <listitem
><para
> ready/status LED를 보면서 10초간 기다립니다. 10초후에는 불이 호박색에서 빨간색으로 바뀔 것입니다. 이 때 빠르게 리셋 단추를 놓습니다.</para
></listitem
> <listitem
><para
> NSLU2의 ready/status LED가 빨간색과 녹색으로 깜빡입니다. (처음 녹색이 되기 전에 1초의 딜레이가 있습니다.) 이제 NSLU2는 업그레이드 모드입니다.</para
></listitem
> </orderedlist
>이 과정에서 문제가 생기면 <ulink url="http://www.nslu2-linux.org/wiki/OpenSlug/UsingTheBinary"
>NSLU2-Linux pages</ulink
>를 보십시오. NSLU2가 업그레이드 모드인 경우 새 이미지를 플래시에 써 넣을 수 있습니다:<informalexample
><screen>
sudo upslug2 -i di-nslu2.bin
</screen
></informalexample
> 이 도구는 DHCP 서버를 설정할 때 유용하게 쓸 수 있도록 NSLU2의 MAC 주소도 표시합니다. 전체 이미지를 쓰고 검사한 다음에는 자동적으로 시스템을 다시 시작합니다. USB 디스크가 잘 연결되었는지 확인하십시오. 연결이 되어 있지 않으면 설치프로그램이 실패합니다. </para>
    </sect4>

    <sect4 arch="arm"
><title
>윈도우즈를 사용해 네트워크를 통해</title>
<para
>네트워크를 통해 윈도우즈에서 펌웨어를 업그레이드할 수 있는 <ulink url="http://www.everbesthk.com/8-download/sercomm/firmware/all_router_utility.zip"
>도구</ulink
>가 있습니다. </para>
    </sect4>
   </sect3>
  </sect2>
<!--   End of file boot-installer/arm.xml -->
<!-- &boot-installer-hppa.xml; -->

<!-- Start of file boot-installer/x86.xml -->
<!-- $Id: x86.xml 58178 2009-04-08 07:13:21Z fjp $ -->

  <sect2 arch="x86"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<!-- We'll comment the following section until we know exact layout -->
<!--
CD #1 of official Debian CD-ROM sets for &arch-title; will present a
<prompt
>boot:</prompt
> prompt on most hardware. Press
<keycap
>F4</keycap
> to see the list of kernel options available
from which to boot. Just type your chosen flavor name (idepci,
vanilla, compact, bf24) at the <prompt
>boot:</prompt
> prompt
followed by &enterkey;.

</para
><para>

If your hardware doesn't support booting of multiple images, put one
of the other CDs in the drive. It appears that most SCSI CD-ROM drives
do not support <command
>isolinux</command
> multiple image booting, so users
with SCSI CD-ROMs should try either CD2 (vanilla) or CD3 (compact),
or CD5 (bf2.4).

</para
><para>

CD's 2 through 5 will each boot a
different ``flavor'' depending on which CD-ROM is
inserted. See <xref linkend="kernel-choice"/> for a discussion of the
different flavors.  Here's how the flavors are laid out on the
different CD-ROMs:

<variablelist>
<varlistentry>
<term
>CD 1</term
><listitem
><para>

Allows a selection of kernel images to boot from (the idepci flavor is
the default if no selection is made).

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 2</term
><listitem
><para>

Boots the <quote
>vanilla</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 3</term
><listitem
><para>

Boots the <quote
>compact</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 4</term
><listitem
><para>

Boots the <quote
>idepci</quote
> flavor.

</para
></listitem
></varlistentry>
<varlistentry>
<term
>CD 5</term
><listitem
><para>

Boots the <quote
>bf2.4</quote
> flavor.

</para
></listitem
></varlistentry>

 </variablelist>

</para
><para>

-->

  </sect2>

  <sect2 arch="x86" id="boot-win32">
  <title
>윈도우즈에서 부팅하기</title>
<para
>윈도우즈에서 설치 프로그램을 부팅하려면, 먼저 <xref linkend="official-cdrom"/> 및 <xref linkend="boot-usb-files"/>에서 설명한 CD-ROM/DVD-ROM이나 USB 메모리 설치 미디어를 가져와야 합니다. </para
><para
>설치 CD나 DVD를 사용하는 경우, 디스크를 넣었을 때 자동으로 설치 전 프로그램이 실행되야 합니다. 윈도우즈가 이 프로그램을 시작하지 않거나 USB 메모리를 사용하는 경우에는, 수동으로 그 장치를 읽고 <command
>setup.exe</command
>를 실행할 수 있습니다. </para
><para
>프로그램이 시작하면 몇 가지 질문을 한 다음 &debian; 설치 프로그램을 시작하도록 준비합니다. </para>
  </sect2>

<!-- FIXME the documented procedure does not exactly work, commented out
     until fixes

  <sect2 arch="x86" id="install-from-dos">
  <title
>Booting from a DOS partition</title>


<para>

Boot into DOS (not Windows) without any drivers being loaded.  To do
this, you have to press <keycap
>F8</keycap
> at exactly the right
moment (and optionally select the <quote
>safe mode command prompt only</quote>
option).  Enter the subdirectory for the flavor you chose, e.g.,

<informalexample
><screen
>
cd c:\install
</screen
></informalexample
>.

Next, execute <command
>install.bat</command
>.
The kernel will load and launch the installer system.

</para
><para>

Please note, there is currently a loadlin problem (#142421) which
precludes <filename
>install.bat</filename
> from being used with the
bf2.4 flavor. The symptom of the problem is an
<computeroutput
>invalid compressed format</computeroutput
> error.

</para>
  </sect2>

END FIXME -->

  <sect2 arch="x86" id="boot-initrd">
  <title
><command
>LILO</command
> 혹은 <command
>GRUB</command
>을 사용해 리눅스 부팅하기</title>

<para
>하드 디스크에서 설치 프로그램을 부팅하려면, 먼저 <xref linkend="boot-drive-files"/>에서 설명한 필요한 파일을 다운로드해 하드 디스크에 저장해야 합니다. </para>

<para
>하드 드라이브를 부팅용으로만 사용하고 나머지는 모두 네트워크에서 받으려고 한다면, <filename
>netboot/debian-installer/&architecture;/initrd.gz</filename
> 파일 및 해당 커널 <filename
>netboot/debian-installer/&architecture;/linux</filename
>를 받아야 합니다. 설치 프로그램을 부팅한 다음에 하드 디스크를 다시 파티션할 수 있습니다. 단 주의를 기울여야 합니다. </para>

<para
>다른 방법으로 하드 드라이브의 현재 파티션을 바꾸지 않고 유지하려면, <filename
>hd-media/initrd.gz</filename
> 파일과 그 커널을 받으시고, CD ISO 파일도 드라이브에 복사해 놓으십시오 (파일 이름이 <literal
>.iso</literal
>로 끝나도록 하십시오). 그러면 설치 프로그램이 이 드라이브에서 부팅한 다음 네트워크 없이 그 CD 이미지에서 설치할 수 있습니다. </para>

<para
><command
>LILO</command
>의 경우, <filename
>/etc/lilo.conf</filename
>에 있는 두 가지 중요한 부분을 설정해야 합니다: <itemizedlist
> <listitem
><para
> 부팅할 때 <filename
>initrd.gz</filename
> 설치 프로그램을 읽어들여야 하고 </para
></listitem
> <listitem
><para
> <filename
>vmlinuz</filename
> 커널의 루트 파티션으로 램 디스크를 사용하도록 합니다. </para
></listitem
> </itemizedlist
> 여기 예제 <filename
>/etc/lilo.conf</filename
> 파일이 있습니다: </para
><para>

<informalexample
><screen
>image=/boot/newinstall/vmlinuz
       label=newinstall
       initrd=/boot/newinstall/initrd.gz
</screen
></informalexample
> 더 자세한 정보는, <citerefentry
><refentrytitle
>initrd</refentrytitle
> <manvolnum
>4</manvolnum
></citerefentry
> 및 <citerefentry
><refentrytitle
>lilo.conf</refentrytitle
> <manvolnum
>5</manvolnum
></citerefentry
> 맨페이지를 참고하십시오. 이제 <userinput
>lilo</userinput
>를 실행하고 다시 부팅하십시오. </para
><para
><command
>GRUB</command
> 사용법은 아주 비슷합니다. <filename
>menu.lst</filename
> 파일을 <filename
>/boot/grub/</filename
> 디렉토리에 (경우에 따라서는 <filename
>/boot/boot/grub/</filename
>) 놓고, 다음 줄을 추가하십시오: <informalexample
><screen>
title  New Install
kernel (hd0,0)/boot/newinstall/vmlinuz
initrd (hd0,0)/boot/newinstall/initrd.gz
</screen
></informalexample
> 그리고 다시 부팅하십시오. </para
><para
><userinput
>ramdisk_size</userinput
>의 값을 initrd 이미지 크기에 따라 조정해야 할 수도 있습니다. 이 이후부터는 <command
>GRUB</command
>와 <command
>LILO</command
> 사이에 차이점이 없습니다. </para>
  </sect2>

  <sect2 arch="x86" condition="bootable-usb" id="usb-boot">
  <title
>USB 메모리에서 부팅하기</title>
<para
><xref linkend="boot-dev-select"/> 및 <xref linkend="boot-usb-files"/>의 모든 것을 준비했으면, USB 메모리를 빈 USB 단자에 꼽고 컴퓨터를 다시 부팅하십시오. 시스템이 부팅해서 <prompt
>boot:</prompt
> 프롬프트가 나와야 합니다. 거기에서 부팅 파라미터를 추가로 넣을 수도 있고, 그냥 &enterkey;를 누를 수도 있습니다. </para>
  </sect2>

  <sect2 arch="x86" condition="supports-floppy-boot" id="floppy-boot">
  <title
>플로피에서 부팅하기</title>
<para
>필요한 플로피 이미지를 다운로드해서 <xref linkend="create-floppy"/>에서 설명한 대로 이미지를 플로피로 만듭니다. </para
><para
>설치 프로그램 부트 플로피로 부팅하려면, 플로피를 첫번째 플로피 드라이브에 넣고, 평소에 하던 방법처럼 시스템을 끈 다음 다시 켜십시오. </para
><para
>플로피를 이용해 LS-120 드라이브에서 (ATAPI 버전) 설치하는 경우, 플로피 장치의 가상 위치를 지정해야 합니다. <emphasis
>root=</emphasis
> 부팅 파라미터를 사용해, ide-floppy 드라이버가 어느 장치로 매핑되는 지 장치를 지정합니다. 예를 들어 LS-120 드라이브가 두 번째 케이블의 첫번째 (master) IDE 장치에 연결되어 있는 경우, 부팅 프롬프트에서 <userinput
>install root=/dev/hdc</userinput
>라고 입력합니다. </para
><para
>컴퓨터에 따라서는 <keycombo
><keycap
>Control</keycap
> <keycap
>Alt</keycap
> <keycap
>Delete</keycap
></keycombo
> 키를 눌러도 컴퓨터를 다시 시작하지 않으므로, <quote
>하드</quote
> 리부팅을 권장합니다. 기존 운영 체제에서 설치하는 경우에는 (예를 들어 DOS에서) 다른 방법이 없습니다. 그 외의 경우에는 항상 부팅할 때 하드 리부팅을 하십시오. </para
><para
>플로피 디스크를 읽게 됩니다. 그 다음에 부팅 플로피에 대해 소개하는 화면이 나오고 마지막에 <prompt
>boot:</prompt
> 프롬프트가 나옵니다. </para
><para
>&enterkey; 키를 누르면, <computeroutput
>Loading...</computeroutput
> 메세지 다음에, <computeroutput
>Uncompressing Linux...</computeroutput
>라고 나오고, 시스템의 하드웨어에 관한 여러가지 정보가 화면 가득히 나옵니다. 이 부팅 과정에 대한 더 자세한 정보는 아래의 <xref linkend="kernel-msgs"/>에 있습니다. </para
><para
>부팅 플로피에서 부팅하면, 루트 플로피를 요청합니다. 루트 플로피를 넣고 &enterkey; 키를 누르십시오. 그러면 루트 플로피의 내용을 메모리로 읽어들입니다. 설치 프로그램 <command
>debian-installer</command
>를 자동으로 실행합니다. </para>
  </sect2>

  <sect2 arch="x86" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>i386에서 TFTP 부팅을 하려면 여러 가지 방법이 있습니다. </para>

   <sect3
><title
>PXE를 지원하는 NIC 혹은 마더보드</title>
<para
>네트워크 인터페이스 카드나 마더보드에서 PXE 부팅 기능을 지원할 수도 있습니다. PXE는 <trademark class="trade"
>인텔</trademark
>에서 TFTP 부팅을 다시 만든 것입니다. PXE를 지원하는 경우 네트워크 부팅을 하도록 BIOS를 설정할 수 있을 것입니다. </para>
   </sect3>

   <sect3
><title
>네트워크 부트롬이 들어 있는 NIC</title>
<para
>네트워크 인터페이스 카드에서 TFTP 부팅 기능을 지원할 수도 있습니다. </para
><para condition="FIXME"
>어떻게 했는지 알려 주십시오 (<email
>&email-debian-boot-list;</email
>). 이 문서를 언급해 주십시오. </para>
   </sect3>

   <sect3
><title
>Etherboot</title>
<para
><ulink url="http://www.etherboot.org"
>etherboot project</ulink
>에는 TFTPboot를 할 수 있는 부팅 디스켓과 부트롬이 있습니다. </para>
   </sect3>
  </sect2>

  <sect2 arch="x86" id="boot-screen">
  <title
>부팅 화면</title>
<para
>설치 프로그램이 부팅하면, 데비안 로고와 메뉴를 표시하는 친근한 그래픽 화면이 나타납니다: <informalexample
><screen>
Installer boot menu

Install
Graphical install
Advanced options       >
Help

Press ENTER to boot or TAB to edit a menu entry
</screen
></informalexample
> 사용하는 설치 방법에 따라 <quote
>Graphical install (그래픽 설치</quote
> 옵션은 사용할 수 없을 수도 있습니다. </para
><para
>일반적인 설치의 경우 <quote
>Install</quote
> 혹은 <quote
>Graphical install</quote
> 항목을 선택하십시오. 키보드의 화살표 키로 선택하거나 (강조되어 있는) 첫 글자를 누르고 &enterkey; 키를 누르면 설치 프로그램이 시작합니다. </para
><para
><quote
>Advanced options</quote
> 항목으로 들어가면 전문가 모드, 응급 모드, 자동 설치 관련 메뉴가 나타납니다. </para
><para
>설치 프로그램이나 커널에 부팅 파라미터를 추가하려면 &tabkey; 키를 누르십시오. 그러면 설치한 메뉴 항목의 기본 부팅 명령어가 나타나고, 여기에 추가 옵션을 입력할 수 있습니다. 도움말 화면에 (아래에서 설명합니다) 사용할 수 있는 일반적인 옵션 목록이 있습니다. &enterkey; 키를 누르면 해당 옵션에 따라 설치 프로그램이 시작하고, &escapekey; 키를 누르면 부팅 메뉴로 돌아가고 입력한 내용을 취소합니다. </para
><para
><quote
>Help</quote
> 항목을 선택하면 첫번째 도움말 화면이 나오고, 여기에는 전체 도움말 화면들에 대한 요약이 들어 있습니다. 도움말 화면이 나타나면 부팅 메뉴로 돌아갈 수 없습니다. 하지만 F3 및 F4 도움말 화면을 보면 부팅 메뉴에 들어 있는 부팅 방법과 동일한 명령어들이 설명되어 있습니다. 모든 도움말 화면에는 부팅 명령어를 입력할 수 있는 부팅 프롬프트가 들어 있습니다: <informalexample
><screen>
Press F1 for the help index, or ENTER to boot:
</screen
></informalexample
> 이 부팅 프롬프트에서 &enterkey; 키를 눌러서 기본 옵션으로 설치 프로그램을 시작할 수도 있고, 아니면 특정 부팅 명령어와 특정 부팅 파라미터를 지정할 수도 있습니다. 부팅 명령어에 사용할 수 있는 유용한 여러가지 부팅 파라미터가 도움말 화면에 설명되어 있습니다. 부팅 명령어에 파라미터를 입력하려면, 먼저 부팅 방법을 입력하고 (기본값은 <userinput
>install</userinput
>입니다.) 첫 파라미터 앞에 공백을 입력하십시오. (예를 들어, <userinput
>install fb=false</userinput
>) <note
><para
>이 시점에서 키보드는 기본 미국식 영어 키보드 배치라고 가정합니다. 즉 키보드가 (언어에 따라) 다른 키보드 배치일 수도 있습니다. 즉 화면에 나타나는 문자가 입력하려는 문자와 다를 수도 있습니다. 위키백과에 어떤 키를 누를 지 참고자료로 이용할 수 있는 <ulink url="&url-us-keymap;"
>미국식 키보드 배치 방식</ulink
>이 있습니다. </para
></note>
<note
><para
>사용하는 시스템에 시리얼 콘솔을 사용하도록 설정한 BIOS가 들어 있다면, 설치 프로그램이 부팅할 때 처음 그래픽 스플래시 화면을 보지 못할 것입니다. 부팅 메뉴를 보지 못할 수도 있습니다. 원격 관리 장치를 (VGA 콘솔의 텍스트 인터페이스를 제공하는 장치) 통해 시스템을 설치하는 경우에도 같은 일이 일어납니다. 이러한 장치는 예를 들어 컴팩의 <quote
>integrated Lights Out</quote
> (iLO) 및 HP의 <quote
>integrated Remote Assistant</quote
> (IRA) 따위가 있습니다. </para
><para
>그래픽 부팅 화면을 건너 뛰려면 보지 않고 &escapekey; 키를 눌러 텍스트 부팅 프롬프트를 나타나게 하거나, 아니면 (역시 보지 않고) <quote
>H</quote
> 다음에 &enterkey;를 눌러 위에서 설명한 <quote
>Help</quote
> 옵션으로 들어가면 됩니다. 그렇게 하면 키 입력이 프롬프트에 그대로 나타날 것입니다. 설치 프로그램의 뒤쪽에서 프레임버퍼를 사용하지 못하게 하려면, 도움말에 설명되어 있는 것처럼 부팅 프롬프트에 <userinput
>fb=false</userinput
> 파라미터도 추가해야 합니다. </para
></note>
</para>

  </sect2>
<!--   End of file boot-installer/x86.xml -->

<!-- Start of file boot-installer/ia64.xml -->
<!-- $Id: ia64.xml 43841 2007-01-04 01:45:08Z fjp $ -->

  <sect2 arch="ia64"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

  <note>
  <title
>CD 내용</title>

<para
>세 가지 종류의 데비안 설치 CD가 있습니다. <emphasis
>Business Card</emphasis
> CD는 작은 CD 미디어에 맞게 만든 최소한의 설치 미디어입니다. 베이스를 설치하고 쓸만한 시스템을 만들려면 네트워크 연결이 필요합니다. <emphasis
>Network Install</emphasis
> CD는 베이스 설치에 필요한 모든 패키지가 들어 있지만, 완전한 시스템에 필요한 추가 패키지를 설치하려면 데비안 미러 사이트에 네트워크로 연결해야 합니다. 데비안 CD 세트는 네트워크 접근 없이도 여러 가지 패키지를 완전히 설치할 수 있습니다. </para>
  </note>

<para
>IA-64 아키텍처에는 인텔에서 나온 차세대 Extensible Firmware Interface가 (EFI) 들어 있습니다. 전통적인 x86 BIOS는 파티션 테이블과 Master Boot Record (MBR) 외에는 부팅 장치에 대해 거의 아무것도 모르지만, EFI는 FAT16 혹은 FAT32 포맷된 디스크 파티션에 파일을 읽고 쓸 수 있습니다. 이 기능때문에 아주 복잡한 방법으로 시스템을 시작하는 과정도 단순하게 할 수 있습니다. EFI를 지원하는 시스템 부트로더 및 EFI 펌웨어는 컴퓨터를 부팅하는 데 필요한 파일을 저장하는 완전한 파일 시스템이 따로 있습니다. 즉 IA-64 시스템의 시스템 디스크에는 전통적인 시스템에서 쓰는 단순한 MBR이나 부트 블록이 아닌 EFI만 사용하는 전용 디스크 파티션이 있습니다. </para
><para
>데비안 설치 CD에는 작은 EFI 파티션이 들어 있어서, 거기에 <command
>ELILO</command
> 부트로더, 그 설정 파일, 설치 프로그램 커널, 파일 시스템(initrd)이 들어 있습니다. 시스템에도 부팅하는 데 필요한 파일이 들어 있는 EFI 파티션이 들어 있습니다. 이 파일은 아래에 설명한 방법으로 EFI Shell에서 읽을 수 있습니다. </para
><para
><command
>ELILO</command
>에서 실제로 시스템을 읽어들여서 시작하는 방법은 시스템 설치 프로그램과는 관련이 없습니다. 하지만 설치 프로그램에서 베이스 시스템을 설치하기 전에 EFI 파티션을 설정해야 합니다. 그렇지 않으면 <command
>ELILO</command
> 설치가 실패해서, 시스템을 부팅할 수 없게 됩니다. 설치할 때 패키지를 설치하기 전에 파티션하는 단계에서 EFI 파티션을 만들고 포맷하게 됩니다. 설치를 계속하기 전에 파티션 작업에서 EFI 파티션이 있는 지 검사도 합니다. </para
><para
>펌웨어 초기화의 마지막 단계에서 EFI 부트 매니저가 나타납니다. 메뉴 목록이 나와서 사용자가 그 중의 하나를 선택합니다. 시스템의 모델이 무엇이고 어떤 소프트웨어를 읽어들였느냐에 따라, 이 메뉴는 시스템마다 다릅니다. 최소한 두 개의 메뉴 항목이 있어야 합니다. <command
>Boot Option Maintenance Menu</command
> 및 <command
>EFI Shell (Built-in)</command
>입니다. 첫번째 옵션을 사용하는 게 좋지만, 그 옵션이 없거나 CD가 부팅하지 않는다면 두 번째 옵션을 사용하십시오. </para>

  <warning>
  <title
>중요</title>
<para
>EFI Boot Manager에서 정해진 몇 초가 지나면 기본 부팅 동작을 (보통 메뉴에서 첫번째) 선택합니다. 화면 아래의 카운트다운을 보면 알 수 있습니다. 타이머가 다 되면 기본 동작을 시작하고, 그러면 (설치하려면) 컴퓨터를 다시 부팅해야 할 수도 있습니다. 기본 액션이 EFI Shell인 경우 쉘 프롬프트에서 <command
>exit</command
> 명령을 실행해 Boot Manager로 돌아오십시오. </para>
  </warning>

  <sect3 arch="ia64" id="bootable-cd">
  <title
>방법 1: Boot Option Maintenance Menu에서 부팅</title>
 

<itemizedlist>

<listitem
><para
>CD를 DVD/CD 드라이브에 넣고 컴퓨터를 다시 부팅하십시오. 펌웨어가 시스템 초기화를 마치면 EFI Boot Manager 페이지와 메뉴를 표시합니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>Boot Maintenance Menu</command
>를 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 다른 메뉴가 나타납니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>Boot From a File</command
>을 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 펌웨어가 찾은 장치의 목록이 나옵니다. 메뉴에서 <command
>Debian Inst [Acpi ...</command
> 혹은 <command
>Removable Media Boot</command
>라고 되어 있는 두 줄이 나옵니다. 그 메뉴 항목의 나머지를 보면, 장치와 컨트롤러 정보가 같은 지 알 수 있습니다. </para
></listitem>

<listitem
><para
>CD/DVD 드라이브를 가리키는 어떤 항목이든 선택할 수 있습니다. 화살표 키로 선택해서 <command
>ENTER</command
>를 누릅니다. <command
>Removable Media Boot</command
>를 선택한 경우 컴퓨터가 즉시 부팅 단계로 들어갑니다. 그게 아니라 <command
>Debian Inst [Acpi ...</command
>를 선택한 경우, CD의 부팅 가능 영역 디렉토리의 내용을 표시하고, 다음 단계로 진행할 수 있습니다. </para
></listitem>

<listitem
><para
>이 단계는 <command
>Debian Inst [Acpi ...</command
>를 선택한 경우에만 필요합니다. 디렉토리 목록에서는 마지막 줄 다음에 <command
>[Treat like Removable Media Boot]</command
>도 표시합니다. 이 줄을 화살표로 선택해 <command
>ENTER</command
>를 누르십시오. 그러면 부팅 과정을 시작합니다. </para
></listitem>

</itemizedlist>

<para
>데비안 부트로더가 시작하고 부팅 커널과 옵션을 선택하는 메뉴 페이지를 표시합니다. 계속해서 부팅 커널과 옵션을 선택하십시오. </para>
  </sect3>

  <sect3 arch="ia64" id="boot-with-efi">
  <title
>방법 2: EFI Shell에서 부팅</title>
<para
>어떤 이유에서든 방법 1이 실패하면, 컴퓨터를 다시 부팅하십시오. EFI Boot Manager 화면에서 <command
>EFI Shell [Built-in]</command
>이라는 옵션이 있습니다. 다음 과정을 통해 데비안 설치 CD를 부팅하십시오: </para>

<itemizedlist>

<listitem
><para
>CD를 DVD/CD 드라이브에 넣고 컴퓨터를 다시 부팅하십시오. 펌웨어가 시스템 초기화를 마치면 EFI Boot Manager 페이지와 메뉴가 나타납니다. </para
></listitem>

<listitem
><para
>메뉴에서 화살표로 <command
>EFI Shell</command
>을 선택하고 <command
>ENTER</command
>를 누르십시오. EFI Shell은 부팅 가능한 장치를 모두 검색하고 명령어 프롬프트 앞에 장치 목록을 표시합니다. 찾아낸 부팅 가능 파티션은 <filename
>fs<replaceable
>n</replaceable
>:</filename
> 식으로 이름을 표시합니다. 그 외에 찾아낸 파티션은 <filename
>blk<replaceable
>n</replaceable
>:</filename
> 모양입니다. CD를 넣은 경우 쉘에 들어가면서 CD 드라이브를 초기화하면서 몇 초가 더 걸릴 수 있습니다. </para>
</listitem>

<listitem
><para
>쉘에서 CD-ROM 드라이브를 찾을 때 출력을 잘 살펴보십시오. 다른 장치는 <filename
>fs<replaceable
>n</replaceable
></filename
>이라고 나올 때 CD-ROM 드라이브는 <filename
>fs0:</filename
>이라고 나올 것입니다. </para
></listitem>

<listitem
><para
><command
>fs<replaceable
>n</replaceable
>:</command
>이라고 입력하고 <command
>ENTER</command
>를 눌러 선택하십시오. 여기서 <replaceable
>n</replaceable
>은 CD-ROM의 파티션 번호입니다. 그러면 파티션 번호를 쉘의 프롬프트에 표시합니다. </para
></listitem>

<listitem
><para
><command
>elilo</command
>라고 입력하고 <command
>ENTER</command
>를 누르십시오. 그러면 부팅 과정을 시작합니다. </para
></listitem>

</itemizedlist>

<para
>방법 1과 마찬가지로, 데비안 부트로더가 시작하면 부트 커널과 옵션을 선택하는 메뉴 페이지를 표시합니다. 쉘 프롬프트에서 더 간단히 <command
>fs<replaceable
>n</replaceable
>:elilo</command
> 명령을 입력할 수도 있습니다. 계속해서 부팅 커널과 옵션을 선택하십시오. </para>

  </sect3>

  <sect3 arch="ia64" id="serial-console">
  <title
>시리얼 콘솔을 사용해 설치하기</title>

<para
>설치할 때 모니터와 키보드를 사용할 수도 있고 시리얼 연결을 사용할 수도 있습니다. 모니터/키보드 설정을 이용하려면, [VGA console]이 들어 있는 옵션을 선택하십시오. 시리얼 연결을 통해 설치하려면, [<replaceable
>BAUD</replaceable
> baud serial console]이 들어 있는 옵션을 선택하십시오. 여기서 <replaceable
>BAUD</replaceable
>는 시리얼 콘솔의 속도입니다. ttyS0 장치가 가장 일반적인 속도로 설정되어 있는 메뉴 항목이 이미 있습니다. </para
><para
>대부분의 경우, 설치 프로그램의 속도를 EFI 콘솔 연결과 같게 해야 합니다. 설정을 어떻게 해야 할 지 잘 모르겠다면, EFI 쉘에서 <command
>baud</command
> 명령으로 알아낼 수 있습니다. </para
><para
>사용하려는 시리얼 장치나 속도에 맞춰 설정된 옵션이 없다면, 기존 메뉴 옵션의 콘솔 설정을 바꿀 수 있습니다. 예를 들어, ttyS1 장치에 57600 baud 콘솔을 사용하려면, <classname
>Boot:</classname
> 텍스트 창에 <command
>console=ttyS1,57600n8</command
>이라고 입력하십시오. </para>

<note
><para
>대부분의 IA-64 컴퓨터는 기본 콘솔 설정이 9600bps로 되어 있습니다. 이 속도는 상당히 느려서, 기본 설치 과정에서 각 화면을 그릴 때 상당한 시간을 소모하게 됩니다. 설치 과정에서 사용하는 속도를 빠르게 하거나, 텍스트 모드 설치를 고려해 봐야 합니다. 텍스트 모드에서 설치를 시작하려면 <classname
>Params</classname
> 도움말 메뉴를 참고하십시오. </para
></note>

<warning
><para
>잘못된 콘솔 종류를 선택했다면, 커널을 선택하고 파라미터를 입력할 수는 있지만 커널이 시작하자 마자 화면과 입력이 멎어 버릴 것입니다. 그러면 다시 부팅해야 설치를 할 수 있습니다. </para
></warning>
  </sect3>

  <sect3 arch="ia64" id="kernel-option-menu">
  <title
>부팅 커널과 옵션 선택하기</title>

<para
>부트로더에서 메뉴 목록과 <classname
>Boot:</classname
> 프롬프트가 있는 텍스트 창을 표시합니다. 화살표 키로 메뉴의 항목을 선택할 수 있고 키보드로 입력한 텍스트도 텍스트 창에 나타납니다. 각 펑션 키를 누르면 도움말 화면도 나타납니다. <classname
>General</classname
> 도움말 화면은 메뉴 선택에 대해 설명하고 <classname
>Params</classname
> 화면은 일반적인 명령행 옵션에 대해 설명합니다. </para
><para
><classname
>General</classname
> 도움말 화면을 보면 설치하는 데 가장 적합한 커널과 설치 모드에 대한 설명이 있습니다. 또 아래의 <xref linkend="boot-parms"/>에 보면 <classname
>Boot:</classname
> 텍스트 창에서 입력할 수 있는 추가 파라미터에 대한 설명이 있습니다. 커널 버전은 설치 과정과 설치된 시스템 모두에 사용할 커널의 버전을 설정합니다. 그래서 설치할 때 커널 문제가 발생하면, 설치한 시스템에서도 같은 문제가 발생할 것입니다. 다음 두 단계에서 설치 모드를 선택하고 설치를 시작합니다: </para>

<itemizedlist>

<listitem
><para
>화살표 키로 가장 적합한 커널 버전과 설치 모드를 선택하십시오. </para
></listitem>

<listitem
><para
>키보드로 부팅 파라미터가 있으면 입력하십시오. 입력한 텍스트가 텍스트 창에 직접 표시됩니다. 여기에서 커널 파라미터를 지정합니다 (예를 들어 시리얼 콘솔 설정). </para
></listitem>

<listitem
><para
><command
>ENTER</command
>를 누르십시오. 그러면 커널을 읽어들여서 시작합니다. 커널에서 초기화 메세지를 표시한 다음에 데비안 설치 프로그램의 첫번째 화면이 나타납니다. </para
></listitem>

</itemizedlist>

<para
>다음 장으로 가서 언어 로캘, 네트워크, 디스크 파티션 설정을 계속 하십시오. </para>
  </sect3>
  </sect2>

  <sect2 arch="ia64" id="boot-tftp"
><title
>TFTP로 부팅하기</title>

<para
>네트워크에서 IA-64 시스템을 부팅하는 건 CD 부팅과 비슷합니다. 다른 점은 설치 커널을 읽어들이는 방법입니다. EFI Boot Manager는 네트워크에 있는 서버에서 프로그램을 읽어들여서 실행할 수 있습니다. 일단 설치 커널을 읽어들이고 실행하면, CD 설치와 마찬가지로 시스템 설치를 진행합니다. 차이점은 베이스 설치 패키지를 CD 드라이브가 아니라 네트워크에서 가져온다는 점입니다. </para>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>IA-64 시스템에서 네트워크 부팅은 두 가지 아키텍처 전용 작업이 필요합니다. 부팅 서버에서는 DHCP와 TFTP를 통해 <command
>elilo</command
>를 전송하도록 설정해야 합니다. 클라이언트에서는 EFI 부트 매니저가 네트워크에서 읽어들이게 하는 부팅 옵션을 정의해야 합니다. </para>

  <sect3 arch="ia64" id="boot-tftp-server">
  <title
>서버 설정하기</title>
<para
>IA-64 시스템에서 네트워크 부팅을 위한 TFTP 엔트리는 다음과 같습니다: <informalexample
><screen>
host mcmuffin {
        hardware ethernet 00:30:6e:1e:0e:83;
        fixed-address 10.0.0.21;
        filename "debian-installer/ia64/elilo.efi";
}
</screen
></informalexample
> 목표는 <command
>elilo.efi</command
>를 클라이언트에서 실행하는 것입니다. </para
><para
><filename
>netboot.tar.gz</filename
> 파일을 TFTP 서버의 루트에 쓸 디렉토리에 풀어 놓으십시오. TFTP 루트 디렉토리는 보통 <filename
>/var/lib/tftp</filename
> 및 <filename
>/tftpboot</filename
>입니다. 파일을 풀면 <filename
>debian-installer</filename
> 디렉토리 밑에 IA64 시스템용 부팅 파일이 들어 있습니다. </para
><para>

<informalexample
><screen
># cd /var/lib/tftp
# tar xvfz /home/user/netboot.tar.gz
./
./debian-installer/
./debian-installer/ia64/
[...]
</screen
></informalexample
> <filename
>netboot.tar.gz</filename
> 안에는, 대부분의 상황에서 동작하는 <filename
>elilo.conf</filename
> 파일이 들어 있습니다. 하지만 이 파일을 수정해야 하는 경우에는, <filename
>debian-installer/ia64/</filename
> 디렉토리 안에 있습니다. 각각의 클라이언트에 대해 다른 설정 파일을 이용하려면 파일 이름을 <filename
>elilo.conf</filename
> 대신에 클라이언트의 IP 주소를 16진수로 쓰고 <filename
>.conf</filename
>를 뒤에 붙이면 됩니다. 자세한 설명은 <classname
>elilo</classname
> 패키지에 들어 있는 문서를 참고하십시오. </para>
  </sect3>

  <sect3 arch="ia64" id="boot-tftp-client">
  <title
>클라이언트 설정하기</title>
<para
>TFTP 부팅을 지원하도록 클라이언트를 설정하려면, EFI를 부팅해서 <guimenu
>Boot Option Maintenance Menu</guimenu
>로 들어가십시오. <itemizedlist
> <listitem
><para
> 부팅 옵션을 추가하십시오. </para
></listitem
> <listitem
><para
> <guimenuitem
>Load File [Acpi()/.../Mac()]</guimenuitem
> 텍스트가 들어 있는 줄을 볼 수 있을 것입니다. 이런 항목이 여러 줄 있을 때, 부팅하려는 인터페이스의 MAC 주소가 들어 있는 항목을 선택하십시오. 화살표 키로 반전시킨 다음 Enter를 누르십시오. </para
></listitem
> <listitem
><para
> 그 항목을 <userinput
>Netboot</userinput
>와 같이 이름 짓고, 저장하고, 부팅 옵션 메뉴로 나가십시오. </para
></listitem
> </itemizedlist
> 이제 방금 만든 새로운 부팅 옵션을 볼 수 있을 것입니다. 그 옵션을 선택하면 DHCP 쿼리를 하고, 서버에서 <filename
>elilo.efi</filename
> 파일을 서버에서 가져옵니다. </para
><para
>부트로더에서 설정 파일을 다운로드하고 관련된 처리를 한 다음 프롬프트를 표시합니다. 여기까지 오면, CD 설치와 마찬가지로 설치를 진행합니다. 위에서와 같이 부트 옵션을 선택하시고 네트워크에서 커널 설치를 마치면, 데비안 설치 프로그램이 시작합니다. </para
><para
>다음 장으로 가서 언어 로캘, 네트워크, 디스크 파티션 설정을 계속 하십시오. </para>
  </sect3>
  </sect2>
<!--   End of file boot-installer/ia64.xml -->

<!-- Start of file boot-installer/m68k.xml -->
<!-- $Id: m68k.xml 45435 2007-02-26 18:29:36Z wouter $ -->

  <sect2 arch="m68k"
><title
>설치 방법 고르기</title>

<para
>몇몇 &arch-title; 서브 아키텍처는 2.4.x 아니면 2.2.x 리눅스 커널중에 하나를 선택해 부팅하는 옵션이 있습니다. 그렇게 선택할 수 있는 경우, 2.4.x 리눅스 커널을 선택하십시오. 2.4.x 리눅스 커널을 사용할 때 오히려 더 작은 메모리를 사용합니다. 2.2.x는 고정된 크기의 램디스크를 사용하고 2.4.x는 tmpfs를 사용하기 때문입니다. </para
><para
>2.2.x 커널을 사용한다면, &ramdisksize; 커널 파라미터를 설정할 필요가 있습니다. </para
><para
><userinput
>root=/dev/ram</userinput
>을 커널 파라미터로 사용하십시오. </para
><para
>문제가 있으면 <ulink url="&url-m68k-cts-faq;"
>cts's &arch-title; debian-installer FAQ</ulink
>를 참고하십시오. </para>

<itemizedlist>
	<listitem
><para
><xref linkend="m68k-boot-amiga"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-atari"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-bvme6000"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-mac"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-mvme"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boot-q40"/></para
></listitem>
</itemizedlist>


    <sect3 id="m68k-boot-amiga"
><title
>Amiga</title>
<para
>Amiga에서 설치하는 유일한 방법은 하드 드라이브입니다. (<xref linkend="m68k-boot-hd"/> 참고) <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para
><para
>현재 Amiga에서는 bogl이 동작하지 않습니다. bogl 오류가 있으면, 커널 파라미터에 <userinput
>fb=false</userinput
>를 포함해야 합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-atari"
><title
>Atari</title>
<para
>Atari용 설치 프로그램은 하드 드라이브에서 시작할 수도 있고 (<xref linkend="m68k-boot-hd"/> 참고) 플로피에서 시작할 수도 있습니다 (<xref linkend="boot-from-floppies"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para
><para
>현재 Atari에서는 bogl이 동작하지 않습니다. bogl 오류가 있으면, 커널 파라미터에 <userinput
>fb=false</userinput
>를 포함해야 합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-bvme6000"
><title
>BVME6000</title>
<para
>BVME6000용 설치 프로그램은 CD-ROM (<xref linkend="m68k-boot-cdrom"/> 참고), 플로피 (<xref linkend="boot-from-floppies"/> 참고), 혹은 네트워크에서 (<xref linkend="boot-tftp"/> 참고) 실행할 수 있습니다. </para>
    </sect3>

    <sect3 id="m68k-boot-mac"
><title
>매킨토시</title>
<para
>맥에서 사용할 수 있는 유일한 설치 방법은 하드 드라이브에서 설치하는 것입니다 (<xref linkend="m68k-boot-hd"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> 맥에서는 2.4.x 커널이 동작하지 않습니다. </para
><para
>53c9x 기반 SCSI 버스를 사용하는 경우, <userinput
>mac53c9x=1</userinput
> 커널 파라미터를 사용해야 할 수도 있습니다. Quadra 950처럼 그런 SCSI 버스가 두 개 있는 하드웨어의 경우 <userinput
>mac53c9x=2</userinput
> 파라미터를 사용해야 합니다. 이렇게 하지 않고 자동 검색을 켜려면 <userinput
>mac53c9x=-1,0</userinput
>으로 설정할 수 있습니다. 하지만 이렇게 하면 SCSI 연결 해제가 불가능할 수 있습니다. 하드 디스크가 하나 이상 있을 때 이 파라미터를 설정해야 합니다. 하드 디스크가 없는 경우, 설정하지 않아야 시스템이 더 빠르게 동작합니다. </para>
    </sect3>

    <sect3 id="m68k-boot-mvme"
><title
>MVME147 및 MVME16x</title>
<para
>MVME147 및 MVME16x용 설치 프로그램은 플로피 (<xref linkend="boot-from-floppies"/> 참고) 혹은 네트워크에서 (<xref linkend="boot-tftp"/> 참고) 설치할 수 있습니다. <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para>
    </sect3>

    <sect3 id="m68k-boot-q40"
><title
>Q40/Q60</title>
<para
>Q40/Q60에서 설치하는 유일한 방법은 하드 드라이브에서 설치하는 것입니다 (<xref linkend="m68k-boot-hd"/> 참고). <emphasis
>즉 CD-ROM에서 부팅할 수 없습니다.</emphasis
> </para>
    </sect3>

  </sect2>

  <sect2 arch="m68k" id="m68k-boot-hd"
><title
>하드 디스크에서 부팅하기</title>


<!-- Start of file boot-installer/intro-hd.xml -->
<!-- $Id: intro-hd.xml 28672 2005-06-26 10:06:30Z fjp $ -->

<para
>기존 운영 체제에서 부팅하는 게 가장 편리한 방법입니다. 몇몇 시스템의 경우에는 이게 유일한 설치 방법입니다. </para
><para
>하드 디스크에서 설치 프로그램을 부팅하려면, <xref linkend="boot-drive-files"/>에서 필요한 파일을 다운로드해서 하드 디스크에 저장해 놓습니다. </para>
<!--   End of file boot-installer/intro-hd.xml -->

<para
>하드 드라이브에서 부팅하려면 최소한 6가지의 램디스크를 사용할 수 있습니다. 2.2.x 리눅스 커널이 지원하는 3가지와 지원하지 않는 3가지가 있습니다. (자세한 설명은 <ulink url="&disturl;/main/installer-&architecture;/current/images/MANIFEST"
>MANIFEST</ulink
> 참고) </para
><para
>3가지 종류의 램 디스크는 <filename
>cdrom</filename
>, <filename
>hd-media</filename
>, <filename
>nativehd</filename
>입니다. 이 램디스크는 설치 패키지의 위치만 다릅니다. <filename
>cdrom</filename
> 램디스크는 debian-installer 패키지를 CD-ROM에서 가져옵니다. <filename
>hd-media</filename
> 램디스크는 하드 디스크에 들어 있는 CD-ROM의 ISO 이미지를 사용합니다. 마지막으로, <filename
>nativehd</filename
> 램디스크는 패키지를 설치하는 데 네트워크를 사용합니다. </para>

<itemizedlist>
	<listitem
><para
><xref linkend="m68k-boothd-amiga"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-atari"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-mac"/></para
></listitem>
	<listitem
><para
><xref linkend="m68k-boothd-q40"/></para
></listitem>
</itemizedlist>


    <sect3 id="m68k-boothd-amiga"
><title
>AmigaOS에서 부팅하기</title>
<para
><command
>Workbench</command
>에서는, <filename
>debian</filename
> 디렉토리 안의 <guiicon
>StartInstall</guiicon
> 아이콘을 두 번 눌러 리눅스 설치를 시작하십시오. </para
><para
>Amiga 설치 프로그램에서 디버깅 정보를 창에 출력하면 &enterkey;를 두 번 눌러야 합니다. 그 다음에 화면이 없어지면 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만 상관없습니다. 몇 초 후에 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>
    </sect3>


    <sect3 id="m68k-boothd-atari"
><title
>Atari TOS에서 부팅하기</title>
<para
>GEM 데스크탑에서, <filename
>debian</filename
> 디렉토리의 <guiicon
>bootstra.prg</guiicon
> 아이콘을 두 번 누르고 프로그램 옵션 대화 상자의 <guibutton
>Ok</guibutton
>를 눌러 리눅스 설치를 시작하십시오. </para
><para
>Atari 부팅 프로그램에서 디버깅 정보를 창에 출력하면 &enterkey;를 눌러야 합니다. 그 다음에 화면이 없어지면 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만 상관없습니다. 몇 초 후에 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>
    </sect3>


    <sect3 id="m68k-boothd-mac"
><title
>맥오에스에서 부팅하기</title>
<para
>원래의 맥 시스템을 유지하면서 그 시스템에서 부팅해야 합니다. 맥오에스가 부팅하면서 Penguin 리눅스 로더 부팅 준비를 할 때, <keycap
>shift</keycap
> 키를 눌러 확장 기능을 읽어들이지 않도록 해야 하는 게 <emphasis
>중요합니다</emphasis
>. 리눅스를 읽어들이는 것 이외에 맥오에스를 사용하지 않는다면, 맥의 시스템 폴더에서 모든 확장 기능과 컨트롤 패널을 지우면 됩니다. 그렇지 않으면 확장 기능을 실행해서 리눅스 커널 실행에 여러 가지 문제가 발생할 수 있습니다. </para
><para
>맥에서는 <command
>Penguin</command
> 부트로더가 필요합니다. 이 부트로더는 <ulink url="&url-m68k-mac;"
>리눅스/mac68k sourceforge.net 프로젝트</ulink
>에서 다운로드할 수 있습니다. <command
>Stuffit</command
> 아카이브를 처리할 수 있는 프로그램이 없다면, 무슨 아키텍처이든 GNU/리눅스 컴퓨터에서 <classname
>hfsutils</classname
>에 들어 있는 <command
>hmount</command
>, <command
>hcopy</command
>, <command
>humount</command
> 명령어를 이용해 해당 아카이브를 맥오에스 포맷한 플로피에 넣으십시오. </para
><para
>맥오에스 데스크탑에서는 <filename
>Penguin</filename
> 디렉토리 안의 <guiicon
>Penguin Prefs</guiicon
> 아이콘을 두 번 눌러 리눅스 설치를 시작하십시오. <command
>Penguin</command
> 부팅 프로그램이 시작합니다. <guimenu
>File</guimenu
> 메뉴에서 <guimenuitem
>Settings</guimenuitem
> 항목으로 가서, <guilabel
>Kernel</guilabel
> 탭을 누르십시오. 커널과 (<filename
>vmlinuz</filename
>) 램디스크 (<filename
>initrd.gz</filename
>) 이미지를 <filename
>install</filename
> 디렉토리에서 위의 오른쪽의 해당 단추를 눌러 선택하십시오. 그리고 파일 선택 대화 상자를 이용해 파일을 찾으십시오. </para
><para
>Penguin에서 부팅 파라미터를 설정하려면, <guimenu
>File</guimenu
> -&gt; <guimenuitem
>Settings...</guimenuitem
>을 선택하시고, <guilabel
>Options</guilabel
> 탭으로 바꾸십시오. 텍스트 입력 창에서 부팅 파라미터를 입력할 수 있습니다. 항상 그 설정을 이용하려면, <guimenu
>File</guimenu
> -&gt; <guimenuitem
>Save Settings as Default</guimenuitem
>를 선택하십시오. </para
><para
><guilabel
>Settings</guilabel
> 대화 상자를 닫고, 설정을 저장하고 <guimenu
>File</guimenu
> 메뉴의 <guimenuitem
>Boot Now</guimenuitem
> 항목을 이용해 부팅을 시작하십시오. </para
><para
><command
>Penguin</command
> 부팅 프로그램에서 디버깅 정보를 창에 출력합니다. 그 다음에 화면이 회색으로 변하고, 몇 초간 딜레이가 있을 것입니다. 그 다음에 흰 글자의 검은 화면이 나타나고, 커널 디버깅 정보를 표시합니다. 이 메세지는 읽기에는 너무 빠르게 스크롤 되겠지만, 상관없습니다. 몇 초 후에, 설치 프로그램이 자동으로 시작하고, <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>

    </sect3>

    <sect3 id="m68k-boothd-q40"
><title
>Q40/Q60에서 부팅하기</title>

<para
>FIXME </para
><para
>설치 프로그램이 자동으로 시작합니다. <xref linkend="d-i-intro"/> 부분으로 넘어가실 수 있습니다. </para>

    </sect3>
  </sect2>


  <sect2 arch="m68k" id="m68k-boot-cdrom"
><title
>CD-ROM에서 부팅하기</title>
<para
>현재 CD-ROM 부팅을 지원하는 &arch-title; 서브 아키텍처는 BVME6000뿐입니다. </para>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

  </sect2>


  <sect2 arch="m68k" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>VMEbus 시스템이 부팅하면, LILO <prompt
>Boot:</prompt
> 프롬프트가 나타납니다. 프롬프트에서 다음 중의 하나를 입력하면 리눅스를 부팅하고 vt102 터미널 에뮬레이션을 이용해 데비안 설치를 시작합니다: <itemizedlist>
<listitem
><para
>BVME4000/6000에 설치하려면 <screen
>i6000 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
<listitem
><para
>MVME162에 설치하려면 <screen
>i162 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
<listitem
><para
>MVME166/167에 설치하려면 <screen
>i167 &enterkey;</screen
>라고 입력하십시오 </para
></listitem>
    </itemizedlist>

</para
><para
>vt100 터미널 에뮬레이션을 이용하려면 <screen
>TERM=vt100</screen
> 파라미터를 붙일 수 있습니다. 예를 들어, <screen
>i6000 TERM=vt100 &enterkey;</screen
>. </para>
  </sect2>


  <sect2 arch="m68k" id="boot-from-floppies">
  <title
>플로피에서 부팅하기</title>
<para
>대부분의 &arch-title; 아키텍처의 경우, 로컬 파일 시스템에서 부팅하는 게 가장 권장하는 방법입니다. </para
><para
>부트 플로피에서 부팅은 현재 Atari와 VMW에서만 (VME의 경우 SCSI 플로피 드라이브가 있으면) 동작합니다. </para>
 </sect2>
<!--   End of file boot-installer/m68k.xml -->

<!-- Start of file boot-installer/mips.xml -->
<!-- $Id: mips.xml 35613 2006-03-19 04:18:28Z tbm $ -->


  <sect2 arch="mips" id="boot-tftp"
><title
>TFTP로 부팅하기</title>

   <sect3>
   <title
>SGI TFTP 부팅</title>
<para
>SGI 컴퓨터에서 리눅스를 부팅하고 데비안의 설치를 시작하려면 커맨드 모니터로 들어간 다음 다음 명령을 사용하십시오: <informalexample
><screen>
bootp():
</screen
></informalexample
> 이렇게 하려면, <envar
>netaddr</envar
> 환경 변수를 지워야 할 수도 있습니다. 지우려면 커맨드 모니터에서 다음 명령을 타이프하십시오: <informalexample
><screen>
unsetenv netaddr
</screen
></informalexample
> </para>
  </sect3>

   <sect3>
   <title
>Broadcom BCM91250A 및 BCM9140B TFTP 부팅</title>
<para
>Broadcom BCM91250A 과 BCM9140B 평가보드에서는 TFTP를 통해 SiByl 부트로더를 읽어들입니다. 그러면 데비안 설치 프로그램을 읽어들여서 시작합니다. 보통 DHCP를 통해 IP 주소를 받지만 고정 주소를 설정할 수도 있습니다. DHCP를 사용하려면, CFE 프롬프트에서 다음 명령을 입력하십시오: <informalexample
><screen>
ifconfig eth0 -auto
</screen
></informalexample
> IP 주소를 받으면, 다음 명령으로 SiByl을 읽어들일 수 있습니다: <informalexample
><screen>
boot 192.168.1.1:/boot/sibyl
</screen
></informalexample
> 위의 예에서 IP 주소는 TFTP 주소의 이름 혹은 IP 주소로 바꿔야 합니다. 일단 이 명령을 실행하면, 설치 프로그램을 자동으로 읽어들입니다. </para>
</sect3>
  </sect2>

  <sect2 arch="mips"
><title
>부팅 파라미터</title>

   <sect3>
   <title
>SGI TFTP 부팅</title>
<para
>SGI에서는 커맨드 모니터에서 부팅 파라미터를 <command
>bootp():</command
> 명령어 뒤에 붙일 수 있습니다. </para
><para
>bootp/dhcp 서버에서 부팅할 파일을 지정하지 않았다면, <command
>bootp():</command
> 명령 뒤에 부팅할 파일의 경로와 이름을 지정할 수 있습니다. 예를 들어: <informalexample
><screen>
bootp():/boot/tftpboot.img
</screen
></informalexample
> 그 외의 커널 파라미터는 <command
>append</command
>를 통해 넘길 수 있습니다: <informalexample
><screen
>bootp(): append="root=/dev/sda1"
</screen
></informalexample>

</para>
  </sect3>

   <sect3>
   <title
>Broadcom BCM91250A 및 BCM9140B TFTP 부팅</title>
<para
>CFE 프롬프트에서는 부팅 파라미터를 직접 넘길 수 없습니다. 대신에 TFTP 서버에 있는 <filename
>/boot/sibyl.conf</filename
> 파일을 편집해서 <replaceable
>extra_args</replaceable
> 변수에 파라미터를 추가해야 합니다. </para>
  </sect3>

  </sect2>
<!--   End of file boot-installer/mips.xml -->

<!-- Start of file boot-installer/mipsel.xml -->
<!-- $Id: mipsel.xml 35612 2006-03-19 03:34:30Z tbm $ -->

  <sect2 arch="mipsel" id="boot-tftp"
><title
>TFTP로 부팅하기</title>

   <sect3>
   <title
>Cobalt TFTP 부팅</title>
<para
>엄격히 말해서 Cobalt는 TFTP를 사용하지 않습니다. 대신 NFS를 이용해서 부팅합니다. NFS 서버를 설치하고 설치프로그램 파일을 <filename
>/nfsroot</filename
>에 놓아야 합니다. Cobalt가 부팅할 때 왼쪽과 오른쪽 커서 단추를 동시에 누르면 NFS에서 네트워크 부팅을 합니다. 그러면 화면에 여러 옵션이 나타납니다. 다음 두 가지 설치 방법이 있습니다: <itemizedlist>
<listitem
><para
>SSH 이용 (기본값): 이 경우 설치 프로그램은 DHCP를 이용해서 네트워크를 설정하고 SSH 서버를 시작합니다. Cobalt LCD에 임의의 암호와 기타 로그인 정보(IP 주소 등)를 표시합니다. SSH 클라이언트를 이용해 컴퓨터에 접속하면 설치를 시작할 수 있습니다. </para
></listitem>
<listitem
><para
>시리얼 콘솔 이용: 널모뎀 케이블을 이용하면 Cobalt 컴퓨터의 시리얼 포트로 (115200 bps 속도) 접속해 설치를 할 수 있습니다. 이 옵션은 Qube 2700 (Qube1) 컴퓨터에서 사용할 수 없습니다. 이 컴퓨터에는 시리얼 포트가 없습니다. </para
></listitem>
</itemizedlist>

</para>
  </sect3>

   <sect3>
<!-- Note to translators: this is the same section as in mips.xml -->
   <title
>Broadcom BCM91250A 및 BCM9140B TFTP 부팅</title>
<para
>Broadcom BCM91250A 과 BCM9140B 평가보드에서는 TFTP를 통해 SiByl 부트로더를 읽어들입니다. 그러면 데비안 설치 프로그램을 읽어들여서 시작합니다. 보통 DHCP를 통해 IP 주소를 받지만 고정 주소를 설정할 수도 있습니다. DHCP를 사용하려면, CFE 프롬프트에서 다음 명령을 입력하십시오: <informalexample
><screen>
ifconfig eth0 -auto
</screen
></informalexample
> IP 주소를 받으면, 다음 명령으로 SiByl을 읽어들일 수 있습니다: <informalexample
><screen>
boot 192.168.1.1:/boot/sibyl
</screen
></informalexample
> 위의 예에서 IP 주소는 TFTP 주소의 이름 혹은 IP 주소로 바꿔야 합니다. 일단 이 명령을 실행하면, 설치 프로그램을 자동으로 읽어들입니다. </para>
</sect3>
  </sect2>

  <sect2 arch="mipsel"
><title
>부팅 파라미터</title>

   <sect3>
   <title
>Cobalt TFTP 부팅</title>
<para
>CFE 프롬프트에서는 부팅 파라미터를 직접 넘길 수 없습니다. 대신, NFS 서버에서 <filename
>/nfsroot/default.colo</filename
>을 편집해서 <replaceable
>args</replaceable
>에 파라미터를 추가하면 됩니다. </para>
  </sect3>

   <sect3>
<!-- Note to translators: this is the same section as in mips.xml -->
   <title
>Broadcom BCM91250A 및 BCM9140B TFTP 부팅</title>
<para
>CFE 프롬프트에서는 부팅 파라미터를 직접 넘길 수 없습니다. 대신에 TFTP 서버에 있는 <filename
>/boot/sibyl.conf</filename
> 파일을 편집해서 <replaceable
>extra_args</replaceable
> 변수에 파라미터를 추가해야 합니다. </para>
  </sect3>

  </sect2>
<!--   End of file boot-installer/mipsel.xml -->

<!-- Start of file boot-installer/s390.xml -->
<!-- $Id: s390.xml 43745 2007-01-01 13:52:38Z fjp $ -->

  <sect2 arch="s390"
><title
>s390 한계</title>
<para
>S/390에서 설치 시스템을 실행하려면 제대로 동작하는 네트워크 설정이 있어야 하고 SSH 세션이 필요합니다. </para
><para
>부팅 과정은 몇 가지 네트워크 파라미터를 설정하는 네트워크 설정으로 시작합니다. 설정이 성공하면, SSH 세션으로 로그인해서 거기에서 표준 설치 시스템을 시작합니다. </para>
  </sect2>


  <sect2 arch="s390"
><title
>s390 부팅 파라미터</title>
<para
>S/390에서는 parm 파일에 부팅 파라미터를 추가할 수 있습니다. ASCII나 EBCDIC 형식을 쓸 수 있습니다. 설치 이미지에 예제 parm 파일 <filename
>parmfile.debian</filename
>이 들어 있습니다. </para>
  </sect2>
<!--   End of file boot-installer/s390.xml -->

<!-- Start of file boot-installer/powerpc.xml -->
<!-- $Id: powerpc.xml 56248 2008-10-03 17:07:28Z fjp $ -->

  <sect2 arch="powerpc" id="boot-cd"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>현재, &arch-title; 서브 아키텍처중에서 CD-ROM 부팅을 지원하는 경우는 PReP (일부 지원하지 않는 시스템도 있습니다) 및 뉴월드 파워맥뿐입니다. 파워맥에서 CD-ROM 부팅을 하려면, <keycap
>c</keycap
> 키를 누르고 있거나, <keycap
>Command</keycap
>, <keycap
>Option</keycap
>, <keycap
>Shift</keycap
>, <keycap
>Delete</keycap
> 키를 동시에 누르고 있으십시오. </para
><para
>올드월드 파워맥은 데비안 CD를 부팅하지 못합니다. 올드월드 컴퓨터는 CD에 있는 맥오에스 ROM CD 부트 드라이버에 의존하기 때문입니다. 그리고 이 드라이버는 자유 소프트웨어 버전이 없습니다. 모든 올드월드 시스템에는 플로피 드라이브가 있으므로, 이 플로피 드라이브로 설치 프로그램을 실행하십시오. 그 다음에 설치 프로그램에서 필요한 파일이 있으면 CD를 지정하십시오. </para
><para
>시스템이 CD-ROM에서 직접 부팅하지 못하는 경우에도, CD-ROM을 사용해 시스템을 설치할 수 있습니다. NewWorld에서는 OpenFirmware 명령을 이용해 CD-ROM을 수동으로 부팅할 수 있습니다. 하드디스크에 부팅하려면 <xref linkend="boot-newworld"/>에 있는 설명을 따라하십시오. 단 다음과 같이 CD에 있는 <command
>yaboot</command
> 경로를 사용하십시오 <informalexample
><screen
>0 &gt; boot cd:,\install\yaboot
</screen
></informalexample>

</para>
  </sect2>

  <sect2 arch="powerpc" id="install-drive">
  <title
>하드 디스크에서 부팅하기</title>


<!-- Start of file boot-installer/intro-hd.xml -->
<!-- $Id: intro-hd.xml 28672 2005-06-26 10:06:30Z fjp $ -->

<para
>기존 운영 체제에서 부팅하는 게 가장 편리한 방법입니다. 몇몇 시스템의 경우에는 이게 유일한 설치 방법입니다. </para
><para
>하드 디스크에서 설치 프로그램을 부팅하려면, <xref linkend="boot-drive-files"/>에서 필요한 파일을 다운로드해서 하드 디스크에 저장해 놓습니다. </para>
<!--   End of file boot-installer/intro-hd.xml -->

<!--
  <sect3
><title
>Booting CHRP from OpenFirmware</title>

<para>

  <emphasis
>Not yet written.</emphasis>

</para>
   </sect3>
-->

   <sect3
><title
>맥오에스에서 올드월드 파워맥 부팅하기</title>
<para
><xref linkend="files-oldworld"/>의 BootX를 설정하는 경우, BootX를 이용해 설치 시스템을 부팅할 수 있습니다. <guiicon
>BootX</guiicon
> 애플리케이션 아이콘을 두 번 누르십시오. <guibutton
>Options</guibutton
> 단추를 눌러 <guilabel
>Use Specified RAM Disk</guilabel
>를 선택하십시오. 그러면 <filename
>ramdisk.image.gz</filename
> 파일을 선택할 수 있습니다. 하드웨어에 따라서는 <guilabel
>No Video Driver</guilabel
> 체크박스를 선택해야 할 수도 있습니다. 그리고 <guibutton
>Linux</guibutton
> 단추를 눌러 맥오에스를 끝내고 설치 프로그램을 시작하십시오. </para>
   </sect3>


  <sect3 id="boot-newworld">
  <title
>OpenFirmware에서 뉴월드 맥 부팅하기</title>
<para
><xref linkend="files-newworld"/>의 <filename
>vmlinux</filename
>, <filename
>initrd.gz</filename
>, <filename
>yaboot</filename
>, <filename
>yaboot.conf</filename
> 파일을 HFS 파티션의 맨 위에 저장해 놓으십시오. 이제 OpenFirmware로 부팅해야 합니다. (<xref linkend="invoking-openfirmware"/> 참고.) 프롬프트에서 다음을 입력하십시오: <informalexample
><screen>
0 &gt; boot hd:<replaceable
>x</replaceable
>,yaboot
</screen
></informalexample
> 여기서 <replaceable
>x</replaceable
>를 커널과 yaboot 파일이 들어 있는 HFS 파티션의 파티션 번호로 바꾸시고, &enterkey;를 누르십시오. 일부 시스템에서는, <userinput
>hd:</userinput
> 대신에 <userinput
>ide0:</userinput
>을 써야 할 수도 있습니다. 몇 초 안에 yaboot 프롬프트를 볼 수 있을 겁니다 <informalexample
><screen>
boot:
</screen
></informalexample
> yaboot의 <prompt
>boot:</prompt
> 프롬프트에서 <userinput
>install</userinput
> 혹은 <userinput
>install video=ofonly</userinput
> 명령을 입력하고 &enterkey;를 누르십시오. <userinput
>video=ofonly</userinput
> 파라미터는 <userinput
>install</userinput
>이 동작하지 않을 때에 호환성을 최대화하기 위해 시도해 볼 수 있습니다. 그러면 데비안 설치 프로그램이 시작합니다. </para>
   </sect3>
  </sect2>

  <sect2 arch="powerpc" condition="bootable-usb" id="usb-boot">
  <title
>USB 메모리에서 부팅하기</title>
<para
>현재 뉴월드 파워맥 시스템은 USB 부팅을 지원한다고 알려져 있습니다. </para>

<para
><xref linkend="boot-usb-files"/>에 있는 모든 걸 준비해야 합니다. 매킨토시 시스템을 USB 메모리에서 부팅하려면, Open Firmware는 USB 저장 장치를 검색하지 않기 때문에 프롬프트를 직접 사용해야 합니다. <xref linkend="invoking-openfirmware"/> 부분을 참고하십시오. </para
><para
>장치 트리에서 USB 저장 장치가 나타나는 위치를 조정할 필요가 있습니다. 이 시점에서는 <command
>ofpath</command
>에서 자동으로 조정하지 못합니다. Open Firmware 프롬프트에서 <userinput
>dev / ls</userinput
> 및 <userinput
>devalias</userinput
> 명령으로 모든 장치와 장치 별명의 목록을 보십시오. 예를 들어 문서 저자의 시스템에는 <filename
>usb0/disk</filename
>, <filename
>usb0/hub/disk</filename
>, <filename
>/pci@f2000000/usb@1b,1/disk@1</filename
>, 그리고 <filename
>/pci@f2000000/usb@1b,1/hub@1/disk@1</filename
>이 동작하고 있습니다. </para
><para
>장치 경로를 조정하고 나면, 다음과 같은 명령으로 설치 프로그램을 시작하십시오: <informalexample
><screen>
boot <replaceable
>usb0/disk</replaceable
>:<replaceable
>2</replaceable
>,\\:tbxi
</screen
></informalexample
> 여기서 <replaceable
>2</replaceable
>는 앞에서 부트 이미지를 복사해 놓은 Apple_HFS 혹은 Apple_Bootstrap 파티션이고, <userinput
>,\\:tbxi</userinput
> 부분은 전에 <command
>hattrib -b</command
> 해 놓은 디렉토리에 있는 "tbxi" 타입의 HFS 파일에서 (예를 들어 <command
>yaboot</command
>) 부팅하도록 Open Firmware에 알려 주는 역할을 합니다. </para
><para
>시스템이 부팅하고, <prompt
>boot:</prompt
> 프롬프트가 나타납니다. 여기서 다른 부팅 파라미터가 필요하면 입력하고, 아니면 그냥 &enterkey;를 누르십시오. </para
><warning
><para
>이 부팅 방법은 새로운 방법으로, 일부 NewWorld 시스템에서는 어려울 수도 있습니다. 문제가 있으면 설치 보고서를 <xref linkend="submit-bug"/>에 설명되어 있는 대로 제출해 주십시오. </para
></warning>
  </sect2>

  <sect2 arch="powerpc" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>현재 PReP 및 뉴월드 파워맥 시스템은 네트워크 부팅을 지원합니다. </para
><para
>뉴월드 파워맥과 같은 Open Firmware 컴퓨터에서는, 부트 모니터로 들어가서 (<xref linkend="invoking-openfirmware"/> 참고) 다음 명령을 사용하십시오: <informalexample
><screen>
0 &gt; boot enet:0
</screen
></informalexample
> 이 명령이 동작하지 않으면 다음과 같이 파일 이름을 추가해야 할 수도 있습니다: <informalexample
><screen>
0 &gt; boot enet:0,yaboot
</screen
></informalexample
> PReP 및 CHRP 컴퓨터는 네트워크 위치를 지정하는 방법이 다릅니다. PReP 컴퓨터에서는 다음과 같이 해 보십시오: <informalexample
><screen>
0 &gt; boot net:<replaceable
>서버IP주소</replaceable
>,<replaceable
>파일</replaceable
>,<replaceable
>클라이언트IP주소</replaceable>
</screen
></informalexample
> 일부 PReP 시스템에서는 (예를 들어 모토로라 PowerStack 컴퓨터) <userinput
>help boot</userinput
> 명령을 실행하면 사용 방법 및 사용할 수 있는 옵션 설명이 나옵니다. </para>
  </sect2>


  <sect2 arch="powerpc" condition="supports-floppy-boot">
  <title
>플로피에서 부팅하기</title>
<para
>플로피 부팅은 &arch-title;에서 지원하지만, 보통 올드월드 시스템에서만 사용 가능합니다. 뉴월드 시스템에는 플로피 드라이브가 없고, 부팅을 지원하지 않는 USB 플로피 드라이브만 붙어 있습니다. </para
><para
>필요한 플로피 이미지를 다운로드해서 <xref linkend="create-floppy"/>에서 설명한 대로 이미지를 플로피로 만듭니다. </para
><para
><filename
>boot-floppy-hfs.img</filename
> 플로피에서 부팅하려면, 시스템을 끄고 전원 단추를 누르기 전에 플로피를 드라이브에 넣으십시오. </para
><note
><para
>매킨토시 플로피 작업에 익숙하지 않은 분을 위해: 부팅하기 전에 넣은 플로피가 첫번째 부팅 우선 순위를 가집니다. 부팅 시스템이 없는 플로피는 튀어 나오게 되고, 부팅 가능한 하드 디스크 파티션을 찾게 됩니다. </para
></note
><para
>부팅한 다음 <filename
>root.bin</filename
> 플로피를 요청합니다. 루트 플로피를 넣고 &enterkey;를 누르십시오. 루트 시스템을 메모리에 읽어들이면 설치 프로그램을 자동으로 시작합니다. </para>
  </sect2>


  <sect2 arch="powerpc"
><title
>PowerPC 부팅 파라미터</title>
<para
>오래된 애플 모니터는 다수가 640x480 67Hz 모드를 사용합니다. 오래된 Apple 모니터에서 화면이 찌그러진다면, <userinput
>video=atyfb:vmode:6</userinput
> 부팅 파라미터를 추가해 보십시오. 그러면 대부분의 Mach64와 Rage 비디오 하드웨어에 맞는 비디오 모드를 선택합니다. Rage 128 하드웨어의 경우에는, <userinput
>video=aty128fb:videomode:6</userinput
>이라고 하십시오. </para>
  </sect2>
<!--   End of file boot-installer/powerpc.xml -->

<!-- Start of file boot-installer/sparc.xml -->
<!-- $Id: sparc.xml 58021 2009-03-30 16:53:10Z cjwatson $ -->

  <sect2 arch="sparc" id="boot-tftp"
><title
>TFTP로 부팅하기</title>


<!-- Start of file boot-installer/intro-net.xml -->
<!-- $Id: intro-net.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<para
>네트워크에서 부팅하려면, 네트워크에 연결되어 있어야 하고 TFTP 네트워크 부팅 서버가 (DHCP, RARP 혹은 BOOTP) 필요합니다. </para
><para arch="hppa"
>715처럼 오래된 시스템의 경우에는 BOOTP 서버 대신에 RBOOT 서버를 사용해야 할 수도 있습니다. </para
><para
>네트워크 부팅을 지원하는 설치 방법은 <xref linkend="install-tftp"/>에 설명되어 있습니다. </para>
<!--   End of file boot-installer/intro-net.xml -->

<para
>OpenBoot 컴퓨터의 경우, 설치하려는 컴퓨터의 부트 모니터로 들어가십시오 (<xref linkend="invoking-openboot"/>). <userinput
>boot net</userinput
> 명령으로 TFTP 및 RARP 서버에서 부팅하거나 <userinput
>boot net:bootp</userinput
>나 <userinput
>boot net:dhcp</userinput
> 명령으로 TFTP와 BOOTP 혹은 DHCP 서버에서 부팅하십시오. </para>
  </sect2>


  <sect2 arch="sparc"
><title
>CD-ROM에서 부팅하기</title>


<!-- Start of file boot-installer/intro-cd.xml -->
<!-- $Id: intro-cd.xml 39614 2006-08-07 15:50:11Z fjp $ -->

<para
>대부분 사람들에게 가장 쉬운 방법은 데비안 CD 세트를 이용하는 방법입니다. CD 세트를 가지고 있고, 컴퓨터에서 직접 CD 부팅을 할 수 있다면 매우 좋은 경우입니다. <phrase arch="x86"
><xref linkend="boot-dev-select"/>에 설명되어 있는 대로 CD에서 시스템을 부팅할 수 있도록 설정하고, </phrase
> CD를 넣은 다음, 다시 부팅하고, 다음 장으로 넘어가십시오. </para
><para
>일부 CD 드라이브의 경우에는 특별한 드라이버가 필요하므로, 설치 단계의 앞 부분에서는 CD 드라이브에 접근할 수 없을 수도 있습니다. 하드웨어에서 표준적인 방법의 CD 부팅이 동작하지 않는다면, 이 장을 다시 보시고, 이러한 경우에 동작하는 다른 커널 및 설치 방법을 읽어보십시오. </para
><para
>CD-ROM에서 부팅할 수 없는 경우에도, CD-ROM에서 데비안 시스템 구성 요소와 패키지를 설치할 수 있습니다. 일단 플로피같은 다른 미디어를 이용해 부팅하십시오. 운영 체제, 베이스 시스템 및 다른 추가 패키지를 설치할 때가 되면 설치 시스템을 CD-ROM 드라이브로 맞춰 놓으십시오. </para
><para
>부팅하는 데 문제가 있으면, <xref linkend="boot-troubleshooting"/> 부분을 참고하십시오. </para>
<!--   End of file boot-installer/intro-cd.xml -->

<para
>대부분의 OpenBoot 버전은 <userinput
>boot cdrom</userinput
> 명령을 지원합니다. 그러면 SCSI 장치의 6번 ID에서 (아니면 IDE 기반 시스템의 경우 secondary master에서) 부팅합니다. </para>
  </sect2>

  <sect2 arch="sparc"
><title
>IDPROM 메세지</title>
<para
><quote
>IDPROM</quote
> 관련 문제에 대한 메세지가 나오면서 부팅하지 못한다면, 펌웨어의 설정 정보가 들어 있는 NVRAM의 배터리가 방전된 경우일 수 있습니다. 자세한 정보는 <ulink url="&url-sun-nvram-faq;"
>Sun NVRAM FAQ</ulink
>를 참고하십시오. </para>
  </sect2>
<!--   End of file boot-installer/sparc.xml -->

 </sect1>


<!-- Start of file boot-installer/parameters.xml -->
<!-- $Id: parameters.xml 57693 2009-02-27 05:55:08Z cjwatson $ -->

 <sect1 id="boot-parms"
><title
>부팅 파라미터</title>
<para
>부팅 파라미터는 리눅스 커널 파라미터로 보통 주변 장치를 제대로 동작하도록 제어하는 데 이용합니다. 대부분 커널에서 주변 장치에 관한 정보를 자동으로 찾아 냅니다. 하지만 몇몇 경우에는 파라미터로 커널을 조금 도와줘야 합니다. </para
><para
>시스템을 첫번째로 부팅하는 경우라면, 기본 부팅 파라미터를 시도해 보시고 (즉 파라미터를 사용하지 않는 것) 제대로 동작하는 지 보십시오. 보통은 제대로 동작할 것입니다. 제대로 동작하지 않는 경우에 다시 부팅해서 하드웨어에 필요한 특별한 파라미터가 있는 지 찾아 보십시오. </para
><para
>부팅 파라미터에 관한 정보는 <ulink url="http://www.tldp.org/HOWTO/BootPrompt-HOWTO.html"
>Linux BootPrompt HOWTO</ulink
>에 (여러가지 보기드문 하드웨어에 대한 정보 포함) 있습니다. 여기서는 몇 가지 많이 이용하는 파라미터에 대한 대략만 다룹니다. 많이 발생하는 문제점 몇 개는 <xref linkend="boot-troubleshooting"/>에 들어 있습니다. </para
><para
>커널이 부팅할 때 다음과 같은 메세지가 나와야 합니다: <informalexample
><screen>
Memory:<replaceable
>avail</replaceable
>k/<replaceable
>total</replaceable
>k available 
</screen
></informalexample
> 여기서 <replaceable
>total</replaceable
>은 전체 RAM의 크기입니다(킬로바이트 단위). 이 숫자가 실제 설치한 RAM의 용량과 다르다면, <userinput
>mem=<replaceable
>ram</replaceable
></userinput
> 파라미터를 사용해야 합니다. 여기서 <replaceable
>ram</replaceable
>은 메모리의 양이고, 킬로바이트의 경우 <quote
>k</quote
>, 메가바이트의 경우 <quote
>m</quote
>을 뒤에 붙입니다. 예를 들어 <userinput
>mem=65536k</userinput
>나 <userinput
>mem=64m</userinput
>은 모두 64MB의 RAM을 뜻합니다. </para
><para condition="supports-serial-console"
>시리얼 콘솔로 부팅하는 경우, 보통 자동으로 찾아냅니다. 시리얼 콘솔로 부팅하려는 컴퓨터에 비디오 카드와 (프레임버퍼) 키보드가 붙어 있다면, <userinput
>console=<replaceable
>장치</replaceable
></userinput
> 파라미터를 커널에 넘겨야 할 수 있습니다. 여기서 <replaceable
>장치</replaceable
>는 시리얼 장치이고, <filename
>ttyS0</filename
>과 같이 씁니다. </para
><para arch="sparc"
>&arch-title;에서 시리얼 장치는 <filename
>ttya</filename
> 혹은 <filename
>ttyb</filename
>입니다. 다른 방법으로, <envar
>input-device</envar
> 및 <envar
>output-device</envar
> OpenPROM 변수를 <filename
>ttya</filename
>로 맞출 수도 있습니다. </para>


  <sect2 id="installer-args"
><title
>데비안 설치 프로그램 파라미터</title>
<para
>설치 시스템에서는 유용하게 쓸 수도 있는 부팅 파라미터 몇 개를 더 인식합니다<footnote
> <para
> 현재 커널에서는 (2.6.9 이후) 32개의 명령행 옵션과 32개의 환경변수를 사용할 수 있습니다. 이 개수를 넘어가면 커널은 멎어 버립니다. </para
> </footnote
>. </para
><para
>여러가지 파라미터는 <quote
>짧은 형식</quote
>이 있어서 커널 명령행의 길이 제한을 피하면서 쉽게 입력할 수 있습니다. 어떤 파라미터에 짧은 형식이 있는 경우에는, (일반적인) 긴 형식 뒤에 괄호 안에 써 놓았습니다. 이 안내서에 들어 있는 예제에서도 짧은 형식을 사용합니다. </para>

<variablelist>
<varlistentry>
<term
>debconf/priority (priority)</term>
<listitem
><para
>이 파라미터는 표시할 메시지의 가장 낮은 우선순위를 설정합니다. </para
><para
>기본 설치에서는 <userinput
>priority=high</userinput
>를 사용합니다. 즉, 높음 우선 순위와 필수 우선순위의 메세지를 표시하지만, 보통과 낮음 우선 순위 메세지는 넘어갑니다. 문제가 발생할 경우에는 설치 프로그램에서 우선순위를 필요에 따라 조정합니다. </para
><para
><userinput
>priority=medium</userinput
>을 부팅 파라미터로 쓴 경우, 설치 메뉴에서 설치 메뉴에서 더 많은 조정을 할 수 있습니다. <userinput
>priority=low</userinput
>라고 쓴 경우, 모든 메세지를 볼 수 있습니다. (<emphasis
>expert</emphasis
> 부팅 방법과 동일합니다.) <userinput
>priority=critical</userinput
>의 경우, 필수 메세지만 표시하고 질문에 신경 쓰지 않고 설치를 진행합니다. </para
></listitem>
</varlistentry>


<varlistentry>
<term
>DEBIAN_FRONTEND</term>
<listitem
><para
>이 부팅 파라미터는 설치 프로그램에서 사용할 사용자 인터페이스 종류를 설정합니다. 현재 가능한 파라미터 값은: <itemizedlist
> <listitem
> <para
><userinput
>DEBIAN_FRONTEND=noninteractive</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=text</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=newt</userinput
></para
> </listitem
><listitem
> <para
><userinput
>DEBIAN_FRONTEND=gtk</userinput
></para
> </listitem
> </itemizedlist
> 기본 프론트엔드는 <userinput
>DEBIAN_FRONTEND=newt</userinput
>입니다. 시리얼 콘솔 설치의 경우 <userinput
>DEBIAN_FRONTEND=text</userinput
>가 더 좋을 수도 있습니다. 보통 기본 설치 미디어에서는 <userinput
>newt</userinput
> 프론트엔드만 사용할 수 있습니다. 그래픽을 지원하는 아키텍처에서는, 그래픽 설치 프로그램은 <userinput
>gtk</userinput
> 프론트엔드를 사용합니다. </para
></listitem>
</varlistentry>


<varlistentry>
<term
>BOOT_DEBUG</term>
<listitem
><para
>이 부트 파라미터를 2로 설정하면 설치프로그램의 부트 절차를 자세하게 기록할 것입니다. 이 값을 3으로 지정하면 부트 프로세스의 전략적인 부분에서 디버깅 쉘을 동작합니다. (부팅을 계속하려면 이 쉘을 끝내십시오.) <variablelist>
<varlistentry>
<term
><userinput
>BOOT_DEBUG=0</userinput
></term>
<listitem
><para
>기본값입니다.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=1</userinput
></term>
<listitem
><para
>보통때보다 많은 디버깅 정보.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=2</userinput
></term>
<listitem
><para
>디버깅 정보 아주 많이.</para
></listitem>
</varlistentry>

<varlistentry>
<term
><userinput
>BOOT_DEBUG=3</userinput
></term>
<listitem
><para
>부팅 과정의 곳곳에서 쉘을 실행해서 자세히 디버깅을 할 수 있습니다. 부팅을 계속하려면 쉘을 나가면 됩니다. </para
></listitem>
</varlistentry>
</variablelist>

</para
></listitem>
</varlistentry>


<varlistentry>
<term
>INSTALL_MEDIA_DEV</term>
<listitem
><para
>이 파라미터의 값은 데비안 설치 프로그램을 읽어들일 장치의 경로입니다. 예를 들어 <userinput
>INSTALL_MEDIA_DEV=/dev/floppy/0</userinput
> </para
><para
>부팅 플로피는 루트 플로피를 찾으면서, 검색할 수 있는 모든 플로피 장치를 검색합니다. 이 파라미터를 재지정해서 장치 한 개만 검색하도록 만들 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>lowmem</term>
<listitem
><para
>사용 가능한 메모리에 따라 저용량 메모리를 판단하는 기준을 설치 프로그램의 기본값보다 높게 만드는 데 사용합니다. 쓸 수 있는 값은 1과 2입니다. <xref linkend="lowmem"/> 부분도 참고하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>debian-installer/framebuffer (fb)</term>
<listitem
><para
>어떤 아키텍처에서는 커널 프레임 버퍼를 사용해 여러 가지 언어로 설치를 지원합니다. 프레임버퍼가 문제가 있는 경우 <userinput
>fb=false</userinput
> 파라미터를 통해 프레임버퍼를 끌 수 있습니다. 문제의 증상은 bterm이나 bogl 관련된 오류 메세지, 검은 화면, 설치를 시작하고 몇 분 후에 멈추는 증상입니다. </para
><para arch="x86"
><userinput
>video=vga16:off</userinput
> 파라미터로 커널이 프레임버퍼를 사용하지 않도록 만들 수 있습니다. 그러한 문제는 Mobile Radeon 카드를 사용하는 Dell Inspiron에서 보고되었습니다. </para
><para arch="m68k"
>Amiga 1200과 SE/30에서 그러한 문제가 보고되었습니다. </para
><para arch="hppa"
>hppa에서 그러한 문제가 보고되었습니다. </para
><note arch="sparc"
><para
>일부 시스템의 화면 표시 문제때문에, &arch-title;에서는 프레임 버퍼를 <emphasis
>기본으로 지원하지 않습니다</emphasis
>. 그 때문에 ATI 그래픽 카드같은 게 있어서 프레임버퍼를 지원하는 시스템에서 조차 화면 표시가 보기가 안 좋을 수도 있습니다. 설치 프로그램에서 화면 표시 문제가 발생하면, <userinput
>debian-installer/framebuffer=true</userinput
> 혹은 짧은 형식으로 <userinput
>fb=true</userinput
> 파라미터를 넣고 부팅해 보십시오. </para
></note
></listitem>
</varlistentry>

<varlistentry arch="not-s390">
<term
>debian-installer/theme (theme)</term>
<listitem
><para
>테마는 설치 프로그램의 사용자 환경(색, 아이콘 등)을 어떻게 보여줄 것인가를 결정합니다. 프론트엔드에 따라 사용할 수 있는 테마가 달라집니다. 현재 newt와 gtk 프론트엔드에서는 시각장애인을 위한 <quote
>dark</quote
>테마만 있습니다. 이 테마를 설정하려면 부팅할 때 <userinput
>theme=<replaceable
>dark</replaceable
></userinput
>를 파라미터로 넘기면 됩니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>netcfg/disable_dhcp</term>
<listitem
><para
>기본값으로 &d-i;는 DHCP를 통해 네트워크 설정을 검색합니다. 검색이 성공하면 그 설정을 검사하거나 바꿀 기회가 없습니다. DHCP 검색이 실패할 경우에만 수동 네트워크 셋업을 할 수 있습니다. </para
><para
>로컬 네트워크에 DHCP 서버가 있지만 DHCP를 사용하고 싶지 않을 때 (예를 들어 잘못된 응답을 한다든지 때문에), <userinput
>netcfg/disable_dhcp=true</userinput
> 파라미터를 사용하면 DHCP 네트워크 설정을 막고 수동으로 정보를 입력할 수 있습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>hw-detect/start_pcmcia</term>
<listitem
><para
>PCMCIA에 문제가 있을 때 <userinput
>false</userinput
>로 하면 PCMCIA 서비스를 시작하지 않습니다. 일부 노트북 컴퓨터에서 이와 관련해 문제가 발생합니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>disk-detect/dmraid/enable (dmraid)</term>
<listitem
><para
><userinput
>true</userinput
>로 설정하면 설치 프로그램에서 시리얼 ATA RAID 디스크를 지원합니다. (ATA RAID, BIOS RAID, 가짜 RAID라고도 합니다.) 이 기능은 아직 실험적인 수준입니다. 더 자세한 내용은 <ulink url="&url-d-i-wiki;"
>Debian Installer Wiki</ulink
>를 참고하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>preseed/url (url)</term>
<listitem
><para
>미리 설정해 놓은 파일을 다운로드할 URL을 지정합니다. 이 파일을 이용해 설치를 자동화합니다. <xref linkend="automatic-install"/> 참고. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>preseed/file (file)</term>
<listitem
><para
>미리 설정해 놓은 파일을 읽어들일 URL을 지정합니다. 이 파일을 이용해 자동 설치를 합니다. <xref linkend="automatic-install"/> 참고. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>preseed/interactive</term>
<listitem
><para
>미리 설정을 했더라도 질문을 표시하려면 <userinput
>true</userinput
>로 설정하십시오. 미리 설정 파일을 테스트하거나 디버깅하는 데 좋습니다. 이 설정은 부팅 파라미터로 넘긴 파라미터에 대해서는 효과가 없으니 주의하십시오. 부팅 파라미터에 대해서는 특별한 문법을 따로 사용합니다. 자세한 정보는 <xref linkend="preseed-seenflag"/> 부분을 보십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>auto-install/enable (auto)</term>
<listitem
><para
>미리 설정이 가능하기 전에 물어보는 질문을 네트워크 설정 다음으로 미룹니다. 이 자동 설치 사용법에 대한 자세한 정보는 <xref linkend="preseed-auto"/> 부분을 보십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>finish-install/keep-consoles</term>
<listitem
><para
>시리얼 콘솔이나 관리 콘솔에서 설치하면, 일반 가상 콘솔은 (VT1-VT6) /etc/inittab에서 막습니다. 이 파라미터를 <userinput
>true</userinput
>로 하면 가상 콘솔을 막지 않습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>cdrom-detect/eject</term>
<listitem
><para
>기본값으로 &d-i;에서는 다시 시작하기 전에 설치할 때 사용했던 광학 미디어를 자동으로 뺍니다. 시스템이 CD에서 자동으로 부팅하는 경우가 아니라면 이럴 필요가 없을 수도 있습니다. 어떤 경우에는 이렇게 하지 않는 게 좋을 때도 있습니다. 예를 들어 해당 광학 드라이브가 미디어를 다시 집어넣지 못하는 경우나, 사용자가 그 자리에 없기 때문에 수동으로 미디어를 집어넣지 못하는 경우입니다. 보통 슬롯 방식 드라이브는 미디어를 자동으로 다시 집어넣지 못합니다. </para
><para
>자동으로 미디어를 꺼내지 않으려면 <userinput
>false</userinput
>로 설정합니다. 단 설치한 후에 시스템이 광학 드라이브에서 자동으로 부팅하지 않도록 하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>debian-installer/allow_unauthenticated</term>
<listitem
><para
>기본 설정으로 설치 프로그램에서 사용하는 저장소는 알려진 GPG 키를 이용해 인증할 수 있어야 합니다. 이 인증을 하지 않으려면 <userinput
>true</userinput
>로 설정하십시오. <emphasis role="bold"
>경고: 보안상 문제가 될 수 있으므로, 권장하지 않습니다.</emphasis
> </para
></listitem>
</varlistentry>

<varlistentry arch="alpha;m68k;mips;mipsel">
<term
>ramdisk_size</term>
<listitem
><para
>이 파라미터는 (필요한 경우) 이미 올바른 값으로 설정되어 있습니다. 램디스크를 완전히 읽어들이지 못해서 부팅이 실패했다는 오류를 본 경우에만 이 파라미터를 설정하십시오. 단위는 kB입니다. </para
></listitem>
</varlistentry>

<varlistentry condition="gtk">
<term
>mouse/protocol</term>
<listitem
><para
>gtk 프론트엔드의 (그래픽 설치 프로그램) 경우, 이 파라미터를 설정해 사용하려는 마우스 프로토콜을 지정할 수 있습니다. 지원하는 값은<footnote
> <para
>자세한 설명은 <citerefentry
><refentrytitle
>directfbrc</refentrytitle
> <manvolnum
>5</manvolnum
></citerefentry
> 맨페이지를 참고하십시오.</para
> </footnote
>: <userinput
>PS/2</userinput
>, <userinput
>IMPS/2</userinput
>, <userinput
>MS</userinput
>, <userinput
>MS3</userinput
>, <userinput
>MouseMan</userinput
>, <userinput
>MouseSystems</userinput
>입니다. 대부분의 경우 기본 프로토콜이 동작합니다. </para
></listitem>
</varlistentry>

<varlistentry condition="gtk">
<term
>mouse/device</term>
<listitem
><para
>gtk 프론트엔드의 (그래픽 설치 프로그램) 경우, 이 파라미터를 설정해 사용하려는 마우스 장치를 지정할 수 있습니다. 마우스가 시리얼 포트에 연결된 경우 (시리얼 마우스) 특히 필요합니다. 예를 들어: <userinput
>mouse/device=<replaceable
>/dev/ttyS1</replaceable
></userinput
>와 같이 사용합니다. </para
></listitem>
</varlistentry>

<varlistentry condition="gtk">
<term
>mouse/left</term>
<listitem
><para
>GTK 프론트엔드(그래픽 설치 프로그램)에서는, 마우스를 왼손잡이용으로 바꿀 수 있습니다. 이 파라미터를 <userinput
>true</userinput
>로 설정하면 됩니다. </para
></listitem>
</varlistentry>

<varlistentry condition="gtk">
<term
>directfb/hw-accel</term>
<listitem
><para
>GTK 프론트엔드(그래픽 설치 프로그램)에서는, 기본적으로 directfb의 하드웨어 가속 기능을 사용하지 않습니다. 가속 기능을 사용하려면 이 파라미터를 <userinput
>true</userinput
>로 설정하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>rescue/enable</term>
<listitem
><para
>일반적인 설치를 하지 않고 복구 모드로 변경하려면 <userinput
>true</userinput
>로 설정하십시오. <xref linkend="rescue"/> 부분을 참고하십시오. </para
></listitem>
</varlistentry>

</variablelist>

   <sect3 id="preseed-args">
   <title
>부팅 파라미터로 질문에 답하기</title>
<para
>일부 예외를 제외하고, 설치 과정에서 물어보는 모든 질문을 부팅 프롬프트에서 설정할 수 있습니다. (하지만 이 기능은 특수한 상황에서만 쓸모가 있습니다.) 이 기능을 사용하는 방법은 <xref linkend="preseed-bootparms"/> 부분을 참고하십시오. 몇 가지 예제가 아래에 있습니다. </para>

<variablelist>

<varlistentry>
<term
>debian-installer/locale (locale)</term>
<listitem
><para
>설치할 때 사용할 언어와 국가를 설정하는 데 사용합니다. 이 기능은 해당 로캘을 데비안에서 지원할 경우에만 동작합니다. 예를 들어 언어로 독일어, 국가로 스위스를 선택하려면 <userinput
>locale=de_CH</userinput
>를 사용하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>anna/choose_modules (modules)</term>
<listitem
><para
>기본값으로는 읽어들이지 않는 설치 프로그램 컴포넌트를 자동으로 읽어들이는 데 사용합니다. 유용한 추가 컴포넌트는 <classname
>openssh-client-udeb</classname
> (설치 도중에 <command
>scp</command
>를 사용할 수 있습니다)<phrase arch="not-s390"
> 및 <classname
>ppp-udeb</classname
>(<xref linkend="pppoe"/> 참고)</phrase
>이 있습니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>netcfg/disable_dhcp</term>
<listitem
><para
>DHCP를 끄고 강제로 고정 네트워크 설정을 하려면 <userinput
>true</userinput
>로 설정하십시오. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>mirror/protocol (protocol)</term>
<listitem
><para
>기본값으로 설치 프로그램은 데비안 미러에서 파일을 다운로드하는 HTTP 프로토콜을 사용하고, "보통" 우선순위에서는 설치 중에 프로토콜을 FTP로 바꿀 수 없습니다. 이 파라미터를 <userinput
>ftp</userinput
>로 설정하면, 설치 프로그램에서 해당 프로토콜을 HTTP 대신 사용합니다.  단 미러 목록에서 FTP 미러를 선택할 수는 없으므로, 수동으로 호스트 이름을 입력해야 합니다. </para
></listitem>
</varlistentry>

<varlistentry>
<term
>tasksel:tasksel/first (tasks)</term>
<listitem
><para
><literal
>kde-desktop</literal
> 태스크처럼 태스크 목록에 나타나지 않는 태스크를 선택할 때 사용합니다. 자세한 정보는 <xref linkend="pkgsel"/> 참고. </para
></listitem>
</varlistentry>

</variablelist>

   </sect3>

   <sect3 id="module-parms">
   <title
>커널 모듈에 파라미터 넘기기</title>
<para
>드라이버를 커널 안에 컴파일해 넣었다면, 커널 문서에 쓰여 있는 대로 파라미터를 넘길 수 있습니다. 하지만 드라이버를 모듈로 컴파일했다면 설치한 시스템에서는 부팅할 때 커널 모듈을 약간 다르게 읽어들이기 때문에, 일반적으로 하는 것처럼 모듈에 파라미터를 넘길 수 없게 됩니다. 그 대신에 설치 프로그램이 지원하는 특정 문법을 사용해 해당 파라미터를 올바른 설정 파일에 저장해 모듈을 읽어들일 때 사용하도록 만들 수 있습니다. 이 파라미터는 설치한 시스템의 설정에도 자동으로 적용됩니다. </para
><para
>한편 모듈에 파라미터를 넘겨야 하는 경우는 매우 드뭅니다. 보통 커널에서 시스템에 있는 하드웨어를 자동으로 찾아내서 쓸만한 기본값을 적용해 놓습니다. 하지만 일부 경우에는 파라미터를 수동으로 지정해야 할 수도 있습니다. </para
><para
>모듈의 파라미터를 설정하는 문법은 다음과 같습니다: <informalexample
><screen>
<replaceable
>모듈_이름</replaceable
>.<replaceable
>파라미터_이름</replaceable
>=<replaceable
>값</replaceable>
</screen
></informalexample
> 같은 모듈 혹은 여러 모듈에 여러 개의 파라미터를 넘기려면, 이 문법을 반복해서 쓰면 됩니다. 예를 들어 오래된 3Com 네트워크 인터페이스 카드에서 BNC (동축) 커넥터와 IRQ 10을 지정하려면, 다음과 같이 합니다: <informalexample
><screen
>3c509.xcvr=3 3c509.irq=10
</screen
></informalexample>

</para>
   </sect3>

   <sect3 id="module-blacklist">
   <title
>커널 모듈 블랙리스트</title>
<para
>경우에 따라서는 모듈을 블랙리스트에 올려서 커널이나 udev가 자동으로 읽어들이지 않게 만들어야 합니다. 이렇게 하는 이유의 한 가지는 특정 모듈이 해당 하드웨어에서 문제를 일으키는 경우입니다. 또 같은 장치에 대해서 두 개의 다른 드라이버가 있기도 합니다. 드라이버가 충돌하거나 잘못된 드라이버를 먼저 읽어들이면 해당 장치가 제대로 동작하지 않을 수 있습니다. </para
><para
>다음 문법으로 모듈을 블랙리스트에 올릴 수 있습니다: <userinput
><replaceable
>모듈_이름</replaceable
>.blacklist=yes</userinput
>. 이렇게 하면 해당 모듈을 <filename
>/etc/modprobe.d/blacklist.local</filename
>의 블랙리스트에 넣어서 설치 프로그램이나 설치한 시스템에 적용합니다. </para
><para
>설치 시스템이 모듈을 직접 읽어들이기도 합니다. 전문가 모드로 설치 프로그램을 시작해서 하드웨어 검색 단계에 나오는 모듈 목록에서 해당 모듈을 제외하면 모듈을 읽어들이지 않게 만들 수 있습니다. </para>
   </sect3>
  </sect2>
 </sect1>
<!--   End of file boot-installer/parameters.xml -->

<!-- Start of file boot-installer/trouble.xml -->
<!-- $Id: trouble.xml 56669 2008-11-17 22:21:26Z jfs $ -->

 <sect1 id="boot-troubleshooting">
 <title
>설치 과정의 문제 해결</title>
 

  <sect2 arch="not-s390" id="unreliable-cd">
  <title
>CD-ROM 신뢰성</title>
<para
>가끔 특히 오래 된 CD-ROM 드라이브의 경우, CD-ROM 부팅이 실패할 수도 있습니다. 심지어는 (CD-ROM에서 성공적으로 부팅한 경우에도) CD-ROM을 인식하지 못하거나 설치 도중에 CD-ROM을 읽으면서 오류가 발생하는 경우도 있습니다. </para
><para
>이러한 문제는 여러가지 원인이 있을 수 있습니다. 여기서는 일부 많이 발생하는 문제 및 각각의 경우 대처하는 방법을 설명합니다. 나머지는 여러분에게 맡깁니다. </para
><para
>제일 먼저 확인할 수 있는 간단한 일이 두 가지 있습니다. <itemizedlist>
<listitem
><para
>CD-ROM이 부팅하지 않으면, CD-ROM을 올바르게 넣었는지 그리고 혹시 CD-ROM 표면이 깨끗한지 확인하십시오. </para
></listitem>
<listitem
><para
>설치 프로그램이 CD-ROM을 인식하지 못하면, <menuchoice
> <guimenuitem
>CD-ROM 찾기 및 마운트</guimenuitem
> </menuchoice
> 옵션을 다시 한 번 실행해 보십시오. 오래 된 CD-ROM에서 발생하는 일부 DMA 관련 문제는 이런 식으로 해결된다고 알려져 있습니다. </para
></listitem>
</itemizedlist>

</para
><para
>이렇게 해도 해결되지 않으면, 아래에 나와 있는 방법들을 시도해 보십시오. 전부는 아니지만 대부분의 경우, 여기에 나와 있는 방법들은 CD-ROM과 DVD 모두에 적용되지만, 간략하게 하기 위해 CD-ROM이라는 용어만 사용합니다. </para
><para
>CD-ROM에서 설치할 수 없는 경우, 사용할 수 있는 다른 설치 방법을 시도해 보십시오. </para>

  <sect3>
  <title
>공통 사항</title>

<itemizedlist>
  <listitem
><para
>일부 오래 된 CD-ROM 드라이브는 최근의 CD 라이터에서 구운 디스크를 일지 못합니다. </para
></listitem>
  <listitem
><para
>시스템이 올바르게 CD-ROM에서 부팅한다고 해서, 리눅스가 그 CD-ROM을 (정확히 말해 해당 CD-ROM 드라이브가 연결된 컨트롤러를) 지원한다는 뜻은 아닙니다. </para
></listitem>
  <listitem
><para
>일부 오래 된 CD-ROM 드라이브는 <quote
>직접 메모리 접근</quote
> (DMA) 기능을 사용할 경우 올바르게 동작하지 않습니다. </para
></listitem>
</itemizedlist>

  </sect3>

  <sect3>
  <title
>문제점 파악 및 해결 방법</title>
<para
>CD-ROM 부팅이 실패하면, 아래에 나온 방법을 시도해 보십시오. <itemizedlist>
  <listitem
><para
>BIOS가 CD-ROM 부팅을 지원하는 지 확인하고 (오래 된 시스템은 지원하지 않을 수도 있습니다) CD-ROM 드라이브가 해당 미디어를 지원하는 지 확인하십시오. </para
></listitem>
  <listitem
><para
>ISO 이미지를 다운로드했다면, 그 이미지의 md5sum이 이미지를 받은 곳과 같은 곳에 있는 <filename
>MD5SUMS</filename
> 파일 안에 있는 md5sum과 일치하는 지 확인하십시오. <informalexample
><screen>
$ md5sum <replaceable
>debian-testing-i386-netinst.iso</replaceable>
a20391b12f7ff22ef705cee4059c6b92  <replaceable
>debian-testing-i386-netinst.iso</replaceable>
</screen
></informalexample
> 그 다음, 구운 CD-ROM의 md5sum이 일치하는 지도 확인하십시오. 다음 명령을 사용하면 됩니다. 이미지의 크기를 이용해서 지정한 바이트 수만큼 CD-ROM에서 읽어들입니다. <informalexample
><screen
>$ dd if=/dev/cdrom | \

> head -c `stat --format=%s <replaceable
>debian-testing-i386-netinst.iso</replaceable
>` | \

> md5sum
a20391b12f7ff22ef705cee4059c6b92  -
262668+0 records in
262668+0 records out
134486016 bytes (134 MB) copied, 97.474 seconds, 1.4 MB/s
</screen
></informalexample>

  </para
></listitem>
</itemizedlist>

</para
><para
>설치 프로그램이 성공적으로 부팅한 다음에 CD-ROM을 찾을 수 없는 경우, 한 번 다시 시도하면 문제가 해결될 수도 있습니다. CD-ROM 드라이브가 두 개 이상 있다면, CD-ROM을 다른 드라이브에서 시도해 보십시오. 그래도 동작하지 않거나 CD-ROM을 인식하지만 읽으면서 오류가 발생하는 경우, 아래에 있는 방법을 시도해 보십시오. 기본적인 리눅스 관련 지식이 필요합니다. 명령어를 실행하려면 먼저 두 번째 가상 콘솔로 (VT2) 전환해서 쉘을 활성화하십시오. <itemizedlist>
  <listitem
><para
>VT4로 전환해서 <filename
>/var/log/syslog</filename
>의 내용을 보고 (<command
>nano</command
>를 편집기로 사용) 특정 오류 메세지가 있는 지 확인하십시오. 그 다음에 <command
>dmesg</command
>의 출력도 확인해 보십시오. </para
></listitem>
  <listitem
><para
><command
>dmesg</command
> 출력에서 CD-ROM 드라이브를 인식했는지 확인하십시오. 다음과 같은 내용이 있어야 합니다 (연속된 줄이 아닐 수도 있습니다): <informalexample
><screen>
Probing IDE interface ide1...
hdc: TOSHIBA DVD-ROM SD-R6112, ATAPI CD/DVD-ROM drive
ide1 at 0x170-0x177,0x376 on irq 15
hdc: ATAPI 24X DVD-ROM DVD-R CD-R/RW drive, 2048kB Cache, UDMA(33)
Uniform CD-ROM driver Revision: 3.20
</screen
></informalexample
> 이와 같은 내용이 없으면, CD-ROM이 연결된 컨트롤러를 인식하지 못했거나 아예 지원하지 않는다는 뜻입니다. 해당 컨트롤러에 무슨 드라이버가 필요한지 알려면, <command
>modprobe</command
> 명령을 사용해 수동으로 드라이버를 읽어들여 보십시오. </para
></listitem>
  <listitem
><para
><filename
>/dev/</filename
> 아래에 CD-ROM 드라이브의 장치 노드가 있는 지 확인하십시오. 위의 예에서 장치 노드는 <filename
>/dev/hdc</filename
>입니다. <filename
>/dev/cdrom</filename
> 파일도 있어야 합니다. </para
></listitem>
  <listitem
><para
><command
>mount</command
> 명령으로 CD-ROM이 이미 마운트되어 있지는 않은 지 확인하십시오. 마운트되어 있지 않다면 수동으로 마운트해 보십시오: <informalexample
><screen>
$ mount /dev/<replaceable
>hdc</replaceable
> /cdrom
</screen
></informalexample
> 이 명령어 다음에 무슨 오류 메세지가 없는 지 확인하십시오. </para
></listitem>
  <listitem
><para
>DMA가 켜져 있는 지 확인하십시오: <informalexample
><screen>
$ cd /proc/<replaceable
>ide</replaceable
>/<replaceable
>hdc</replaceable>
$ grep using_dma settings
using_dma      1       0       1       rw
</screen
></informalexample
> 첫번째 열의 <literal
>using_dma</literal
> 다음에 나오는 <quote
>1</quote
>은 DMA가 켜져 있다는 뜻입니다. DMA가 켜져 있다면 꺼 보십시오: <informalexample
><screen>
$ echo -n "using_dma:0" 
>settings
</screen
></informalexample
> CD-ROM 드라이브에 해당하는 장치 노드가 있는 디렉토리 안에서 실행해야 하는 것에 유의하십시오. </para
></listitem>
  <listitem
><para
>설치하는 데 문제가 있다면, 설치 프로그램의 메인 메뉴 맨 아래 부분에 있는 옵션을 사용해 CD-ROM이 올바른지 확인해 보십시오. 이 옵션은 CD-ROM을 안정적으로 읽을 수 있는 지 시험하는 목적으로도 사용합니다. </para
></listitem>
</itemizedlist>

</para>
  </sect3>
  </sect2>

  <sect2 condition="supports-floppy-boot" id="unreliable-floppies">
  <title
>플로피 디스크 신뢰성</title>

<para
>플로피 디스크를 사용해 설치하는 사람이 겪는 가장 큰 문제는 플로피 디스크 신뢰성 문제일 것입니다. </para
><para
>부팅 플로피가 가장 문제가 많은 플로피입니다. 부팅 플로피는 리눅스가 아니라 하드웨어에서 직접 읽어들이기 때문입니다. 가끔 하드웨어는 리눅스 플로피 디스크 드라이버가 하는 것 만큼 안정적으로 플로피를 읽지 못합니다. 또 잘못된 데이터를 읽은 경우에도 오류 메세지를 표시하지 않고 멈춰버리기도 합니다. 드라이버 플로피에서도 디스크 입출력 오류 메세지만 가득 나오는 문제가 발생하기도 합니다. </para
><para
>설치 도중에 특정 플로피에서 멈추는 현상이 발생하면, 가장 먼저 할 일은 플로피 디스크 이미지를 <emphasis
>다른</emphasis
> 플로피에 만들어서 문제가 해결되는 지 보는 것입니다. 기존의 플로피를 다시 포맷하는 것만으로는 (애러 없이 포맷이 되더라도) 안 됩니다. 다른 시스템에서 플로피를 만드는 게 도움이 될 수도 있습니다. </para
><para
>어떤 사용자는 플로피가 제대로 동작할 때까지 이미지를 무려 <emphasis
>세 번</emphasis
> 써야 했다고 하고, 세 번째 플로피에서 제대로 동작했다고 합니다. </para
><para
>보통 플로피 이미지를 다시 다운로드할 필요는 없습니다. 하지만 문제를 겪는다면 md5sum을 검사해서 이미지가 올바른 지 확인하는 게 좋습니다. </para
><para
>또 어떤 사용자는 같은 플로피를 가지고 여러 번 다시 부팅하니까 성공적으로 부팅했다고 합니다. 이러한 현상은 모두 문제가 있는 하드웨어나 펌웨어의 플로피 드라이버때문입니다. </para>
  </sect2>

  <sect2
><title
>부팅 설정</title>

<para
>문제가 생겨서 커널이 부팅 과정에서 멈추거나, 주변 장치를 인식하지 못하거나, 드라이브를 제대로 인식하지 못하거나 하는 경우, 먼저 부팅 파라미터가 <xref linkend="boot-parms"/>에 쓰여 있는 것처럼 제대로 되었는 지 확인하십시오. </para
><para
>추가 장치나 주변 기기를 없앤 다음에 다시 부팅하면 문제가 없어질 수도 있습니다. <phrase arch="x86"
>내장 모뎀, 사운드 카드 및 플러그앤플레이 장치가 특히 문제가 많습니다.</phrase
> </para
><para
>컴퓨터에 512M 보다 더 많은 메모리가 붙어 있는 경우에 설치 프로그램의 커널이 부팅할 때 멈춘다면, 커널에 보이는 메모리 양을 제한하는 부팅 파라미터를 써야 할 수도 있습니다. 예를 들어 <userinput
>mem=512m</userinput
>과 같이 씁니다. </para>
  </sect2>

  <sect2 arch="x86" id="i386-boot-problems">
  <title
>자주 발생하는 &arch-title; 설치 문제</title>
<para
>자주 발생하는 설치 문제중에 몇 개는 설치 프로그램에 부팅 파라미터를 넘기는 방법으로 해결할 수 있습니다. </para
><para
>일부 시스템에는 <quote
>DCL이 뒤바뀐</quote
> 플로피가 달려 있습니다. 플로피가 문제가 없는 게 분명한데도 플로피를 읽다가 오류가 발생하면, <userinput
>floppy=thinkpad</userinput
> 파라미터를 시도해 보십시오. </para
><para
>IBM PS/1이나 ValuePoint같은 (ST-506 디스크 드라이버가 있는) 일부 시스템에서는 IDE 드라이브를 제대로 인식하지 못하기도 합니다. 먼저 파라미터 없이 IDE 드라이버를 제대로 인식하는 지 시도해 보십시오. 제대로 인식하지 못하면, 드라이브 크기를 (실린더, 헤드, 섹터) 알아보고, <userinput
>hd=<replaceable
>cylinders</replaceable
>,<replaceable
>heads</replaceable
>,<replaceable
>sectors</replaceable
></userinput
> 파라미터를 사용하십시오. </para
><para
>아주 오래된 컴퓨터에서 <computeroutput
>Checking 'hlt' instruction...</computeroutput
>라고 나오면서 커널이 멈춘다면, hlt 인스트럭션 테스트를 하지 않도록 <userinput
>no-hlt</userinput
> 파라미터를 시도해 보십시오. </para
><para
>일부 시스템의 경우 (특히 노트북 컴퓨터) 본래 화면 해상도가 4:3 비율이 (예를 들어 800x600이나 1024x768) 아닌 경우가 있는데, 이런 시스템에서는 설치 프로그램이 부팅한 후에 검은 화면이 나타날 수도 있습니다. 그런 경우 <userinput
>vga=788</userinput
><footnote
> <para
> <userinput
>vga=788</userinput
> 파라미터를 사용하면 800x600 해상도로 VESA 프레임 버퍼를 사용합니다. 이렇게 하면 동작하겠지만 시스템에 적합한 해상도는 아닐 수도 있습니다. 지원하는 해상도 목록은 <userinput
>vga=ask</userinput
> 파라미터를 사용하면 알 수 있지만 이 목록은 전체 목록이 아닙니다. </para
> </footnote
> 파라미터를 사용하면 동작할 수도 있습니다. 동작하지 않는다면 <userinput
>fb=false</userinput
> 파라미터를 사용해 보십시오. </para
><para
>커널이 부팅할 때 화면에 괴상한 그림이 나온다면, 예를 들어 전부 하얀 색이 되거나 전부 검은 색이 되거나 가지가지 색의 픽셀 쓰레기가 나오거나 하면, 프레임버퍼 모드로 제대로 전환하지 못하는 문제 있는 비디오 카드가 붙어 있다는 뜻입니다. 그러면 <userinput
>fb=false</userinput
> 부팅 파라미터로 프레임버퍼 콘솔을 사용하지 않을 수 있습니다. 그러면 콘솔 기능의 한계때문에 설치할 때 언어는 일부 언어만 사용할 수 있습니다. 자세한 방법은 <xref linkend="boot-parms"/> 부분을 참고하십시오. </para>

  <sect3>
  <title
>PCMCIA 설정 단계에서 시스템 멈춤</title>
<para
>Dell에서 제조한 일부 노트북 모델은 PCMCIA 장치를 찾을 때 특정 하드웨어 주소에 접근하는 순간 멈춰 버립니다. 그 외의 노트북 모델도 비슷한 현상이 나타날 수 있습니다. 만약 그러한 문제가 발생하고 설치할 때 PCMCIA 기능이 필요없다면, <userinput
>hw-detect/start_pcmcia=false</userinput
> 부팅 파라미터로 PCMCIA를 끌 수 있습니다. 설치를 마친 다음에 PCMCIA를 설정해서 문제가 발생하는 구간을 제외할 수 있습니다. </para
><para
>다른 방법으로 전문가 모드에서 설치 프로그램을 부팅할 수 있습니다. 그 다음에 하드웨어에 필요한 리소스 범위를 입력합니다. 예를 들어, 위에서 말한 Dell 노트북을 가지고 있다면, 여기서 <userinput
>exclude port 0x800-0x8ff</userinput
>라고 입력합니다. <ulink url="http://pcmcia-cs.sourceforge.net/ftp/doc/PCMCIA-HOWTO-1.html#ss1.12"
>System resource settings section of the PCMCIA HOWTO</ulink
>에 보면 리소스 범위 관련 옵션의 목록이 있습니다. 설치 프로그램에서 이 값을 입력할 때, 쉼표를 쓰지 않는다는 것에 유의하십시오. </para>
   </sect3>

   <sect3>
   <title
>USB 모듈을 읽어들이다가 시스템 멈춤</title>
<para
>일부 표준에서 벗어난 USB 키보드를 지원하기 위해 커널에서 USB 모듈과 USB 키보드 드라이버를 읽어들입니다. 하지만 일부 문제 있는 USB 시스템에서는 드라이버를 읽어들일 때 멈춥니다. 한 가지 방법은 메인보드의 BIOS 설정에서 USB 컨트롤러를 끄는 것입니다. 또 다른 방법은 <userinput
>nousb</userinput
> 파라미터를 부팅 프롬프트로 넘기는 방법입니다. </para>
   </sect3>
  </sect2>

  <sect2 arch="sparc" id="sparc-boot-problems">
  <title
>자주 발생하는 &arch-title; 설치 문제</title>
<para
>자주 발생하는 설치 문제 중에 몇 가지를 설명합니다. </para>
   <sect3>
   <title
>비디오 출력이 다른 곳으로 가는 경우</title>
<para
>&arch-title; 아키텍처의 경우 한 컴퓨터에 비디오 카드가 두 개인 경우가 많습니다. 예를 들어 ATI 카드와 Sun Creator 3D 카드가 모두 있을 수 있습니다. 어떤 경우에는 비디오 카드가 두 개이면 시스템이 부팅한 다음에 비디오 출력이 엉뚱한 곳으로 가는 경우가 발생합니다. 이러한 경우 보통 해당 디스플레이는 다음 메세지만 표시합니다: <informalexample
><screen>
Remapping the kernel... done
Booting Linux...
</screen
></informalexample
> 이 현상을 피해가려면, 비디오 카드 하나를 뽑아 버리거나, OpenProm 부팅 단계에서 커널 파라미터를 이용해 사용하지 않는 비디오카드를 사용하지 않으면 됩니다. 예를 들어 ATI 카드를 사용하지 않으려면, <userinput
>video=atyfb:off</userinput
> 파라미터로 설치 프로그램을 부팅합니다. </para
><para
>SILO 설정에도 수동으로 이 파라미터를 추가해야 하고 (부팅하기 전에 <filename
>/target/etc/silo.conf</filename
> 편집), X11을 설치한다면 <filename
>/etc/X11/xorg.conf</filename
>의 비디오 드라이버도 바꿔야 합니다. </para>
   </sect3>

   <sect3>
   <title
>부팅 실패 혹은 CD-ROM에서 설치 실패</title>
<para
>일부 Sparc 시스템은 부팅 CD-ROM에서 부팅을 못하는 경우가 있습니다. 설치하는 도중에 설명할 수 없는 실패가 일어나기도 합니다. 이러한 문제는 대부분 SunBlade 시스템에서 보고되었습니다. </para
><para
>이러한 시스템에서는 설치 프로그램을 네트워크 부팅해서 설치하기를 권장합니다. </para>
   </sect3>
  </sect2>

  <sect2 id="kernel-msgs">
  <title
>커널 시작 메세지 해석하기</title>

<para
>부팅 과정에서, <computeroutput
>can't find <replaceable
>something</replaceable
></computeroutput
> 혹은 <computeroutput
><replaceable
>something</replaceable
> not present</computeroutput
>, <computeroutput
>can't initialize <replaceable
>something</replaceable
></computeroutput
>, 아니면 심지어는 <computeroutput
>this driver release depends on <replaceable
>something</replaceable
></computeroutput
> 형식의 메세지를 볼 수 있을 것입니다. 이러한 메세지 대부분은 아무런 문제를 일으키지 않습니다. 설치 시스템은 여러 가지 주변 장치가 달린 컴퓨터에서 동작하도록 만들어졌기 때문에 이런 메세지가 나옵니다. 당연히 그 어떤 컴퓨터도 모든 종류의 주변 장치를 가진 컴퓨터는 없으므로, 운영체제에서는 찾으려는 주변 장치가 없을 때 이러한 메세지를 내보냅니다. 또 시스템이 일시적으로 멈추는 현상이 일어날 수도 있습니다. 이러한 현상은 어떤 장치가 응답할 때까지 기다리는데, 그 장치가 없을 때 발생합니다. 이런 시간이 너무 오래 걸린다고 생각한다면, 나중에 직접 설정한 커널을 사용할 수 있습니다. (<xref linkend="kernel-baking"/> 참고.) </para>
  </sect2>


  <sect2 id="problem-report">
  <title
>설치 문제 보고하기</title>
<para
>최초 부팅 단계를 지나갔지만 설치를 마치지 못했다면, <guimenuitem
>디버깅 기록 저장</guimenuitem
> 메뉴가 도움이 될 수도 있습니다. 이 메뉴를 이용하면 시스템 오류 로그와 설정 정보를 설치 프로그램에서 플로피로 복사하거나, 웹브라우저를 이용해 다운로드할 수 있습니다. 이 정보는 무엇이 잘못되었는지 및 어떻게 고치는 지에 대한 단서가 들어 있습니다. 버그를 보고할 때 이 정보를 버그 보고에 첨부해 주십시오. </para
><para
>그 외의 설치 메세지는 설치할 때 <filename
>/var/log/</filename
>에 들어 있고, 설치된 시스템으로 부팅한 다음에는 <filename
>/var/log/installer/</filename
>에 들어 있습니다. </para>
  </sect2>

  <sect2 id="submit-bug">
  <title
>설치 보고 제출</title>
<para
>그래도 문제가 있다면, 설치 리포트를 보내 주십시오. 설치가 성공했을 경우에도 설치 리포트를 보내 주시는 게 좋습니다. 그래야 사용자가 어떤 하드웨어 설정을 사용하는 지에 대한 정보를 많이 얻을 수 있습니다. </para
><para
>주의: 설치 보고서는 데비안 버그 추적 시스템에 (BTS) 공개되며, 공개 메일링 리스트에도 전달됩니다. 공개해도 상관 없는 전자메일 주소를 사용하도록 하십시오. </para
><para
>이미 동작하고 있는 데비안 시스템이 있다면, 설치 리포트를 보내는 가장 쉬운 방법은 <classname
>installation-report</classname
> 및 <classname
>reportbug</classname
> 패키지를 설치하고 (<command
>aptitude install installation-report reportbug</command
>), <classname
>reportbug</classname
>를 <xref linkend="mail-outgoing"/>에 설명된 대로 설정한 다음, <command
>reportbug installation-reports</command
> 명령을 실행하는 것입니다. </para
><para
>다른 방법으로, 설치 보고서를 작성하실 때 아래 형식을 이용하시고, <classname
>installation-reports"</classname
> 패키지에 대한 버그를 <email
>submit@bugs.debian.org</email
>로 메일을 보내 제출해 주십시오.  <informalexample
><screen>
Package: installation-reports

Boot method: &lt;설치 프로그램을 어떻게 부팅했는지? CD? 플로피? 네트워크?&gt;
Image version: &lt;설치 이미지를 받은 URL을 쓰는 게 가장 좋습니다&gt;
Date: &lt;설치한 날짜 및 시각&gt;

Machine: &lt;컴퓨터 설명 (예, IBM Thinkpad R32)&gt;
Processor:
Memory:
Partitions: &gt;df -Tl 명령어의 결과. 파티션 테이블의 raw 정보가 좋습니다.&gt;

Output of lspci -knn (or lspci -nn):

Base System Installation Checklist:
[O] = OK, [E] = Error (please elaborate below), [ ] = didn't try it

Initial boot:           [ ]
Detect network card:    [ ]
Configure network:      [ ]
Detect CD:              [ ]
Load installer modules: [ ]
Detect hard drives:     [ ]
Partition hard drives:  [ ]
Install base system:    [ ]
Clock/timezone setup:   [ ]
User/password setup:    [ ]
Install tasks:          [ ]
Install boot loader:    [ ]
Overall install:        [ ]

Comments/Problems:

&lt;설치 과정을 문장으로 설명하십시오. 그리고 처음에 설치했을 때 
      들었던 생각, 평가, 아이디어 따위도 써 주십시오.&gt;
</screen
></informalexample
> 버그 보고서에 문제가 무엇인지 설명하시고, 커널이 멈춘 경우에 마지막으로 볼 수 있는 커널 메세지를 포함하십시오. 문제가 발생할 때 어떤 과정을 거쳤는 지 설명하십시오. </para>
  </sect2>
 </sect1>
<!--   End of file boot-installer/trouble.xml -->

</chapter>
<!--   End of file boot-installer/boot-installer.xml -->
