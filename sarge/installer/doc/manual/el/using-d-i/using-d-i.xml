<!-- Start of file using-d-i/using-d-i.xml -->


 <chapter id="d-i-intro"
><title
>Χρησιμοποιώντας τον Εγκαταστάτη του Debian </title>

 <sect1
><title
>Πώς λειτουργεί ο Εγκαταστάτης</title>
<para
>Ο Εγκαταστάτης του Debian αποτελείται από έναν αριθμό εξειδικευμένων συστατικών για κάθε εργασία της εγκατάστασης. Κάθε συστατικό εκτελεί την εργασία του, αλληλεπιδρώντας με τον χρήστη όπου είναι αυτό απαραίτητο. Για τις ίδιες τις ερωτήσεις έχουν οριστεί προτεραιότητες. Κατά την εκκίνηση του εγκαταστάτη καθορίζεται ποιες ερωτήσεις θα εμφανιστούν στο χρήστη ορίζοντας την προτεραιότητα. </para
><para
>Σε μια τυπική εγκατάσταση, μόνο οι απαραίτητες (υψηλής προτεραιότητας) ερωτήσεις θα ερωτηθούν. Αυτό θα έχει ως αποτέλεσμα την αυτοματοποίηση της διαδικασίας εγκατάστασης με μικρή συμμετοχή του χρήστη. Τα συστατικά εκτελούνται διαδοχικά και η σειρά εκτέλεσής τους καθορίζεται κυρίως από τη μέθοδο της εγκατάστασης που χρησιμοποιείτε και την αρχιτεκτονική σας. Ο εγκαταστάτης θα χρησιμοποιήσει προκαθορισμένες τιμές για ερωτήσεις που δεν εμφανίζονται. </para
><para
>Αν υπάρχει πρόβλημα ο χρήστης θα δει μια οθόνη σφάλματος, και αμέσως μετά θα εμφανιστεί το μενού του εγκαταστάτη, ώστε να είναι δυνατή η επιλογή κάποιας εναλλακτικής εργασίας. Αν δεν υπάρξουν προβλήματα, ο χρήστης δε θα δει ποτέ το μενού του εγκαταστάτη, μόνο τις ερωτήσεις κάθε συστατικού με τη σειρά. Οι ειδοποιήσεις σοβαρών σφαλμάτων ορίζονται με προτεραιότητα 'critical' ώστε ο χρήστης θα ειδοποιείται πάντοτε. </para
><para
>Μερικές από τις προκαθορισμένες ρυθμίσεις του εγκαταστάτη μπορούν να οριστούν περνώντας τις κατάλληλες παραμέτρους κατά την εκκίνηση του &d-i;. Αν, για παράδειγμα, θέλετε να εξαναγκάσετε στατική ρύθμιση του δικτύου (εξ ορισμού χρησιμοποείται DHCP), μπορείτε να προσθέσετε την παράμετρο  <userinput
>netcfg/disable_dhcp=true</userinput
>. Δείτε το <xref linkend="installer-args"/> για τις διαθέσιμες επιλογές. </para
><para
>Οι έμπειροι χρήστες πιθανόν να προτιμούν ένα σύστημα διεπαδής με μενού, όπου κάθε βήμα θα ελέγχεται από το χρήστη παρά να επιλέγεται διαδοχικά από τον εγκαταστάτη. Για χρήση του εγκαταστάτη με αυτόν τον χειροκίνητο τρόπο, προσθέστε την παράμετρο εκκίνησης <userinput
>debconf/priority=medium</userinput
>. </para
><para
>Αν η το υλικό του υπολογιστή σας απαιτεί κάποιες παραμέτρους στα αρθρώματα του πυρήνα κατά την εγκατάστασή τους, θα πρέπει να εκκινήσετε την εγκατάσταση σε κατάσταση <quote
>expert</quote
>. Αυτό μπορεί να γίνει είτε χρησιμοποιώντας την εντολή <command
>expert</command
> κατά την εκκίνηση ή προσθέτοντας την παράμετρο εκκίνησης <userinput
>debconf/priority=low</userinput
>. Η κατάσταση Expert σας δίνει πλήρη έλεγχο πάνω στον &d-i;. </para
><para
>Οι οθόνες του εγκαταστάτη είναι τυπικά οθόνες χαρακτήρων (αντίθετα με τα πιο σύγχρονα γραφικά περιβάλλοντα). Το ποντίκι δεν είναι λειτουργικό σε αυτό το περιβάλλον. Τα πλήκτρα που μπορείτε να χρησιμοποιήσετε για την πλοήγηση στους διαλόγους του εγκαταστάτη είναι: Το πλήκτρο <keycap
>Tab</keycap
> ή το πλήκτρο <keycap
>δεξιά</keycap
> του δρομέα, προκαλούν κίνηση του δρομέα 'εμπρός', ενώ ο συνδυασμός <keycombo
> <keycap
>Shift</keycap
> <keycap
>Tab</keycap
> </keycombo
> ή το πλήκτρο <keycap
>αριστερά</keycap
> του δρομέα προκαλούν κίνηση του δρομέα 'πίσω', ανάμεσα στα εμφανιζόμενα κουμπιά και τις επιλογές. Τα πλήκτρα του δρομέα <keycap
>πάνω</keycap
> και <keycap
>κάτω</keycap
> επιλέγουν ανάμεσα σε διαφορετικά αντικείμενα από μια λίστα. Σε μεγάλες λίστες, μπορείτε να πατήσετε ένα πλήκτρο για να μετακινηθείτε κατευθείαν στο αντικείμενο του οποίου το όνομα αρχίζει με το γράμμα που πατήσατε, ενώ τα πλήκτρα <keycap
>Pg-Up</keycap
> και <keycap
>Pg-Down</keycap
> προκαλούν μετακίνηση στη λίστα ανά σελίδες. Το πλήκτρο <keycap
>space</keycap
>  επιλέγει ένα αντικείμενο όπως checkbox. Χρησιμοποιήστε το πλήκτρο &enterkey; για να ενεργοποιήσετε τις επιλογές σας. </para
><para arch="s390"
>Η αρχιτεκτονική S/390 δεν υποστηρίζει εικονικές κονσόλες. Μπορείτε να ανοίξετε μια δεύτερη και τρίτη συνεδρία ssh για να δείτε τα αρχεία καταγραφών που περιγράφονται παρακάτω. </para
><para
>Error messages are redirected to the third console. You can access this console by pressing <keycombo
><keycap
>Left Alt</keycap
><keycap
>F3</keycap
></keycombo
> (hold the left <keycap
>Alt</keycap
> key while pressing the <keycap
>F3</keycap
> function key); get back to the main installer process with <keycombo
><keycap
>Left Alt</keycap
><keycap
>F1</keycap
></keycombo
>. </para
><para
>These messages can also be found in <filename
>/var/log/messages</filename
>. After installation, this log is copied to <filename
>/var/log/debian-installer/messages</filename
> on your new system. Other installation messages may be found in <filename
>/var/log/</filename
> during the installation, and <filename
>/var/log/debian-installer/</filename
> after the computer has been booted into the installed system. </para>
 </sect1>


  <sect1 id="modules-list"
><title
>Εισαγωγή στα αρθρώματα</title>
<para
>Here is a list of installer components with a brief description of each component's purpose. Details you might need to know about using a particular component are in <xref linkend="module-details"/>. </para>

<variablelist>
<varlistentry>

<term
>main-menu</term
><listitem
><para
>Shows the list of components to the user during installer operation, and starts a component when it is selected. Main-menu's questions are set to priority medium, so if your priority is set to high or critical (high is the default), you will not see the menu. On the other hand, if there is an error which requires your intervention, the question priority may be downgraded temporarily to allow you to resolve the problem, and in that case the menu may appear. </para
><para
>You can get to the main menu by selecting the "Back" button repeatedly to back all the way out of the currently running component. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>languagechooser</term
><listitem
><para
>Shows a list of languages and language variants. The installer will display messages in the chosen language, unless the translation for that language is not complete. When a translation is not complete, English messages are shown. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>countrychooser</term
><listitem
><para
>Shows a list of countries. The user may choose the country he lives in. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>kbd-chooser</term
><listitem
><para
>Shows a list of keyboards, from which the user chooses the model which matches his own. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>hw-detect</term
><listitem
><para
>Automatically detects most of the system's hardware, including network cards, disk drives, and PCMCIA. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>cdrom-detect</term
><listitem
><para
>Looks for and mounts a Debian installation CD. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>netcfg</term
><listitem
><para
>Configures the computer's network connections so it can communicate over the internet. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>iso-scan</term
><listitem
><para
>Looks for ISO file systems, which may be on a CD-ROM or on the hard drive. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>choose-mirror</term
><listitem
><para
>Presents a list of Debian archive mirrors. The user may choose the source of his installation packages. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>cdrom-checker</term
><listitem
><para
>Checks integrity of a CD-ROM. This way the user may assure him/herself that the installation CD-ROM was not corrupted. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>lowmem</term
><listitem
><para
>Lowmem tries to detect systems with low memory and then does various tricks to remove unnecessary parts of &d-i; from the memory (at the cost of some features). </para
></listitem>
</varlistentry>
<varlistentry>

<term
>anna</term
><listitem
><para
>Anna's Not Nearly APT. Installs packages which have been retrieved from the chosen mirror or CD. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partman</term
><listitem
><para
>Allows the user to partition disks attached to the system, create file systems on the selected partitions, and attach them to the mountpoints. Included are also interesting features like a fully automatic mode or LVM support. This is the preferred partitioning tool in Debian. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>autopartkit</term
><listitem
><para
>Automatically partitions an entire disk according to preset user preferences. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partitioner</term
><listitem
><para
>Allows the user to partition disks attached to the system. A partitioning program appropriate to your computer's architecture is chosen. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>partconf</term
><listitem
><para
>Displays a list of partitions, and creates file systems on the selected partitions according to user instructions. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>lvmcfg</term
><listitem
><para
>Helps the user with the configuration of the <firstterm
>LVM</firstterm
> (Logical Volume Manager). </para
></listitem>
</varlistentry>
<varlistentry>

<term
>mdcfg</term
><listitem
><para
>Allows the user to setup Software <firstterm
>RAID</firstterm
> (Redundant Array of Inexpensive Disks). This Software RAID is usually superior to the cheap IDE (pseudo hardware) RAID controllers found on newer motherboards. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>base-installer</term
><listitem
><para
>Installs the most basic set of packages which would allow the computer to operate under Linux when rebooted. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>os-prober</term
><listitem
><para
>Detects currently installed operating systems on the computer and passes this information to the bootloader-installer, which may offer you an ability to add discovered operating systems to the bootloader's start menu. This way the user could easily choose at the boot time which operating system to start. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>bootloader-installer</term
><listitem
><para
>Installs a boot loader program on the hard disk, which is necessary for the computer to start up using Linux without using a floppy or CD-ROM. Many boot loaders allow the user to choose an alternate operating system each time the computer boots. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>base-config</term
><listitem
><para
>Provides dialogs for setting up the base system packages according to user preferences. This is normally done after rebooting the computer; it is the 'first run' of the new Debian system. </para
></listitem>
</varlistentry>
<varlistentry>

<term
>shell</term
><listitem
><para
>Allows the user to execute a shell from the menu, or in the second console. </para
></listitem>
</varlistentry>
<varlistentry>

<term condition="sarge"
>bugreporter</term
><term condition="etch"
>save-logs</term
><listitem
><para
>Provides a way for the user to record information on a floppy disk<phrase condition="etch"
>, network, hard disk, or other media</phrase
> when trouble is encountered, in order to accurately report installer software problems to Debian developers later. </para
></listitem>
</varlistentry>

</variablelist>

 </sect1>


<!-- Start of file using-d-i/components.xml -->

 <sect1 id="module-details">
 <title
>Using Individual Components</title>
<para
>In this section we will describe each installer component in detail. The components have been grouped into stages that should be recognizable for users. They are presented in the order they appear during the install. Note that not all modules will be used for every installation; which modules are actually used depends on the installation method you use and on your hardware. </para>

  <sect2 id="di-setup">
  <title
>Setting up Debian Installer and Hardware Configuration</title>
<para
>Let's assume the Debian Installer has booted and you are facing its first screen. At this time, the capabilities of &d-i; are still quite limited. It doesn't know much about your hardware, preferred language, or even the task it should perform. Don't worry. Because &d-i; is quite clever, it can automatically probe your hardware, locate the rest of its components and upgrade itself to a capable installation system. However, you still need to help &d-i; with some information it can't determine automatically (like selecting your preferred language, keyboard layout or desired network mirror). </para
><para
>You will notice that &d-i; performs <firstterm
>hardware detection</firstterm
> several times during this stage. The first time is targeted specifically at the hardware needed to load installer components (e.g. your CD-ROM or network card). As not all drivers may be available during this first run, hardware detection needs to be repeated later in the process. </para>


<!-- Start of file using-d-i/modules/lowmem.xml -->

  <sect3 id="lowmem">
  <title
>Check available memory</title>

<para
>One of the first things &d-i; does, is to check available memory. If the available memory is limited, this component will make some changes in the installation process which hopefully will allow you to install &debian; on your system. </para
><para
>During a low memory install, not all components will be available. One of the limitations is that you won't be able to choose a language for the installation. </para>
   </sect3>
<!--   End of file using-d-i/modules/lowmem.xml -->

<!-- Start of file using-d-i/modules/languagechooser.xml -->


   <sect3 id="lang-chooser">
   <title
>Language Chooser</title>

<para
>As the first step of the installation, select the language in which you want the installation process to proceed. The language names are listed in both English (left side) and in the language itself (right side); the names on the right side are also shown in the proper script for the language. The list is sorted on the English names. </para
><para
>The language you choose will be used for the rest of the installation process, provided a translation of the different dialogs is available. If no valid translation is available for the selected language, the installer will default to English. The selected language will also be used to help select a suitable keyboard layout. </para>
   </sect3>
<!--   End of file using-d-i/modules/languagechooser.xml -->

<!-- Start of file using-d-i/modules/countrychooser.xml -->


   <sect3 id="country-chooser">
   <title
>Country Chooser</title>

<para
>If you selected a language in <xref linkend="lang-chooser"/> which has more than one country associated with it (true for Chinese, English, French, and many other languages), you can specify the country here. If you choose <guimenuitem
>Other</guimenuitem
> at the bottom of the list, you will be presented with a list of all countries, grouped by continent. </para
><para
>This selection will be used later in the installation process to pick the default timezone and a Debian mirror appropriate for your geographic location. If the defaults proposed by the installer are not suitable, you can make a different choice. The selected country, together with the selected language, may also affect locale settings for your new Debian system. </para>
   </sect3>
<!--   End of file using-d-i/modules/countrychooser.xml -->

<!-- Start of file using-d-i/modules/kbd-chooser.xml -->

   <sect3 id="kbd-chooser">
   <title
>Choosing a Keyboard</title>

<para
>Keyboards are often tailored to the characters used in a language. Select a layout that conforms to the keyboard you are using, or select something close if the keyboard layout you want isn't represented. Once the system installation is complete, you'll be able to select a keyboard layout from a wider range of choices (run <command
>kbdconfig</command
> as root after you have completed the installation). </para
><para
>Move the highlight to the keyboard selection you desire and press &enterkey;. Use the arrow keys to move the highlight &mdash; they are in the same place in all national language keyboard layouts, so they are independent of the keyboard configuration. An 'extended' keyboard is one with <keycap
>F1</keycap
> through <keycap
>F10</keycap
> keys along the top row. </para
><para arch="mipsel"
>On DECstations there is currently no loadable keymap available, so you have to skip the keyboard selection and keep the default kernel keymap (LK201 US). This may change in the future as it depends on further Linux/MIPS kernel development. </para
><para arch="powerpc"
>There are two keyboard layouts for US keyboards; the qwerty/mac-usb-us (Apple USB) layout will place the Alt function on the <keycap
>Command/Apple</keycap
> key (in the keyboard position next to the <keycap
>space</keycap
> key similar to <keycap
>Alt</keycap
> on PC keyboards), while the qwerty/us (Standard) layout will place the Alt function on the <keycap
>Option</keycap
> key (engraved with 'alt' on most Mac keyboards). In other respects the two layouts are similar. </para>

<note arch="sparc"
><para
>If you are installing on a system that has a Sun USB keyboard and have booted the installer with the default 2.4 kernel, the keyboard will not be identified correctly by the installation system. The installer will show you a list of Sun type keymaps to choose from, but selecting one of these will result in a non-working keyboard. If you are installing with the 2.6 kernel, there is no problem. </para
><para
>To get a working keyboard, you should boot the installer with parameter <userinput
>debconf/priority=medium</userinput
>. When you get to keyboard selection<footnote
> <para
> If you are installing at default priority you should use the <userinput
>Go Back</userinput
> button to return to the installer menu when you are shown the list of Sun type keymaps. </para
> </footnote
>, choose <quote
>No keyboard to configure</quote
> if you have a keyboard with an American (US) layout, or choose <quote
>USB keyboard</quote
> if you have a keyboard with a localized layout. Selecting <quote
>No keyboard to configure</quote
> will leave the kernel keymap in place, which is correct for US keyboards. </para
></note>
   </sect3>
<!--   End of file using-d-i/modules/kbd-chooser.xml -->

<!-- Start of file using-d-i/modules/s390/netdevice.xml -->
<!--   End of file using-d-i/modules/s390/netdevice.xml -->

<!-- Start of file using-d-i/modules/s390/dasd.xml -->
<!--   End of file using-d-i/modules/s390/dasd.xml -->

<!-- Start of file using-d-i/modules/ddetect.xml -->
<!--   End of file using-d-i/modules/ddetect.xml -->

<!-- Start of file using-d-i/modules/cdrom-detect.xml -->
<!--   End of file using-d-i/modules/cdrom-detect.xml -->

<!-- Start of file using-d-i/modules/iso-scan.xml -->

   <sect3 id="iso-scan">
   <title
>Looking for the Debian Installer ISO Image</title>
<para
>When installing via the <emphasis
>hd-media</emphasis
> method, there will be a moment where you need to find and mount the Debian Installer iso image in order to get the rest of the installation files. The component <command
>iso-scan</command
> does exactly this. </para
><para
>At first, <command
>iso-scan</command
> automatically mounts all block devices (e.g. partitions) which have some known filesystem on them and sequentially searches for filenames ending with <filename
>.iso</filename
> (or <filename
>.ISO</filename
> for that matter). Beware that the first attempt scans only files in the root directory and in the first level of subdirectories (i.e. it finds <filename
>/<replaceable
>whatever</replaceable
>.iso</filename
>, <filename
>/data/<replaceable
>whatever</replaceable
>.iso</filename
>, but not <filename
>/data/tmp/<replaceable
>whatever</replaceable
>.iso</filename
>). After an iso image has been found, <command
>iso-scan</command
> checks its content to determine if the image is a valid Debian iso image or not. In the former case we are done, in the latter <command
>iso-scan</command
> seeks for another image. </para
><para
>In case the previous attempt to find an installer iso image fails, <command
>iso-scan</command
> will ask you whether you would like to perform a more thorough search. This pass doesn't just look into the topmost directories, but really traverses whole filesystem. </para
><para
>If <command
>iso-scan</command
> does not discover your installer iso image, reboot back to your original operating system and check if the image is named correctly (ending in <filename
>.iso</filename
>), if it is placed on a filesystem recognizable by &d-i;, and if it is not corrupted (verify the checksum). Experienced Unix users could do this without rebooting on the second console. </para>
   </sect3>
<!--   End of file using-d-i/modules/iso-scan.xml -->

<!-- Start of file using-d-i/modules/anna.xml -->
<!--   End of file using-d-i/modules/anna.xml -->

<!-- Start of file using-d-i/modules/netcfg.xml -->

   <sect3 id="netcfg">
   <title
>Configuring Network</title>

<para
>As you enter this step, if the system detects that you have more than one network device, you'll be asked to choose which device will be your <emphasis
>primary</emphasis
> network interface, i.e. the one which you want to use for installation. The other interfaces won't be configured at this time. You may configure additional interfaces after installation is complete; see the <citerefentry
> <refentrytitle
>interfaces</refentrytitle
> <manvolnum
>5</manvolnum
> </citerefentry
> man page. </para
><para
>By default, &d-i; tries to configure your computer's network automatically via DHCP. If the DHCP probe succeeds, you are done. If the probe fails, it may be caused by many factors ranging from unplugged network cable, to a misconfigured DHCP setup. Or maybe you don't have a DHCP server in your local network at all. For further explanation check the error messages on the third console. In any case, you will be asked if you want to retry, or if you want to perform manual setup. DHCP servers are sometimes really slow in their responses, so if you are sure everything is in place, try again. </para
><para
>The manual network setup in turn asks you a number of questions about your network, notably <computeroutput
>IP address</computeroutput
>, <computeroutput
>Netmask</computeroutput
>, <computeroutput
>Gateway</computeroutput
>, <computeroutput
>Name server addresses</computeroutput
>, and a <computeroutput
>Hostname</computeroutput
>. Moreover, if you have a wireless network interface, you will be asked to provide your <computeroutput
>Wireless ESSID</computeroutput
> and a <computeroutput
>WEP key</computeroutput
>. Fill in the answers from <xref linkend="needed-info"/>. </para
><note
><para
>Some technical details you might, or might not, find handy: the program assumes the network IP address is the bitwise-AND of your system's IP address and your netmask. It will guess the broadcast address is the bitwise OR of your system's IP address with the bitwise negation of the netmask. It will also guess your gateway. If you can't find any of these answers, use the system's guesses &mdash; you can change them once the system has been installed, if necessary, by editing <filename
>/etc/network/interfaces</filename
>. Alternatively, you can install <classname
>etherconf</classname
>, which will step you through your network setup. </para
></note>
   </sect3>
<!--   End of file using-d-i/modules/netcfg.xml -->

<!-- Start of file using-d-i/modules/choose-mirror.xml -->

<!--
- Component is only selected and executed if the installer needs to load
  installer components or the base system from the network
  (either local or the internet).
- This means you first have to configure a network interface.
- A list of countries is displayed with the default based on the country you
  selected earlier.
- Note that not all mirrors are equal (see http://www.nl.debian.org/mirror/list)
- Selection of a local mirror (at top of the list: manual selection).
- After selecting a country, a list of mirrors in the country will be shown.

- The selected mirror will be tested.
- How to handle problems with mirrors.
-->
<!--   End of file using-d-i/modules/choose-mirror.xml -->

  </sect2>

  <sect2 id="di-partition">
  <title
>Partitioning and Mount Point Selection</title>
<para
>At this time, after hardware detection has been executed a final time, &d-i; should be at its full strength, customized for the user's needs and ready to do some real work. As the title of this section indicates, the main task of the next few components lies in partitioning your disks, creating filesystems, assigning mountpoints and optionally configuring closely related issues like LVM or RAID devices. </para>


<!-- Start of file using-d-i/modules/partman.xml -->

   <sect3 id="partman">
   <title
>Partitioning Your Disks</title>

<para
>Now it is time to partition your disks. If you are uncomfortable with partitioning, or just want to know more details, see <xref linkend="partitioning"/>. </para
><para
>First you will be given the opportunity to automatically partition either an entire drive, or free space on a drive. This is also called <quote
>guided</quote
> partitioning. If you do not want to autopartition, choose <guimenuitem
>Manually edit partition table</guimenuitem
> from the menu. </para
><para
>If you choose guided partitioning, you will be able to choose from the schemes listed in the table below. All schemes have their pros and cons, some of which are discussed in <xref linkend="partitioning"/>. If you are unsure, choose the first one. Bear in mind, that guided partitioning needs certain minimal amount of free space to operate with. If you don't give it at least about 1GB of space (depends on chosen scheme), guided partitioning will fail. </para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
  <entry
>Partitioning scheme</entry>
  <entry
>Minimum space</entry>
  <entry
>Created partitions</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>All files in one partition</entry>
  <entry
>600MB</entry>
  <entry
><filename
>/</filename
>, swap</entry>
</row
><row>
  <entry
>Σταθμός εργασίας (Desktop)</entry>
  <entry
>500MB</entry>
  <entry
><filename
>/</filename
>, <filename
>/home</filename
>, swap </entry>
</row
><row>
  <entry
>Πολυχρηστικός σταθμός εργασίας</entry>
  <entry
>1GB</entry>
  <entry
><filename
>/</filename
>, <filename
>/home</filename
>, <filename
>/usr</filename
>, <filename
>/var</filename
>, <filename
>/tmp</filename
>, swap </entry>
</row>

</tbody
></tgroup
></informaltable>

<para arch="ia64"
>If you chose an automatic partitioning for your IA64 system, there will be an additional partition, formatted as a FAT16 bootable filesystem, for the EFI boot loader. There is also an additional menu item in the formatting menu to manually set up a partition as an EFI boot partition. </para
><para arch="alpha"
>If you chose an automatic partitioning for your Alpha system, an additional, unformatted partition will be allocated at the beginning of your disk to reserve this space for the aboot boot loader. </para
><para
>After selecting a scheme, the next screen will show your new partition table, including information on whether and how partitions will be formatted and where they will be mounted. </para
><para
>The list of partitions might look like this: <informalexample
><screen
>
  IDE1 master (hda) - 6.4 GB WDC AC36400L
        #1 primary   16.4 MB     ext2       /boot
        #2 primary  551.0 MB     swap       swap
        #3 primary    5.8 GB     ntfs
           pri/log    8.2 MB     FREE SPACE

  IDE1 slave (hdb) - 80.0 GB ST380021A
        #1 primary   15.9 MB     ext3
        #2 primary  996.0 MB     fat16
        #3 primary    3.9 GB     xfs        /home
        #5 logical    6.0 GB     ext3       /
        #6 logical    1.0 GB     ext3       /var
        #7 logical  498.8 GB     ext3
        #8 logical  551.5 GB     swap       swap
        #9 logical   65.8 GB     ext2
</screen
></informalexample
> This example shows two IDE harddrives divided into several partitions; the first disk has some free space. Each partition line consists of the partition number, its type, size, optional flags, file system, and mountpoint (if any). </para
><para
>This concludes the guided partitioning. If you are satisfied with the generated partition table, you can choose <guimenuitem
>Finish partitioning and write changes to disk</guimenuitem
> from the menu to implement the new partition table (as described at the end of this section). If you are not happy, you can choose to <guimenuitem
>Undo changes to partitions</guimenuitem
>, to run guided partitioning again or modify the proposed changes as described below for manual partitioning. </para
><para
>A similar screen to the one shown just above will be displayed if you choose manual partitioning except that your existing partition table will be shown and without the mount points. How to manually setup your partition table and the usage of partitions by your new Debian system will be covered in the remainder of this section. </para
><para
>If you select a pristine disk which doesn't have neither partitions nor free space on it, you will be offered to create a new partition table (this is needed so you can create new partitions). After this a new line entitled <quote
>FREE SPACE</quote
> should appear under the selected disk. </para
><para
>If you select some free space, you will be offered to create new partition. You will have to answer a quick series of questions about its size, type (primary or logical), and location (beginning or end of the free space). After this, you will be presented with detailed overview of your new partition. There are options like mountpoint, mount options, bootable flag, or way of usage. If you don't like the preselected defaults, feel free to change them to your liking. E.g. by selecting the option <guimenuitem
>Use as:</guimenuitem
>, you can choose different filesystem for this partition including the possibility to use the partition for swap, software RAID, LVM, or not use it at all. Other nice feature is the possibility to copy data from existing partition onto this one. When you are satisfied with your new partition, select <guimenuitem
>Done setting up the partition</guimenuitem
> and you will be thrown back to the <command
>partman</command
>'s main screen. </para
><para
>If you decide you want to change something about your partition, simply select the partition, which will bring you to the partition configuration menu. Because this is the same screen like when creating a new partition, you can change the same set of options. One thing which might not be very obvious at a first glance is that you can resize the partition by selecting the item displaying the size of the partition. Filesystems known to work are at least fat16, fat32, ext2, ext3 and swap. This menu also allows you to delete a partition. </para
><para
>Be sure to create at least two partitions: one for the <emphasis
>root</emphasis
> filesystem (which must be mounted as <filename
>/</filename
>) and one for <emphasis
>swap</emphasis
>. If you forget to mount the root filesystem, <command
>partman</command
> won't let you continue until you correct this issue. </para
><para arch="ia64"
>If you forget to select and format an EFI boot partition <command
>partman</command
> will detect this and will not let you continue until you allocate one. </para
><para
>Capabilities of <command
>partman</command
> can be extended with installer modules, but are dependent on your system's architecture. So if you can't see all promised goodies, check if you have loaded all required modules (e.g. <filename
>partman-ext3</filename
>, <filename
>partman-xfs</filename
>, or <filename
>partman-lvm</filename
>). </para
><para
>After you are satisfied with partitioning, select <guimenuitem
>Finish partitioning and write changes to disk</guimenuitem
> from the partitioning menu. You will be presented with a summary of changes made to the disks and asked to confirm that the filesystems should be created as requested. </para>
   </sect3>
<!--   End of file using-d-i/modules/partman.xml -->

<!-- Start of file using-d-i/modules/autopartkit.xml -->
<!--   End of file using-d-i/modules/autopartkit.xml -->

<!-- Start of file using-d-i/modules/partitioner.xml -->

<!--   End of file using-d-i/modules/partitioner.xml -->

<!-- Start of file using-d-i/modules/partconf.xml -->
<!--   End of file using-d-i/modules/partconf.xml -->

<!-- Start of file using-d-i/modules/lvmcfg.xml -->

   <sect3 id="lvmcfg">
   <title
>Configuring Logical Volume Manager (LVM)</title>
<para
>If you are working with computers at the level of system administrator or <quote
>advanced</quote
> user, you have surely seen the situation where some disk partition (usually the most important one) was short on space, while some other partition was grossly underused and you had to manage this situation with moving stuff around, symlinking, etc. </para
><para
>To avoid the described situation you can use Logical Volume Manager (LVM). Simply said, with LVM you can combine your partitions (<firstterm
>physical volumes</firstterm
> in LVM lingo) to form a virtual disc (so called <firstterm
>volume group</firstterm
>), which can then be divided into virtual partitions (<firstterm
>logical volumes</firstterm
>). The point is that logical volumes (and of course underlying volume groups) can span across several physical discs. </para
><para
>Now when you realize you need more space for your old 160GB <filename
>/home</filename
> partition, you can simply add a new 300GB disc to the computer, join it with your existing volume group and then resize the logical volume which holds your <filename
>/home</filename
> filesystem and voila &mdash; your users have some room again on their renewed 460GB partition. This example is of course a bit oversimplified. If you haven't read it yet, you should consult the <ulink url="&url-lvm-howto;"
>LVM HOWTO</ulink
>. </para
><para
>LVM setup in &d-i; is quite simple. At first, you have to mark your partitions to be used as physical volumes for LVM. (This is done in <command
>partman</command
> in the <guimenu
>Partition settings</guimenu
> menu where you should select <menuchoice
> <guimenu
>Use as:</guimenu
> <guimenuitem
>physical volume for LVM</guimenuitem
> </menuchoice
>.) Then start the <command
>lvmcfg</command
> module (either directly from <command
>partman</command
> or from the &d-i;'s main menu) and combine physical volumes to volume group(s) under the <guimenuitem
>Modify volume groups (VG)</guimenuitem
> menu. After that, you should create logical volumes on the top of volume groups from the menu <guimenuitem
>Modify logical volumes (LV)</guimenuitem
>. <note arch="powerpc"
><para
>There is no widely accepted standard to identify partitions containing LVM data on Apple Power Macintosh hardware. On this particular hardware, the above procedure for creating physical volumes and volume groups will not work. There is a good workaround for this limitation, provided you are familiar with the underlying LVM tools. </para
><para
>To install using logical volumes on Power Macintosh hardware you should create all the disk partitions for your logical volumes as usual. In the <guimenu
>Partition settings</guimenu
> menu you should choose <menuchoice
><guimenu
>Use as:</guimenu
> <guimenuitem
>Do Not Use</guimenuitem
></menuchoice
> for these partitions (you will not be offered the option to use the partition as a physical volume). When you are done with creating all your partitions, you should start the logical volume manager as usual. However, since no physical volumes have been created you must now access the command shell available on the second virtual terminal (see <xref linkend="shell"/>) and create them manually. </para
><para
>Use the <command
>pvcreate</command
> command at the shell command prompt to create a physical volume on each of your chosen partitions. Then use the <command
>vgcreate</command
> command to create each volume group you want. You can safely ignore any errors about incorrect metadata area header checksums and fsync failures while doing this. When you have finished creating all your volume groups, you should go back to the first virtual terminal and skip directly to the <command
>lvmcfg</command
> menu items for logical volume management. You will see your volume groups and you can create the logical volumes you need as usual. </para
></note>

</para
><para
>After returning from <command
>lvmcfg</command
> back to <command
>partman</command
>, you will see any created logical volumes in the same way as ordinary partitions (and you should treat them like that). </para>
   </sect3>
<!--   End of file using-d-i/modules/lvmcfg.xml -->

<!-- Start of file using-d-i/modules/mdcfg.xml -->

   <sect3 id="mdcfg">
   <title
>Configuring Multidisk Device (Software RAID)</title>
<para
>If you have more than one harddrive<footnote
><para
> To be honest, you can construct MD device even from partitions residing on single physical drive, but that won't bring you anything useful. </para
></footnote
> in your computer, you can use <command
>mdcfg</command
> to setup your drives for increased performance and/or better reliability of your data. The result is called <firstterm
>Multidisk Device</firstterm
> (or after its most famous variant <firstterm
>software RAID</firstterm
>). </para
><para
>MD is basically a bunch of partitions located on different disks and combined together to form a <emphasis
>logical</emphasis
> device. This device can then be used like an ordinary partition (i.e. in <command
>partman</command
> you can format it, assign a mountpoint, etc.). </para
><para
>The benefit you gain depends on a type of a MD device you are creating. Currently supported are: <variablelist
> <varlistentry
> <term
>RAID0</term
><listitem
><para
> Is mainly aimed at performance. RAID0 splits all incoming data into <firstterm
>stripes</firstterm
> and distributes them equally over each disk in the array. This can increase the speed of read/write operations, but when one of the disks fails, you will loose <emphasis
>everything</emphasis
> (part of the information is still on the healthy disk(s), the other part <emphasis
>was</emphasis
> on the failed disk). </para
><para
> The typical use for RAID0 is a partition for video editing. </para
></listitem
> </varlistentry
> <varlistentry
> <term
>RAID1</term
><listitem
><para
> Is suitable for setups where reliability is the first concern. It consists of several (usually two) equally sized partitions where every partition contains exactly the same data. This essentially means three things. First, if one of your disks fails, you still have the data mirrored on the remaining disks. Second, you can use only a fraction of the available capacity (more precisely, it is the size of the smallest partition in the RAID). Third, file reads are load balanced among the disks, which can improve performance on a server, such as a file server, that tends to be loaded with more disk reads than writes. </para
><para
> Optionally you can have a spare disk in the array which will take the place of the failed disk in the case of failure. </para
></listitem
> </varlistentry
> <varlistentry
> <term
>RAID5</term
><listitem
><para
> Is a good compromise between speed, reliability and data redundancy. RAID5 splits all incomming data into stripes and distributes them equally on all but one disks (similar to RAID0). Unlike RAID0, RAID5 also computes <firstterm
>parity</firstterm
> information, which gets written on the remaining disk. The parity disk is not static (that would be called RAID4), but is changing periodically, so the parity information is distributed equally on all disks. When one of the disks fails, the missing part of information can be computed from remaining data and its parity. RAID5 must consist of at least three active partitions. Optionally you can have a spare disk in the array which will take the place of the failed disk in the case of failure. </para
><para
> As you can see, RAID5 has similar degree of reliability like RAID1 while achieving less redundancy. On the other hand it might be a bit slower on write operation than RAID0 due to computation of parity information. </para
></listitem
> </varlistentry
> </variablelist
> To sum it up: <informaltable
> <tgroup cols="5">
<thead>
<row>
  <entry
>Τύπος</entry>
  <entry
>Minimum Devices</entry>
  <entry
>Spare Device</entry>
  <entry
>Survives disk failure?</entry>
  <entry
>Available Space</entry>
</row>
</thead>

<tbody>
<row>
  <entry
>RAID0</entry>
  <entry
>2</entry>
  <entry
>no</entry>
  <entry
>no</entry>
  <entry
>Size of the smallest partition multiplied by number of devices in RAID</entry>
</row>

<row>
  <entry
>RAID1</entry>
  <entry
>2</entry>
  <entry
>προαιρετικό</entry>
  <entry
>yes</entry>
  <entry
>Size of the smallest partition in RAID</entry>
</row>

<row>
  <entry
>RAID5</entry>
  <entry
>3</entry>
  <entry
>προαιρετικό</entry>
  <entry
>yes</entry>
  <entry
>Size of the smallest partition multiplied by (number of devices in RAID minus one) </entry>
</row>

</tbody
></tgroup
></informaltable>

</para
><para
>If you want to know the whole truth about Software RAID, have a look at <ulink url="&url-software-raid-howto;"
>Software RAID HOWTO</ulink
>. </para
><para
>To create a MD device, you need to have the desired partitions it should consist of marked for use in a RAID. (This is done in <command
>partman</command
> in the <guimenu
>Partition settings</guimenu
> menu where you should select <menuchoice
> <guimenu
>Use as:</guimenu
> <guimenuitem
>physical volume for RAID</guimenuitem
> </menuchoice
>.) </para
><warning
><para
>Support for MD is a relatively new addition to the installer. You may experience problems for some RAID levels and in combination with some bootloaders if you try to use MD for the root (<filename
>/</filename
>) filesystem. For experienced users, it may be possible to work around some of these problems by executing some configuration or installation steps manually from a shell. </para
></warning
><para
>Next, you should choose <guimenuitem
>Configure software RAID</guimenuitem
> from the main <command
>partman</command
> menu. On the first screen of <command
>mdcfg</command
> simply select <guimenuitem
>Create MD device</guimenuitem
>. You will be presented with a list of supported types of MD devices, from which you should choose one (e.g. RAID1). What follows depends on the type of MD you selected. </para>

<itemizedlist>
<listitem
><para
>RAID0 is simple &mdash; you will be issued with the list of available RAID partitions and your only task is to select the partitions which will form the MD. </para
></listitem>
<listitem
><para
>RAID1 is a bit more tricky. First, you will be asked to enter the number of active devices and the number of spare devices which will form the MD. Next, you need to select from the list of available RAID partitions those that will be active and then those that will be spare. The count of selected partitions must be equal to the number provided few seconds ago. Don't worry. If you make a mistake and select different number of partitions, the &d-i; won't let you continue until you correct the issue. </para
></listitem>
<listitem
><para
>RAID5 has similar setup procedure as RAID1 with the exception that you need to use at least <emphasis
>three</emphasis
> active partitions. </para
></listitem>
</itemizedlist>

<para
>It is perfectly possible to have several types of MD at once. For example if you have three 200 GB hard drives dedicated to MD, each containing two 100 GB partitions, you can combine first partitions on all three disk into the RAID0 (fast 300 GB video editing partition) and use the other three partitions (2 active and 1 spare) for RAID1 (quite reliable 100 GB partition for <filename
>/home</filename
>). </para
><para
>After you setup MD devices to your liking, you can <guimenuitem
>Finish</guimenuitem
> <command
>mdcfg</command
> to return back to the <command
>partman</command
> to create filesystems on your new MD devices and assign them the usual attributes like mountpoints. </para>
   </sect3>
<!--   End of file using-d-i/modules/mdcfg.xml -->
  </sect2>

  <sect2 id="di-install-base">
  <title
>Installing the Base System</title>
<para
>Although this stage is the least problematic, it consumes most time of the install because it downloads, verifies and unpacks the whole base system. If you have a slow computer or network connection, this could take some time. </para>


<!-- Start of file using-d-i/modules/base-installer.xml -->

   <sect3 id="base-installer">
   <title
>Base System Installation</title>

<para
>During the Base installation, package unpacking and setup messages are redirected to <userinput
>tty3</userinput
>. You can access this terminal by pressing <keycombo
><keycap
>Left Alt</keycap
><keycap
>F3</keycap
></keycombo
>; get back to the main installer process with <keycombo
><keycap
>Left Alt</keycap
><keycap
>F1</keycap
></keycombo
>. </para
><para
>The unpack/setup messages generated by the base installation are saved in <filename
>/var/log/messages</filename
> when the installation is performed over a serial console. </para
><para
>As part of the installation, a Linux kernel will be installed. At the default priority, the installer will choose one for you that best matches your hardware. In lower priority modes, you will be able to choose from a list of available kernels. </para>
   </sect3>
<!--   End of file using-d-i/modules/base-installer.xml -->
  </sect2>

  <sect2 id="di-make-bootable">
  <title
>Making Your System Bootable</title>

<para condition="supports-nfsroot"
>If you are installing a diskless workstation, obviously, booting off the local disk isn't a meaningful option, and this step will be skipped. <phrase arch="sparc"
>You may wish to set the OpenBoot to boot from the network by default; see <xref linkend="boot-dev-select-sun"/>.</phrase
> </para
><para
>Note that multiple operating systems booting on a single machine is still something of a black art. This document does not even attempt to document the various boot managers, which vary by architecture and even by subarchitecture. You should see your boot manager's documentation for more information. </para>


<!-- Start of file using-d-i/modules/os-prober.xml -->

   <sect3 id="os-prober">
   <title
>Detecting other operating systems</title>

<para
>Before a boot loader is installed, the installer will attempt to probe for other operating systems which are installed on the machine. If it finds a supported operating system, you will be informed of this during the boot loader installation step, and the computer will be configured to boot this other operating system in addition to Debian. </para
><para
>Note that multiple operating systems booting on a single machine is still something of a black art. The automatic support for detecting and setting up boot loaders to boot other operating systems varies by architecture and even by subarchitecture. If it does not work you should consult your boot manager's documentation for more information. </para>

<note condition="sarge"
><para
>The installer may fail to detect other operating systems if the partitions on which they reside are mounted when the detection takes place. This may occur if you select a mountpoint (e.g. /win) for a partition containing another operating system in <command
>partman</command
>, or if you have mounted partitions manually from a console. </para
></note>

   </sect3>
<!--   End of file using-d-i/modules/os-prober.xml -->

<!-- Start of file using-d-i/modules/alpha/aboot-installer.xml -->

  <sect3 arch="alpha">
  <title
>Install <command
>aboot</command
> on a Hard Disk</title>
<para
>If you have booted from SRM, if you select this option, the installer will write <command
>aboot</command
> to the first sector of the disk on which you installed Debian. Be <emphasis
>very</emphasis
> careful &mdash; it is <emphasis
>not</emphasis
> possible to boot multiple operating systems (e.g. GNU/Linux, Free/Open/NetBSD, OSF/1 a.k.a. Digital Unix a.k.a. Tru64 Unix, or OpenVMS) from the same disk. If you also have a different operating system installed on the disk where you have installed Debian, you will have to boot GNU/Linux from a floppy instead. </para>
  </sect3>
<!--   End of file using-d-i/modules/alpha/aboot-installer.xml -->

<!-- Start of file using-d-i/modules/hppa/palo-installer.xml -->

  <sect3 arch="hppa">
  <title
><command
>palo</command
>-installer</title>
<para
>The bootloader on PA-RISC is <quote
>palo</quote
>. <command
>PALO</command
> is similar in configuration and usage to <command
>LILO</command
>, with a few exceptions. First of all, <command
>PALO</command
> allows you to boot any kernel image on your boot partition. This is because <command
>PALO</command
> can actually read Linux partitions. </para
><para condition="FIXME"
>hppa FIXME ( need more info ) </para>
  </sect3>
<!--   End of file using-d-i/modules/hppa/palo-installer.xml -->

<!-- Start of file using-d-i/modules/i386/grub-installer.xml -->

  <sect3 arch="i386">
  <title
>Install the <command
>Grub</command
> Boot Loader on a Hard Disk</title>
<para
>The main &architecture; boot loader is called <quote
>grub</quote
>. Grub is a flexible and robust boot loader and a good default choice for newbies and old hands alike. </para
><para
>By default, grub will be installed into the Master Boot Record (MBR), where it will take over complete control of the boot process. If you prefer, you can install it elsewhere. See the grub manual for complete information. </para
><para
>If you do not want to install grub at all, use the Back button to get to the main menu, and from there select whatever bootloader you would like to use. </para>
  </sect3>
<!--   End of file using-d-i/modules/i386/grub-installer.xml -->

<!-- Start of file using-d-i/modules/i386/lilo-installer.xml -->

  <sect3 arch="i386">
  <title
>Install the <command
>LILO</command
> Boot Loader on a Hard Disk</title>
<para
>The second &architecture; boot loader is called <quote
>LILO</quote
>. It is an old complex program which offers lots of functionality, including DOS, Windows, and OS/2 boot management. Please carefully read the instructions in the directory <filename
>/usr/share/doc/lilo/</filename
> if you have special needs; also see the <ulink url="&url-lilo-howto;"
>LILO mini-HOWTO</ulink
>. </para>
<note
><para
>Currently the LILO installation will only create menu entries for other operating systems if these can be <firstterm
>chainloaded</firstterm
>. This means you may have to manually add a menu entry for operating systems like GNU/Linux and GNU/Hurd after the installation. </para
></note>
<para
>&d-i; presents you three choices where to install the <command
>LILO</command
> boot loader: <variablelist>
<varlistentry>
<term
>Master Boot Record (MBR)</term
><listitem
><para
>This way the <command
>LILO</command
> will take complete control of the boot process. </para
></listitem
></varlistentry>
<varlistentry>
<term
>new Debian partition</term
><listitem
><para
>Choose this if you want to use another boot manager. <command
>LILO</command
> will install itself at the beginning of the new Debian partition and it will serve as a secondary boot loader. </para
></listitem
></varlistentry>
<varlistentry>
<term
>Other choice</term
><listitem
><para
>Useful for advanced users who want to install <command
>LILO</command
> somewhere else. In this case you will be asked for desired location. You can use devfs style names, such as those that start with <filename
>/dev/ide</filename
>, <filename
>/dev/scsi</filename
>, and <filename
>/dev/discs</filename
>, as well as traditional names, such as <filename
>/dev/hda</filename
> or <filename
>/dev/sda</filename
>. </para
></listitem
></varlistentry>
</variablelist>

</para
><para
>If you can no longer boot into Windows 9x (or DOS) after this step, you'll need to use a Windows 9x (MS-DOS) boot disk and use the <userinput
>fdisk /mbr</userinput
> command to reinstall the MS-DOS master boot record &mdash; however, this means that you'll need to use some other way to get back into Debian! For more information on this please read <xref linkend="reactivating-win"/>. </para>
  </sect3>
<!--   End of file using-d-i/modules/i386/lilo-installer.xml -->

<!-- Start of file using-d-i/modules/ia64/elilo-installer.xml -->

  <sect3 arch="ia64">
  <title
>Install the <command
>ELILO</command
> Boot Loader on a Hard Disk</title>
<para
>The &architecture; boot loader is called <quote
>elilo</quote
>. It is modeled on the <quote
>lilo</quote
> boot loader for the x86 architecture and uses a similar configuration file. However, instead of writing an MBR or partition boot record to the disk, it copies the necessary files to a separate FAT formatted disk partition and modifies the <guimenuitem
>EFI Boot Manager</guimenuitem
> menu in the firmware to point to the files in the EFI partition. The <command
>elilo</command
> boot loader is really in two parts. The <filename
>/usr/sbin/elilo</filename
> command manages the partition and copies file into it. The <filename
>elilo.efi</filename
> program is copied into the EFI partition and then run by the <quote
>EFI Boot Manager</quote
> to actually do the work of loading and starting the Linux kernel. </para
><para
>The <quote
>elilo</quote
> configuration and installation is done as the last step of installing the packages of the base installation. &d-i; will present you with a list of potential disk partitions that it has found suitable for an EFI partition. Select the partition you set up earlier in the installation, typically a partition on the same disk that contains your <emphasis
>root</emphasis
> filesystem. </para>

  <warning
><title
>Choose the correct partition!</title>

<para
>The criteria for selecting a partition is that it is FAT format filesystem with its <emphasis
>boot</emphasis
> flag set. &d-i; may show multiple choices depending on what it finds from scanning all of the disks of the system including EFI partitions of other system disks and EFI diagnostic partitions. Remember, the <command
>elilo</command
> may format the partition during the installation, erasing any previous contents! </para
></warning>

  </sect3>

  <sect3 arch="ia64">
  <title
>EFI Partition Contents</title>

<para
>The EFI partition is a FAT filesystem format partition on one of the hard disks of the system, usually the same disk that contains the <emphasis
>root</emphasis
> filesystem. It is normally not mounted on a running system as it is only needed by the <quote
>EFI Boot Manager</quote
> to load the system and the installer part of the <command
>elilo</command
> writes to the filesystem directly. The <command
>/usr/sbin/elilo</command
> utility writes the following files into the <filename
>efi/debian</filename
> directory of the EFI partition during the installation. Note that the <quote
>EFI Boot Manager</quote
> would find these files using the path <filename
>fs<replaceable
>n</replaceable
>:\efi\debian</filename
>. There may be other files in this filesystem as well over time as the system is updated or re-configured. </para>

<variablelist>

<varlistentry>
<term
><filename
>elilo.conf</filename
></term>
<listitem
><para
>This is the configuration file read by the boot loader when it starts. It is a copy of the <filename
>/etc/elilo.conf</filename
> with the filenames re-written to refer to files in the EFI partition. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>elilo.efi</filename
></term>
<listitem
><para
>This is the boot loader program that the <quote
>EFI Boot Manager</quote
> runs to boot the system. It is the program behind the <guimenuitem
>Debian GNU/Linux</guimenuitem
> menu item of the <quote
>EFI Boot Manager</quote
> command menu. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>initrd.img</filename
></term>
<listitem
><para
>This is the initial root filesystem used to boot the kernel. It is a copy of the file referenced in the <filename
>/etc/elilo.conf</filename
>. In a standard Debian installation it would be the file in <filename
>/boot</filename
> pointed to by the symbolic link <filename
>/initrd.img</filename
>. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>readme.txt</filename
></term>
<listitem
><para
>This is a small text file warning you that the contents of the directory are managed by the <command
>elilo</command
> and that any local changes would be lost at the next time <filename
>/usr/sbin/elilo</filename
> is run. </para
></listitem
></varlistentry>

<varlistentry>
<term
><filename
>vmlinuz</filename
></term>
<listitem
><para
>This is the compressed kernel itself. It is a copy of the file referenced in the <filename
>/etc/elilo.conf</filename
>. In a standard Debian installation it would be the file in <filename
>/boot</filename
> pointed to by the symbolic link <filename
>/vmlinuz</filename
>. </para
></listitem
></varlistentry>

</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/ia64/elilo-installer.xml -->

<!-- Start of file using-d-i/modules/mips/arcboot-installer.xml -->

  <sect3 arch="mips">
  <title
><command
>arcboot</command
>-installer</title>
<para
>The boot loader on SGI Indys is <command
>arcboot</command
>. It has to be installed on the same hard disk as the kernel (this is done automatically by the installer). Arcboot supports different configurations which are set up in <filename
>/etc/arcboot.conf</filename
>. Each configuration has a unique name, the default setup as created by the installer is <quote
>linux</quote
>. After arcboot has been installed, the system can be booted from hard disk by setting some firmware environment variables entering <informalexample
><screen
>
<userinput> setenv SystemPartition scsi(<replaceable>scsi</replaceable>)disk(<replaceable>disk</replaceable>)rdisk(0)partition(0)</userinput>
<userinput> setenv OSLoadPartition scsi(<replaceable>scsi</replaceable>)disk(<replaceable>disk</replaceable>)rdisk(0)partition(<replaceable>partnr</replaceable>)</userinput>
<userinput> setenv OSLoader arcboot</userinput>
<userinput> setenv OSLoadFilename <replaceable>config</replaceable></userinput>
<userinput> setenv AutoLoad yes</userinput>
</screen
></informalexample
> on the firmware prompt, and then typing <command
>boot</command
>. </para>

<variablelist>
<varlistentry>
<term
> <replaceable
>scsi</replaceable
> </term>
<listitem
><para
>is the SCSI bus to be booted from, this is <userinput
>0</userinput
> for the onboard controllers </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>disk</replaceable
> </term>
<listitem
><para
>is the SCSI ID of the hard disk on which <command
>arcboot</command
> is installed </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>partnr</replaceable
> </term>
<listitem
><para
>is the number of the partition on which <filename
>/etc/arcboot.conf</filename
> resides </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>config</replaceable
> </term>
<listitem
><para
>is the name of the configuration entry in <filename
>/etc/arcboot.conf</filename
>, which is <quote
>linux</quote
> by default. </para
></listitem>
</varlistentry>
</variablelist>

  </sect3>
<!--   End of file using-d-i/modules/mips/arcboot-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/colo-installer.xml -->
<!--   End of file using-d-i/modules/mipsel/colo-installer.xml -->

<!-- Start of file using-d-i/modules/mipsel/delo-installer.xml -->

  <sect3 arch="mipsel">
  <title
><command
>delo</command
>-installer</title>
<para
>The boot loader on DECstations is <command
>DELO</command
>. It has to be installed on the same hard disk as the kernel (this is done automatically by the installer). DELO supports different configurations which are set up in <filename
>/etc/delo.conf</filename
>. Each configuration has a unique name, the default setup as created by the installer is <quote
>linux</quote
>. After DELO has been installed, the system can be booted from hard disk by entering <informalexample
><screen
>
<userinput>boot <replaceable>#</replaceable>/rz<replaceable>id</replaceable> <replaceable>partnr</replaceable>/<replaceable>name</replaceable></userinput>
</screen
></informalexample
> on the firmware prompt. </para>

<variablelist>
<varlistentry>
<term
> <replaceable
>#</replaceable
> </term>
<listitem
><para
>is the TurboChannel device to be booted from, on most DECstations this is <userinput
>3</userinput
> for the onboard controllers </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>id</replaceable
> </term>
<listitem
><para
>is the SCSI ID of the hard disk on which <command
>DELO</command
> is installed </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>partnr</replaceable
> </term>
<listitem
><para
>is the number of the partition on which <filename
>/etc/delo.conf</filename
> resides </para
></listitem>
</varlistentry>
<varlistentry>
<term
> <replaceable
>name</replaceable
> </term>
<listitem
><para
>is the name of the configuration entry in <filename
>/etc/delo.conf</filename
>, which is <quote
>linux</quote
> by default. </para
></listitem>
</varlistentry>
</variablelist>

<para
>In case <filename
>/etc/delo.conf</filename
> is on the first partition on the disk and the default configuration shall be booted, it is sufficient to use <informalexample
><screen
><userinput>boot #/rz<replaceable>id</replaceable></userinput>
</screen
></informalexample>

</para>
  </sect3>
<!--   End of file using-d-i/modules/mipsel/delo-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/yaboot-installer.xml -->

  <sect3 arch="powerpc">
  <title
>Install <command
>Yaboot</command
> on a Hard Disk</title>
<para
>Newer (mid 1998 and on) PowerMacs use <command
>yaboot</command
> as their boot loader. The installer will set up <command
>yaboot</command
> automatically, so all you need is a small 820k partition named <quote
>bootstrap</quote
> with type <emphasis
>Apple_Bootstrap</emphasis
> created back in the partitioning component. If this step completes successfully then your disk should now be bootable and OpenFirmware will be set to boot &debian;. </para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/yaboot-installer.xml -->

<!-- Start of file using-d-i/modules/powerpc/quik-installer.xml -->

  <sect3 arch="powerpc">
  <title
>Install <command
>Quik</command
> on a Hard Disk</title>
<para
>The boot loader for OldWorld Power Macintosh machines is <command
>quik</command
>. You can also use it on CHRP. The installer will attempt to set up <command
>quik</command
> automatically. The setup has been known to work on 7200, 7300, and 7600 Powermacs, and on some Power Computing clones. </para>
  </sect3>
<!--   End of file using-d-i/modules/powerpc/quik-installer.xml -->

<!-- Start of file using-d-i/modules/s390/zipl-installer.xml -->

  <sect3 arch="s390">
  <title
><command
>zipl</command
>-installer</title>
<para
>The boot loader on &arch-title; is <quote
>zipl</quote
>. <command
>ZIPL</command
> is similar in configuration and usage to <command
>LILO</command
>, with a few exceptions. Please take a look at <quote
>LINUX for &arch-title; Device Drivers and Installation Commands</quote
> from IBM's developerWorks web site if you want to know more about <command
>ZIPL</command
>. </para>
  </sect3>
<!--   End of file using-d-i/modules/s390/zipl-installer.xml -->

<!-- Start of file using-d-i/modules/sparc/silo-installer.xml -->

  <sect3 arch="sparc">
  <title
>Install the <command
>SILO</command
> Boot Loader on a Hard Disk</title>
<para
>The standard &architecture; boot loader is called <quote
>silo</quote
>. It is documented in <filename
>/usr/share/doc/silo/</filename
>. <command
>SILO</command
> is similar in configuration and usage to <command
>LILO</command
>, with a few exceptions. First of all, <command
>SILO</command
> allows you to boot any kernel image on your drive, even if it is not listed in <filename
>/etc/silo.conf</filename
>. This is because <command
>SILO</command
> can actually read Linux partitions. Also, <filename
>/etc/silo.conf</filename
> is read at boot time, so there is no need to rerun <command
>silo</command
> after installing a new kernel like you would with <command
>LILO</command
>. <command
>SILO</command
> can also read UFS partitions, which means it can boot SunOS/Solaris partitions as well. This is useful if you want to install GNU/Linux alongside an existing SunOS/Solaris install. </para>
  </sect3>
<!--   End of file using-d-i/modules/sparc/silo-installer.xml -->

<!-- Start of file using-d-i/modules/nobootloader.xml -->

   <sect3 id="nobootloader">
   <title
>Continue Without Boot Loader</title>

<para
>This option can be used to complete the installation even when no boot loader is to be installed, either because the arch/subarch doesn't provide one, or because none is desired (e.g. you will use existing boot loader). <phrase arch="m68k"
>This option is especially useful for Macintosh, Atari, and Amiga systems, where the original operating system must be maintained on the box and used to boot GNU/Linux.</phrase
> </para
><para
>If you plan to manually configure your bootloader, you should check the name of the installed kernel in <filename
>/target/boot</filename
>. You should also check that directory for the presence of an <firstterm
>initrd</firstterm
>; if one is present, you will probably have to instruct your bootloader to use it. Other information you will need are the disk and partition you selected for your <filename
>/</filename
> filesystem and, if you chose to install <filename
>/boot</filename
> on a separate partition, also your <filename
>/boot</filename
> filesystem. </para>
   </sect3>
<!--   End of file using-d-i/modules/nobootloader.xml -->
  </sect2>

  <sect2 id="di-finish">
  <title
>Finishing the First Stage</title>
<para
>These are the last bits to do before rebooting to your new Debian. It mostly consists of tidying up after the &d-i;. </para>


<!-- Start of file using-d-i/modules/prebaseconfig.xml -->

   <sect3 id="prebaseconfig">
   <title
>Finish the Installation and Reboot</title>

<para
>This is the last step in the initial Debian installation process. You will be prompted to remove the boot media (CD, floppy, etc) that you used to boot the installer. The installer will do any last minute tasks, and then reboot into your new Debian system. </para
><para arch="s390"
>Select the <guimenuitem
>Finish the installation</guimenuitem
> menu item which will halt the system because rebooting is not supported on &arch-title; in this case. You then need to IPL GNU/Linux from the DASD which you selected for the root filesystem during the first steps of the installation. </para>
   </sect3>
<!--   End of file using-d-i/modules/prebaseconfig.xml -->
  </sect2>

  <sect2 id="di-miscellaneous">
  <title
>Miscellaneous</title>
<para
>The components listed in this section are usually not involved in the installation process, but are waiting in the background to help the user in case something goes wrong. </para>


<!-- Start of file using-d-i/modules/save-logs.xml -->

   <sect3 id="save-logs">
   <title
>Saving the installation logs</title>

<para
>If the installation is successful, the logfiles created during the installation process will be automatically saved to <filename
>/var/log/debian-installer/</filename
> on your new Debian system. </para
><para
>Choosing <guimenuitem
>Save debug logs</guimenuitem
> from the main menu allows you to save the log files to a floppy disk<phrase condition="etch"
>, network, hard disk, or other media</phrase
>. This can be useful if you encounter fatal problems during the installation and wish to study the logs on another system or attach them to an installation report. </para>
   </sect3>
<!--   End of file using-d-i/modules/save-logs.xml -->

<!-- Start of file using-d-i/modules/cdrom-checker.xml -->
<!--   End of file using-d-i/modules/cdrom-checker.xml -->

<!-- Start of file using-d-i/modules/shell.xml -->

   <sect3 id="shell">
   <title
>Using the Shell and Viewing the Logs</title>
   <!-- TODO: There is nothing about logs in this section! -->

<para
>There is an <guimenuitem
>Execute a Shell</guimenuitem
> item on the menu. If the menu is not available when you need to use the shell, press <keycombo
><keycap
>Left Alt</keycap
> <keycap
>F2</keycap
></keycombo
> (on a Mac keyboard, <keycombo
><keycap
>Option</keycap
> <keycap
>F2</keycap
> </keycombo
>) to switch to the second <emphasis
>virtual console</emphasis
>. That's the <keycap
>Alt</keycap
> key on the left-hand side of the <keycap
>space bar</keycap
>, and the <keycap
>F2</keycap
> function key, at the same time. This is a separate window running a Bourne shell clone called <command
>ash</command
>. </para
><para
>At this point you are booted from the RAM disk, and there is a limited set of Unix utilities available for your use. You can see what programs are available with the command <command
>ls /bin /sbin /usr/bin /usr/sbin</command
> and by typing <command
>help</command
>. The text editor is <command
>nano</command
>. The shell has some nice features like autocompletion and history. </para
><para
>Use the menus to perform any task that they are able to do &mdash; the shell and commands are only there in case something goes wrong. In particular, you should always use the menus, not the shell, to activate your swap partition, because the menu software can't detect that you've done this from the shell. Press <keycombo
><keycap
>Left Alt</keycap
> <keycap
>F1</keycap
></keycombo
> to get back to menus, or type <command
>exit</command
> if you used a menu item to open the shell. </para>
   </sect3>
<!--   End of file using-d-i/modules/shell.xml -->

<!-- Start of file using-d-i/modules/baseconfig.xml -->

   <sect3 id="baseconfig">
   <title
>Running <command
>base-config</command
> From Within &d-i;</title>

<para
>It is possible to configure the base system within the first stage installer (before rebooting from the hard drive), by running <command
>base-config</command
> in a <firstterm
>chroot</firstterm
> environment. This is mainly useful for testing the installer and a vast majority of people should avoid it. </para>
   </sect3>
<!--   End of file using-d-i/modules/baseconfig.xml -->
  </sect2>
 </sect1>
<!--   End of file using-d-i/components.xml -->

</chapter>

<!--   End of file using-d-i/using-d-i.xml -->
